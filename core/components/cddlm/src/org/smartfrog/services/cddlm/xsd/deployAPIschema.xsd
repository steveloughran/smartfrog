<?xml version="1.0" encoding="UTF-8" ?>
<xsd:schema elementFormDefault="qualified"
  targetNamespace="http://gridforum.org/cddlm/serviceAPI/types/2004/07/30"
  xmlns:types="http://gridforum.org/cddlm/serviceAPI/types/2004/07/30"
  xmlns="http://gridforum.org/cddlm/serviceAPI/types/2004/07/30"
  xmlns:xsd="http://www.w3.org/2001/XMLSchema"
  xmlns:wsa="http://schemas.xmlsoap.org/ws/2003/03/addressing"
  >
  <!--
  xmlns:jsdl="http://www.gridforum.org/JSDL"
  xmlns:wsbf="http://www.ibm.com/xmlns/stdwip/web-services/WS-BaseFaults"
    -->
  <!-- ============================================================= -->
  <xsd:annotation>
    <xsd:documentation>
  
    This is the XSD describing the types of the CDDLM service API


    Version: 0.1.
    This is an initial draft for the first demonstration-grade prototypes.
    It may change completely in future.


    The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
    NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
    "OPTIONAL" in this document are to be interpreted as described in
    RFC 2119.
    http://www.ietf.org/rfc/rfc2119.txt

    </xsd:documentation>
  </xsd:annotation>
  <!-- ============================================================= -->

  
  <!-- ============================================================= -->
  <!-- BEGIN IMPORTS -->
  <!-- ============================================================= -->

  <xsd:import
    namespace="http://schemas.xmlsoap.org/ws/2003/03/addressing"
    schemaLocation="ws-addressing.xsd"/>

  <!-- <xsd:import
     namespace="http://www.ibm.com/xmlns/stdwip/web-services/WS-BaseFaults"
     schemaLocation="WS-BaseFaults.xsd"/> -->

  <!-- ============================================================= -->
  <!-- END IMPORTS -->
  <!-- ============================================================= -->

  <!-- low level type: XML with no validations, namespace = ##other -->
  <xsd:complexType name="unboundedXMLOtherNamespace">
    <xsd:sequence>
      <xsd:any processContents="lax" minOccurs="0" maxOccurs="unbounded" namespace="##other"/>
    </xsd:sequence>
  </xsd:complexType>

  <!-- low level type: XML with no validations, namespace = ##any  -->
  <xsd:complexType name="unboundedXMLAnyNamespace">
    <xsd:sequence>
      <xsd:any processContents="lax" minOccurs="0" maxOccurs="unbounded" namespace="##any"/>
    </xsd:sequence>
  </xsd:complexType>

  <!-- ============================================================= -->
  <!-- BEGIN SIMPLETYPES -->
  <!-- ============================================================= -->

  <xsd:simpleType name="callbackEnum">
    <xsd:annotation>
      <xsd:documentation>
      Enumeration of supported callback types. Any
      unexpected type constitutes an error and should be
      flagged.
        -none: we have no callback
        -direct:  caller calls URL with a predefined event message
        -ws-notification:  callbacks via WS-N
        -ws-eventing

      </xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="ws-notification">
        <xsd:annotation>
          <xsd:documentation>
            Notification
          </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="cddlm-prototype">
      <xsd:annotation>
        <xsd:documentation>
            Non-standard callback
        </xsd:documentation>
      </xsd:annotation>
    </xsd:enumeration>
      <xsd:enumeration value="ws-eventing">
    <xsd:annotation>
      <xsd:documentation>
            WS-eventing
      </xsd:documentation>
    </xsd:annotation>
  </xsd:enumeration>
    </xsd:restriction>
  </xsd:simpleType>


  <xsd:simpleType name="lifecycleStateEnum">
    <xsd:annotation>
      <xsd:documentation>
      Enumeration of lifecycle states.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="null">
        <xsd:annotation>
          <xsd:documentation>
            undefined state
          </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>

      <xsd:enumeration value="instantiated">
        <xsd:annotation>
          <xsd:documentation>
            Instantiated component
          </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="initialized">
        <xsd:annotation>
          <xsd:documentation>
            Initialized component
          </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="running">
        <xsd:annotation>
          <xsd:documentation>
            Running deployment
          </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="failed">
        <xsd:annotation>
          <xsd:documentation>
            Application has failed
          </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="terminated">
        <xsd:annotation>
          <xsd:documentation>
            Application has terminated
          </xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
    </xsd:restriction>
  </xsd:simpleType>

  <!-- ============================================================= -->
  <!-- naming rules for application -->
  <!-- we may want a more restrictive policy, such as
    <xsd:restriction base="xsd:string">
      <xsd:pattern value="[\p{L}\-\.][\p{L}\-\.\P{Nd}]*"/>
    </xsd:restriction>
  -->
  <!-- ============================================================= -->
  <xsd:simpleType name="applicationNameType">
    <xsd:annotation>
      <xsd:documentation>
        This is the policy for the naming of applications
      </xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:NCName"/>
  </xsd:simpleType>

  <!-- ============================================================= -->
  <!-- The response to deployment requests is the URI to a endpoint
       within the Basic-Services generated component model -->
  <!-- Commentary: we may want to make this a WS-Addressing endpoint -->
  <!-- ============================================================= -->

  <xsd:simpleType name="applicationReferenceType">
    <xsd:annotation>
      <xsd:documentation>
        This is the policy for the naming of applications
      </xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:anyURI"/>
  </xsd:simpleType>

  <!-- ============================================================= -->
  <!-- allows the caller to pass a URL to a deploy descriptor, instead
       of the body itself. This allows signed descriptors inside
       files to be used as a source of data -->
  <!-- ============================================================= -->
  <xsd:simpleType name="remoteDescriptorType">
    <xsd:annotation>
      <xsd:documentation>
        Descriptors can also be URLs.
        We extend the URI type in case of future needs to add attributes such as
        authentication information.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:anyURI"/>
  </xsd:simpleType>

  <!-- ============================================================= -->
  <!-- BEGIN COMPLEXTYPES -->
  <!-- ============================================================= -->

  <!-- ============================================================= -->
  <!-- callback address union -->
  <!-- ============================================================= -->

  <xsd:complexType name="callbackAddressType">
    <xsd:annotation>
      <xsd:documentation>
      holder for different callback types
      </xsd:documentation>
    </xsd:annotation>
    <xsd:choice>
      <xsd:element name="uri" type="xsd:anyURI"/>
      <xsd:element name="address" type="wsa:EndpointReferenceType"/>
    </xsd:choice>
  </xsd:complexType>


  <!-- ============================================================= -->
  <!-- composite representation of callback enum, address and identifier -->
  <!-- ============================================================= -->

  <xsd:complexType name="callbackInformationType">
    <xsd:annotation>
      <xsd:documentation>
      Callback information consists of a selection of a callback mechanism,
      the address for it, and an identifier that is used in all messages
      to help identify the conversation.

      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="type" type="types:callbackEnum"/>
      <xsd:element name="address" type="types:callbackAddressType"/>
      <xsd:element name="identifier" type="xsd:string"/>
    </xsd:sequence>
  </xsd:complexType>




  <!-- ============================================================= -->
  <!--
    we could actually explicitly declare both the smartfrog
    and CDL types in here, but are not, because we can be independent
    of all deployment types here
  -->
  <!-- ============================================================= -->
  <xsd:complexType name="deploymentDescriptorType">
    <xsd:annotation>
      <xsd:documentation>
      A deployment descriptor is either arbitrary XML, or a URL to arbitrary XML
      </xsd:documentation>
    </xsd:annotation>
    <xsd:choice>
      <xsd:element name="source" type="xsd:anyURI"/>
      <xsd:element name="data">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:any processContents="lax" namespace="##other" minOccurs="1" maxOccurs="1"/>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
    </xsd:choice>
  </xsd:complexType>


  <!-- ============================================================= -->
  <!-- TODO: incorporate JSDL into the specification -->
  <!-- ============================================================= -->
  <xsd:complexType name="jsdlType">
    <xsd:annotation>
      <xsd:documentation>
        This is the jsdl content. It should be in the namespace http://www.gridforum.org/JSDL.
        The reason we are not explicitly declaring the JSDL import is to
        (a) stop the SOAP stack trying to parse it.
        (b) decouple the API from changes in the spec.
        (c) handle WSDL parsers that are no good at taking in extra schemas
            (like the Mono implementation)
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:any processContents="lax" minOccurs="0" maxOccurs="unbounded" namespace="##other"/>
    </xsd:sequence>
  </xsd:complexType>

  <!-- ============================================================= -->
  <!-- application naming -->
  <!-- ============================================================= -->
  <xsd:complexType name="applicationNameOrReferenceType">
    <xsd:annotation>
      <xsd:documentation>
      A type that can contain either an application name or a reference.
      Names are only unique to a host, but the combination of (host,name) is
      guaranteed to be unique and valid over multiple deployment.
      References are only valid for a single deployment.
      URL information
      </xsd:documentation>
    </xsd:annotation>
    <xsd:choice>
      <xsd:element name="name" type="types:applicationNameType"/>
      <xsd:element name="reference" type="types:applicationReferenceType"/>
    </xsd:choice>
  </xsd:complexType>


  <!-- ============================================================= -->
  <!-- options -->
  <!-- ============================================================= -->
  <xsd:complexType name="optionType">
    <xsd:annotation>
      <xsd:documentation>
        Options are @uri plus (string|integer|boolean|XML)
        really, all could be XML, but that forces too much parse complexity
        having string and int attrs makes it simpler.

        A processor of the options MUST ignore options that it does not recognise
        and that are marked mustUnderstand==false.
        It MUST fail if it receives an option marked mustUnderstand==true that it
        does not recognise or can not process in accordance with the
        normative/descriptive definition of the option.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:choice>
      <xsd:element name="string" type="xsd:string"/>
      <xsd:element name="integer" type="xsd:integer"/>
      <xsd:element name="boolean" type="xsd:boolean"/>
      <xsd:element name="xml" type="types:unboundedXMLAnyNamespace"/>
    </xsd:choice>
    <xsd:attribute name="name" type="xsd:anyURI" use="required"/>
    <xsd:attribute name="mustUnderstand" type="xsd:boolean" use="optional" default="false"/>
  </xsd:complexType>

  <!-- ============================================================= -->
  <!-- a set of options -->
  <!-- TODO: add some uniqueness rules -->
  <!-- ============================================================= -->
  <xsd:complexType name="optionMapType">
    <xsd:annotation>
      <xsd:documentation>
        A set of options. Only one of each URI is allowed.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="option" type="types:optionType"
        minOccurs="0" maxOccurs="unbounded"/>
    </xsd:sequence>
  </xsd:complexType>


  <!-- ============================================================= -->
  <!-- property tuples-->
  <!-- ============================================================= -->
  <xsd:complexType name="propertyTupleType">
    <xsd:annotation>
      <xsd:documentation>
        A name/value pair of properties. Names are restricted to NCName type;
        values are any string. Why restrict name type? For easier incorporation
        into the language
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="name" type="xsd:NCName"/>
      <xsd:element name="value" type="xsd:string"/>
    </xsd:sequence>
  </xsd:complexType>

  <!-- ============================================================= -->
  <!-- a map of property tuples -->
  <!-- to use this in a deployment, add it under the option -->
  <!-- http://gridforum.org/cddlm/serviceAPI/options/properties/2004/07/30 -->
  <!-- ============================================================= -->
  <xsd:complexType name="propertyMapType">
    <xsd:annotation>
      <xsd:documentation>
        A set of name/value pair of properties. Only one instance of each name
        is allowed. This is essentially a serialisation of a map/hash table.
        
        This is for properties that are to be passed directly to the
        deployment engine, using whatever property binding mechanism is
        included in the language.        
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="property" type="types:propertyTupleType"
        minOccurs="0" maxOccurs="unbounded"/>
    </xsd:sequence>
  </xsd:complexType>



  <!-- ============================================================= -->
  <!-- Server status -->
  <!-- this section includes various lists of server information -->
  <!-- which are returned in the server status response -->
  <!-- ============================================================= -->

  <xsd:complexType name="languageListType">
    <xsd:annotation>
      <xsd:documentation>
        This is the list of supported languages
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="language" minOccurs="1" maxOccurs="unbounded">
        <xsd:complexType>
          <xsd:annotation>
            <xsd:documentation>
              A language is defined by a name and version, and a namespace.
              It is the namespace itself that defines the language; the name
              and version are for the benefit of humans.
            </xsd:documentation>
          </xsd:annotation>
          <xsd:sequence>
            <xsd:element name="name" type="xsd:string"/>
            <xsd:element name="version" type="xsd:string"/>
            <xsd:element name="namespace" type="xsd:anyURI"/>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>

  <xsd:complexType name="callbackListType">
    <xsd:annotation>
      <xsd:documentation>
        This is the list of supported callback mechanisms
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="callback" minOccurs="1" maxOccurs="unbounded"
        type="xsd:string">
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>

  <xsd:complexType name="serverInformationType">
    <xsd:annotation>
      <xsd:documentation>
        This is static information about the server itself.

      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="name" type="xsd:string" minOccurs="1" maxOccurs="1">
        <xsd:annotation>
          <xsd:documentation>
          Name of the implementation of the server
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="build" type="xsd:string" minOccurs="1" maxOccurs="1">
        <xsd:annotation>
          <xsd:documentation>
          Build information: version, build number, build date, etc. 
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="home" type="xsd:anyURI" minOccurs="1" maxOccurs="1">
        <xsd:annotation>
          <xsd:documentation>
        URL to a page providing support and docs for the server
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="location" type="xsd:string" minOccurs="1" maxOccurs="1">
        <xsd:annotation>
          <xsd:documentation>
          Location string describing server location
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="timezoneUTCOffset" type="xsd:integer" minOccurs="1" maxOccurs="1">
        <xsd:annotation>
          <xsd:documentation>
            Offset from UTC of the local clock.
            Provides a location hint and good diagnostics
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>

      <xsd:element name="diagnostics" type="types:unboundedXMLAnyNamespace" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>
            Arbitrary diagnostic information.
            Components used, result of local health checks etc.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>

    </xsd:sequence>
  </xsd:complexType>

  <xsd:complexType name="staticServerStatusType">
    <xsd:annotation>
      <xsd:documentation>
        Static status should be constant for the life of
        this instance of the service, while dynamic information is viewed as transient.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="server" type="types:serverInformationType"/>
      <xsd:element name="languages" type="types:languageListType"/>
      <xsd:element name="callbacks" type="types:callbackListType"/>
    </xsd:sequence>
  </xsd:complexType>

  <xsd:complexType name="dynamicServerStatusType">
    <xsd:annotation>
      <xsd:documentation>
        Dynamic status contents are undefined; service is free to provide
        any information they like.
        This could be declared as a WS-RF property.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:any processContents="lax" minOccurs="0" maxOccurs="unbounded" namespace="##other"/>
    </xsd:sequence>
  </xsd:complexType>

  <!-- ============================================================= -->
  <!-- serverstatus -->
  <!-- ============================================================= -->


  <xsd:complexType name="serverStatusType">
    <xsd:annotation>
      <xsd:documentation>
        This is the server status response. If the endpoint returns with anything
        then the system is partially alive; a SOAPFault is always a sign of failure
        from the perspective of the far end or the transport.
        It consists of static status and
        dynamic status. Static status should beconstant for the life of
        this instance of the service, while dynamic information is viewed as transient.
        Interpretation of a server status into a proper health metric is left to
        tools of the caller's choice.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="static" type="types:staticServerStatusType"/>
      <xsd:element name="dynamic" type="types:dynamicServerStatusType" minOccurs="0"/>
    </xsd:sequence>
  </xsd:complexType>

  <!-- ============================================================= -->
  <!-- application status -->
  <!-- ============================================================= -->


  <xsd:complexType name="applicationStatusType">
    <xsd:annotation>
      <xsd:documentation>
        This is the application status response. If the endpoint returns with anything
        then the system is partially alive; a SOAPFault is always a sign of failure
        from the perspective of the far end or the transport.
        It consists of static status and
        dynamic status. Static status should beconstant for the life of
        this instance of the service, while dynamic information is viewed as transient.
        Interpretation of a server status into a proper health metric is left to
        tools of the caller's choice.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="name" type="types:applicationNameType"/>
      <xsd:element name="state" type="types:lifecycleStateEnum"/>
      <xsd:element name="stateInfo" type="xsd:string"/>
      <xsd:element name="extendedState" minOccurs="0" type="types:unboundedXMLOtherNamespace"/>
    </xsd:sequence>
  </xsd:complexType>


  <!-- ============================================================= -->
  <!-- list of application is used for enumerating running applications -->
  <!-- ============================================================= -->

  <xsd:complexType name="applicationReferenceListType">
    <xsd:annotation>
      <xsd:documentation>
        This is a (potentially empty) list of  applications
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="application" minOccurs="0" maxOccurs="unbounded"
        type="types:applicationReferenceType">
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>

  
  <!-- ============================================================= -->
  <!-- empty elements get used in a few places -->
  <!-- ============================================================= -->

  <xsd:complexType name="emptyElementType">
    <xsd:annotation>
      <xsd:documentation>
        This is an empty message
      </xsd:documentation>
    </xsd:annotation>
  </xsd:complexType>

  <!-- ============================================================= -->
  <!-- option elements -->
  <!-- ============================================================= -->

  <xsd:element name="PropertyMapOption" type="types:propertyMapType">
    <xsd:annotation>
      <xsd:appinfo>
        http://gridforum.org/cddlm/serviceAPI/options/propertyMap/2004/07/30
      </xsd:appinfo>
      <xsd:documentation>
        this is the contents of a property map option
      </xsd:documentation>
    </xsd:annotation>
  </xsd:element>
  <!--
    not needed, we just use boolean on the option instead.
    <xsd:element name="ValidateOnlyOption" type="xsd:boolean">
      <xsd:annotation>
        <xsd:appinfo>
          http://gridforum.org/cddlm/serviceAPI/options/validateOnly/2004/07/30
        </xsd:appinfo>
        <xsd:documentation>
          this is the contents of a validateOnly option.
          If set to true, a runtime that understands the message must
          only validate the message and deployment descriptor, and not execute it.
        </xsd:documentation>
      </xsd:annotation>
    </xsd:element>
  -->


  <!-- ============================================================= -->
  <!-- Requests and responses. These are the complex types that
  get sent/received as messages-->
  <!-- ============================================================= -->

  <!-- ============================================================= -->
  <!-- ============================================================= -->
  <xsd:element name="deployRequest">
    <xsd:complexType>
      <xsd:annotation>
        <xsd:documentation>
          This is our deployment request.
          Rather than have so many typed options,
          a core few mandatory options are specified inline, and the rest
          are referred to in the deployment_options map.
        </xsd:documentation>
      </xsd:annotation>
      <xsd:sequence>
        <xsd:element name="jsdl" type="types:jsdlType">
          <xsd:annotation>
            <xsd:documentation>
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>

        <xsd:element name="name" type="types:applicationNameType">
          <xsd:annotation>
            <xsd:documentation>
          The name of the application
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>
        <xsd:element name="descriptor" type="types:deploymentDescriptorType">
          <xsd:annotation>
            <xsd:documentation>
          Mandatory deployment descriptor
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>
        <xsd:element name="callback" type="types:callbackInformationType" minOccurs="0">
          <xsd:annotation>
            <xsd:documentation>
            callback data, can be committed
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>
        <xsd:element name="options" type="types:optionMapType" minOccurs="0">
          <xsd:annotation>
            <xsd:documentation>
          This is for optional deployment options.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>

  <!-- ============================================================= -->
  <!-- ============================================================= -->
  <xsd:element name="deployResponse">
    <xsd:complexType>
      <xsd:annotation>
        <xsd:documentation>
        This is our deployment response.
        It consists of a reference to the application, which can be used
        for future references.
        </xsd:documentation>
      </xsd:annotation>
      <xsd:sequence>
        <xsd:element name="applicationReference" type="types:applicationReferenceType"/>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>

  <!-- ============================================================= -->
  <!-- ============================================================= -->
  <xsd:element name="undeployRequest">
    <xsd:complexType>
      <xsd:annotation>
        <xsd:documentation>
          Request to terminate an application.
        </xsd:documentation>
      </xsd:annotation>
      <xsd:sequence>
        <xsd:element name="application" type="types:applicationReferenceType"/>
        <xsd:element name="reason" type="xsd:string"/>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>

  <!-- ============================================================= -->
  <!-- there isnt really much to say here -->
  <!-- ============================================================= -->
  <xsd:element name="undeployResponse" type="xsd:boolean">
  </xsd:element>

  <!-- ============================================================= -->
  <!-- ============================================================= -->

  <xsd:element name="serverStatusRequest">
    <xsd:annotation>
      <xsd:documentation>
        This is an empty message
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType/>
  </xsd:element>

  <!-- ============================================================= -->
  <!-- ============================================================= -->
  <xsd:element name="serverStatusResponse" type="types:serverStatusType">
  </xsd:element>

  <!-- ============================================================= -->
  <!-- ============================================================= -->
  <xsd:element name="applicationStatusRequest">
    <xsd:annotation>
      <xsd:documentation>
        Request the status of an individual application
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:sequence>
        <xsd:element name="application" type="types:applicationReferenceType"/>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>

  <xsd:element name="applicationStatusResponse" type="types:applicationStatusType">
  </xsd:element>

  <!-- ============================================================= -->
  <!-- ============================================================= -->
  <xsd:element name="lookupApplicationRequest">
    <xsd:annotation>
      <xsd:documentation>
        Look up an application: pass in the name and get a reference back
        (or an error, if there is no such application or security prevents
         the caller seeing it)
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>
      <xsd:sequence>
        <xsd:element name="application" type="types:applicationNameType"/>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>

  <xsd:element name="lookupApplicationResponse" type="types:applicationReferenceType">
  </xsd:element>

  <!-- ============================================================= -->
  <!-- list applications request/response -->
  <!-- ============================================================= -->

  <xsd:element name="listApplicationsRequest" type="types:emptyElementType">
    <xsd:annotation>
      <xsd:documentation>
        List all running applications.
        Security policy may intervene and only list those the user is
        authorised to see.
      </xsd:documentation>
    </xsd:annotation>
  </xsd:element>

  <xsd:element name="listApplicationsResponse"
    type="types:applicationReferenceListType">
    <xsd:annotation>
      <xsd:documentation>
        List of running applications
      </xsd:documentation>
    </xsd:annotation>
  </xsd:element>


  <!-- ============================================================= -->
  <!-- callback event message -->
  <!-- ============================================================= -->
  <xsd:element name="lifecycleEventCallbackRequest">
    <xsd:complexType>
      <xsd:annotation>
        <xsd:documentation>
        This is the message which gets sent after a state change
        to a listening endpoint
        </xsd:documentation>
      </xsd:annotation>
      <xsd:sequence>
        <xsd:element name="identifier" type="xsd:string"/>
        <xsd:element name="applicationReference" type="types:applicationReferenceType"/>
        <xsd:element name="status" type="types:applicationStatusType"/>
        <!--      <xsd:element name="BaseFault" type="wsbf:BaseFaultType" minOccurs="0"/>-->
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>

  <xsd:element name="lifecycleEventCallbackResponse" type="xsd:boolean">
    <xsd:annotation>
      <xsd:documentation>
         Return false if you wish to cease to receive notification events.
         Return true if you wish to continue to receive events.
         The sender must not view failure to send as a reason to stop
         sending messages, as these may be transient.
      </xsd:documentation>
    </xsd:annotation>
  </xsd:element>


  <!-- ============================================================= -->
  <!-- end schema-->
  <!-- ============================================================= -->

</xsd:schema>
  
