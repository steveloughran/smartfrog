<?xml version="1.0"?>
<project name="common" basedir="."
     xmlns:ivy="antlib:fr.jayasoft.ivy.ant"
    >
  <!--
  /** (C) Copyright Hewlett-Packard Development Company, LP

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

  For more information: www.smartfrog.org

  */
  -->
<description>
  This is a build file
  for importing and overriding in subsidiary build files. 

  When ant imports stuff into a project, the value of ".", the project
  directory is that of the importing project, not the imported. But it sets
  a property ant.file.PROJECTNAME to that of the directory of the imported 
  project, where PROJECTNAME is not the filename, but the name of the project
  in the XML declaration.
      
</description>

  <fail>
    <condition>
      <not>
        <available
          classname="org.apache.tools.ant.types.resources.FileResourceIterator"/>
      </not>
    </condition>
    This version of Ant is not supported.
    Please upgrade to Ant1.7 or later and build this project again
  </fail>

  <!-- ========================================================== -->
  <!-- this is the simple definitions part of the common init -->
  <!-- IT must contain -->
  <!-- NO side effects -->
  <!-- NO requirement for smartfrog jar or similar to exist -->
  <!-- ========================================================== -->

  
  <target name="init-common-simpledefinitions">
     <!-- load in the local override -->
    <property file="build.properties"/>
    
    <!-- this is where we work out the base directory    -->
    <!-- only here when running this task raw, to test targets inside -->
    <property name="ant.file.common" location="${ant.file}" />
    <!-- this will be set by the runtime during importation --> 
    <!-- it is how we infer the base directory of the system -->
    <dirname property="antfile.dir" file="${ant.file.common}"/>
    <property name="core.dir" location="${antfile.dir}"/>
    
    <!-- This is to decide the directory structure for the components, and default is false -->
    <property name="is.component" value="false"  />

    <!-- the common.properties file lets you provide a single declaration of
    overrides (like the compiler settings) that apply across
    all projects that use this common file-->
    <property file="${core.dir}/common.properties"/>

    <!-- now read in environment settings -->
    <property environment="env" />
    <!-- read these after the env settings -->
    <property file="${core.dir}/build.properties"/>

    <property name="smartfrog.home" location="${core.dir}/smartfrog"/>
    <property name="smartfrog.dist.dir" location="${smartfrog.home}/dist" />
    <property name="smartfrog.dist.lib.dir" location="${smartfrog.dist.dir}/lib"/>
    <property name="smartfrog.components.dir" location="${core.dir}/components"/>
    
    <!-- Compile options for Smartfrog Release -->
    <property name="javac.debug.mode" value="true"/> 
    <property name="javac.deprecation.mode" value="true"/> 
    <property name="javac.debug.level" value="lines,vars,source" />
    <property name="javac.java.version" value="1.4" />
    <property name="javac.include.ant" value="false" />

    <property name="smartfrog.daemon.port" value="3800" />
    <!--use the forking compiler-->
    <property name="rmic.compiler" value="forking"/>

    
    <property name="extras.dir"
      location="${core.dir}/extras"/>
    <property name="maven.lib.dir"
      location="${core.dir}/lib"/>
    <property name="maven.url"
      value="http://ibiblio.org/maven2/"/>
      
      
      <!-- common directories are relative to the build file loaded-->
    <property name="src.dir" location="src"/>
    <property name="bin.dir" location="bin"/>
    <property name="doc.dir" location="doc"/>
    <property name="lib.dir" location="lib" />
    <property name="test.src.dir" location="test" />
    
    
    <!--generated stuff --> 
    <property name="build.dir" location="build"/>
    <property name="build.classes.dir" location="${build.dir}/classes"/>
    <property name="build.test.dir" location="${build.dir}/test"/>
    <property name="test.dir" location="${build.dir}/test"/>
    <property name="test.classes.dir" location="${build.test.dir}/classes"/>
    <property name="test.data.dir" location="${build.test.dir}/data"/>
    <property name="test.datafiles.dir" location="test/files"/>
    <property name="test.reports.dir" location="${build.test.dir}/reports"/>
  
    <property name="dist.dir" location="dist"/>
    <property name="dist.lib.dir" location="${dist.dir}/lib"/>
    <property name="dist.doc.dir" location="${dist.dir}/docs"/>
    <property name="dist.jdocs.dir" location="${dist.doc.dir}/jdocs"/>
    <property name="dist.bin.dir" location="${dist.dir}/bin"/>
    <property name="dist.src.dir" location="${dist.dir}/src"/>

    <echo level="verbose">build.classes.dir=${build.classes.dir}
      test.classes.dir=${test.classes.dir}
      dist.dir=${dist.dir}
    </echo>

    <!-- name of a file for runtime properties 
      This is optional and allows users to define extra 
      properties for the smartfrog daemons and other runtimes-->
    <property name="runtime.properties"
      location="${core.dir}/runtime.properties"/>
    <echo level="verbose">Looking at ${runtime.properties} 
      for optional SmartFrog runtime properties</echo>
    <property file="${runtime.properties}" prefix="runtime"/>      
      <!-- turn on the tests. If you dont want this, set one (or both) to false)  in the unit tests-->
    <property name="system.tests" value="true" />
    <property name="unit.tests" value="true" />

    <condition property="system.tests.enabled">
      <istrue value="${system.tests}"/>
    </condition>

    <condition property="unit.tests.enabled">
      <istrue value="${unit.tests}"/>
    </condition>
    

    <!-- build the name of our JAR file from the name of the project.
      override any of this stuff for alternate naming -->
    <property name="jar.prefix" value="sf-" />
    <!-- this is the name of the outer project, not common.xml's name -->
    <property name="project.name" value="${jar.prefix}${ant.project.name}" />

        <!-- information about the ant tasks -->
    <property name="smartfrog.tasks.prefix" value="${jar.prefix}tasks"/>

    <!-- work out our java version by introspection -->
    <condition property="java1.5+" >
      <available classname="java.lang.Readable"/>
    </condition>

    <tstamp>
      <format property="year" pattern="yyyy"/>
    </tstamp>
    <property name="Name.Framework" value="SmartFrog"/>
    <property name="Name.System" value="${ant.project.name}"/>
    <property name="Name.Company"
        value="(C) Copyright 1998-${year} Hewlett-Packard Development Company, LP"/>

    <!--copy all proxy settings from the running JVM-->
    <propertyset id="proxy.settings">
      <propertyref prefix="http."/>
      <propertyref prefix="socks."/>
    </propertyset>

  </target>


 <target name="init-common" depends="init-common-simpledefinitions">

    <fileset id="smartfrog.core.fileset"
      dir="${smartfrog.dist.lib.dir}">
      <include name="smartfrog*.jar"/>
      <!-- we DO NOT want smarfrog tasks -->
      <exclude name="${smartfrog.tasks.prefix}*.jar"/>
      <include name="sfExamples*.jar"/>
      <include name="sfServices*.jar"/>
    </fileset>

    <fileset id="smartfrog.lib.fileset"
      dir="${smartfrog.dist.lib.dir}">
      <include name="**/*.jar"/>
      <!-- we DO NOT want smartfrog tasks -->
      <exclude name="${smartfrog.tasks.prefix}*.jar"/>
    </fileset>


    <!-- set up the path of common files in the dist/lib directory -->
    <path id="smartfrog.classpath">
      <fileset refid="smartfrog.lib.fileset" />
    </path>
    <path id="smartfrog.core.classpath">
      <fileset refid="smartfrog.core.fileset" />
    </path>


    <!-- name the resource -->
    <property name="smartfrog.version.property.resource"
      value="org/smartfrog/smartfrog-version.properties"
      />

    <!-- check for its presence; break the build if missing -->
    <fail >
      <condition>
      <not>
        <available resource="${smartfrog.version.property.resource}"
          classpathref="smartfrog.classpath"/>
      </not>
      </condition>
SmartFrog distribution not found. Please create the SmartFrog distribution first.
Alternatively, make sure that this project is configured to locate the distribution
correctly.

smartfrog.classpath=
 ${toString:smartfrog.classpath}

build.sysclasspath=${build.sysclasspath}

java.class.path=
  ${java.class.path}
    </fail>

    <!-- load in our version -->
    <loadproperties resource="${smartfrog.version.property.resource}"
      classpathref="smartfrog.classpath"/>
    <fail unless="sf.build.version">No property sf.build.version found in resource ${smartfrog.version.property.resource}</fail>
    <property name="Version" value="${sf.build.version}" />
    <property name="smartfrog.version" value="${sf.build.version}" />

    <!-- this is an override point; components call this -component -->
    <property name="jarfile.suffix" value=""/>
    <property name="jarfile.extension" value="jar"/>
    <property name="artifact.name" value="${project.name}" />
    <property name="jarfile.stub" value="${artifact.name}${jarfile.suffix}-${Version}" />
    <property name="jarfile.name" value="${jarfile.stub}.${jarfile.extension}"/>

    <property name="target.jar"
      location="${dist.lib.dir}/${jarfile.name}"/>

<!--     name JAR files that tests go into. this is for signing all
    test code (inc deployment descriptors) for deployment onto secure
    boxes
 -->
    <property name="test.jar.name" value="${artifact.name}-test-${Version}.jar"/>
    <property name="test.jar"
        location="${dist.lib.dir}/${test.jar.name}" />

   <!--name of javadocs zip file-->
   <property name="javadocs.zip.name" value="${artifact.name}-javadocs-${Version}.zip"/>
   <property name="javadocs.zip"
     location="${dist.lib.dir}/${javadocs.zip.name}" />

   <!--info about the documentation zip-->
   <property name="documentation.zip.name"
     value="${artifact.name}-documentation-${Version}.zip"/>
   <property name="documentation.zip"
     location="${dist.lib.dir}/${documentation.zip.name}" />


    <!-- standard location for distributed stuff; used when locating
      other things -->
    <property name="dist.lib.dir.relative" value="/dist/lib" />
    <property name="smartfrog.tasks.name" value="${smartfrog.tasks.prefix}-${Version}.jar"/>

    <property name="smartfrog.tasks.lib.dir"
      location="${extras.dir}/ant/${dist.lib.dir.relative}"/>
    <property name="smartfrog.tasks.jar"
      location="${smartfrog.tasks.lib.dir}/${smartfrog.tasks.name}"/>


      <!-- location of junit jar; override it if it is somewhere else-->
    <condition property="junit.jar" value="${ant.home}/lib/junit.jar">
      <available file="${ant.home}/lib/junit.jar" />
    </condition>

    <condition property="junit.jar" value="${ant.home}/lib/junit-3.8.1.jar">
      <available file="${ant.home}/lib/junit-3.8.1.jar" />
    </condition>

   <condition property="junit.jar" value="${ant.home}/lib/junit-3.8.2.jar">
     <available file="${ant.home}/lib/junit-3.8.2.jar"/>
   </condition>

   <condition property="junit.jar" value="${user.home}/.ant/lib/junit-3.8.1.jar">
     <available file="${user.home}/.ant/lib/junit-3.8.1.jar" />
   </condition>
   <condition property="junit.jar" value="${user.home}/.ant/lib/junit-3.8.2.jar">
     <available file="${user.home}/.ant/lib/junit-3.8.2.jar"/>
   </condition>

    <echo level="verbose">system.tests.enabled=${system.tests.enabled}</echo>
    <echo level="verbose">unit.tests.enabled=${unit.tests.enabled}</echo>

    <!-- define a new javac task with new default options -->
    <presetdef name="sf-javac">
       <javac debug="${javac.debug.mode}"
            nowarn="true"
            deprecation="${javac.deprecation.mode}"
            source="${javac.java.version}"
            target="${javac.java.version}"
            includeAntRuntime="${javac.include.ant}"
            includes="**/*.java"
            >
       </javac>
    </presetdef>

    <!-- an extension of the previous javac, this with ant classpath included -->
    <presetdef name="sf-javac-with-ant">
       <sf-javac
          includeAntRuntime="true" />
    </presetdef>


    <!-- a new version of the java task that always forks, does not include
    the ant runtime by default, and fails on any error -->
    <presetdef name="sf-java">
      <java
        includeantruntime="false"
        fork="true"
        failonerror="true"
        >
       </java>
    </presetdef>

   <!--
    JAR files are uncompressed, with duplicate classes preserved, meaning
    whatever was there first wins.
    -->
    <presetdef name="sf-jar">
      <jar
        compress="true"
        duplicate="preserve"
        >
       </jar>
    </presetdef>

   <!--
   Tar files are gnu formatted for long files
   -->
   <presetdef name="sf-tar">
     <tar
         longfile="gnu"
         >
     </tar>
   </presetdef>

    <!-- junit wrapper;
      enables forking, turns assertions on in the code,
      and enables XML output.
      Timeout is set to 10 minutes, so we dont ever hang.
      User is still required to
        -specify failure properties
        -provide test or batch test patterns
        -set up the classpath. Dont forget to
        include a reference to smartfrog.classpath to get the core stuff
      -->
    <presetdef name="sf-junit">
      <junit printsummary="no"
           fork="true"
           includeantruntime="true"
           showoutput="true"
           timeout="6000000"
           >
        <jvmarg value="-ea"/>
        <jvmarg value="-esa"/>
        <!--copy all proxy settings from the running JVM-->
        <syspropertyset refid="proxy.settings"/>

        <!-- #Tests take system property parameters -->
        <!-- #Formatters for capture and display -->
        <formatter type="xml"/>
        <formatter type="brief" usefile="false"/>
      </junit>
    </presetdef>

    <!-- testing for a server being present; set a property to set -->

    <presetdef name="sf-daemonfound">
      <condition >
        <socket port="${smartfrog.daemon.port}" server="localhost" />
      </condition>
    </presetdef>

    <!-- wait for 10 seconds for a daemon. Set maxwait to a different
    value for more or less time, timeoutproperty to the name of a property
    to set on failure -->
    <presetdef name="sf-waitfordaemon">
        <waitfor maxwait="10" maxwaitunit="second">
            <socket server="localhost" port="${smartfrog.daemon.port}"/>
        </waitfor>
    </presetdef>

    <!-- reporting wrapper -->
   <macrodef name="sf-junitreport">
     <attribute name="data"/>
     <attribute name="reports"/>
     <sequential>
       <junitreport todir="@{data}">
         <fileset dir="@{data}">
           <include name="TEST-*.xml"/>
         </fileset>
         <report format="frames" todir="@{reports}"/>
       </junitreport>
     </sequential>
   </macrodef>

    <macrodef name="sf-test-report">
      <attribute name="data"/>
      <attribute name="reports"/>
      <attribute name="failed"/>
      <sequential>
        <sf-junitreport data="@{data}" reports="@{reports}" />
        <fail if="@{failed}">Tests failed see:
          @{reports}</fail>
      </sequential>
    </macrodef>

    <!--
    Copy useful files from the source to dest directories. Use this for adding
    extra stuff to the bin directory. By default it pulls in
    **/*.xml,**/*.dtd,**/*.xsd,**/*.sf,**/*.properties;
    override the pattern property to set more
     -->
   <macrodef name="copy-useful-files">
     <attribute name="src"/>
     <attribute name="dest"/>
     <attribute name="failonerror" default="false"/>
     <attribute name="pattern"
         default="**/*.ini,**/*.xml,**/*.dtd,**/*.xsd,**/*.sf,**/*.sfcd,**/*.wsdl,**/*.properties,**/*.wsdd,**/*.cdl,**/*.css,**/*.xsl"/>
     <sequential>
       <echo level="verbose">copying @{pattern} from @{src} to @{dest}</echo>
       <copy todir="@{dest}" failonerror="@{failonerror}">
         <fileset dir="@{src}"
             includes="@{pattern}"/>
       </copy>
     </sequential>
   </macrodef>

    <!-- rmic configuration -->
    <presetdef name="sf-rmic">
      <rmic
        verify="true"
        stubversion="1.2" />
    </presetdef>
  </target>

  <!--set up javadoc-->
  <target name="init-javadoc" depends="init,init-common">

    <property name="javadoc.access" value="protected"/>
    <property name="javadoc.author" value="false"/>
    <property name="javadoc.version" value="true"/>
    <property name="javadoc.use" value="true"/>
    <property name="javadoc.windowtitle" value="${Name.System}"/>
    <property name="javadoc.packagenames" value="org.smartfrog.*"/>
    <property name="javadoc.header" value="${Name.System} ${Version}"/>
    <property name="javadoc.footer" value="${Name.System} ${Version}"/>
    <presetdef name="sf-javadoc" >
      <javadoc packagenames="${javadoc.packagenames}"
          author="${javadoc.author}"
          version="${javadoc.version}"
          use="${javadoc.use}"
          windowtitle="${javadoc.windowtitle}"
          header="${javadoc.header}"
          footer="${javadoc.footer}"
          doctitle="${Name.System}"
          bottom="${Name.Company}"
          source="${javac.java.version}"
          verbose="false"
          >
      </javadoc>
    </presetdef>

  </target>

  <target name="jdocs" depends="javadoc" description="Generates the API documentation"/>

  <!-- =================================================================== -->
  <!--   Javadocs. uses the compile classpath to set up the javadoc task   -->
  <!-- =================================================================== -->

  <target name="ready-to-javadoc"
          depends="generateversion,declare-classpaths,init-javadoc"
      />

  <target name="javadoc"
          depends="ready-to-javadoc"
          unless="javadoc.disabled"
          >
    <!--  Java Docs for all                                                -->
    <echo message=""/>
    <echo message="------ Creating Java Docs for ${javadoc.header} [${dist.jdocs.dir}]---------------"/>
    <fail unless="dist.jdocs.dir">
      We are not properly initialized, as dist.jdocs.dir is undefined.
    </fail>
    <mkdir dir="${dist.jdocs.dir}"/>
    <sf-javadoc
        sourcepath="${src.dir}"
        destdir="${dist.jdocs.dir}"
        classpathref="compile.classpath"
        >
      <group title="SmartFrog Packages" packages="org.smartfrog.*"/>
    </sf-javadoc>
  </target>

  <!--Package up the javadocs into their own zip file-->
  <target name="ready-to-package-javadocs" depends="javadoc">
  </target>

  <target name="package-javadocs" depends="ready-to-package-javadocs"
      description="package up all the javadocs">
    <zip destfile="${javadocs.zip}">
      <zipfileset dir="${dist.jdocs.dir}" includes="**/*.*"
          prefix="javadoc"/>
    </zip>
  </target>

  <!-- ========================================================== -->
  <!--  set up the documentation-->
  <!-- ========================================================== -->

  <target name="init-documents" depends="init">

  </target>

  <target name="ready-to-package-documents" depends="init-documents">

  </target>

  <target name="package-documents" depends="ready-to-package-documents">
    <zip destfile="${documentation.zip}"
         whenempty="create" duplicate="preserve">
      <!--fileset is set up to work if there are no artifacts-->
      <zipfileset dir="." >
        <include name="doc/**/*.html" />
        <include name="doc/**/*.pdf" />
        <include name="doc/**/*.sx?" />
        <include name="doc/**/*.txt" />
      </zipfileset>
    </zip>
  </target>


  <!-- ========================================================== -->
  <!--
    This target is used to set up the standard output for builds and tests and things
   -->
  <!-- ========================================================== -->
  <target name="init-standard-output-dirs" depends="init-common">


  <!--logic to have conditional directory structure for components -->
    <condition property="is.component.enabled">
      <istrue value="${is.component}"/>
    </condition>

    <condition property="is.component.not.enabled">
      <isfalse value="${is.component}"/>
    </condition>

    <mkdir dir="${build.dir}" />
    <mkdir dir="${build.classes.dir}" />


    <mkdir dir="${test.dir}" />
    <mkdir dir="${test.classes.dir}" />
    <mkdir dir="${test.data.dir}" />
    <mkdir dir="${test.reports.dir}" />

    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.lib.dir}"/>
    <mkdir dir="${dist.doc.dir}"/>
    <mkdir dir="${dist.bin.dir}"/>
    <mkdir dir="${dist.src.dir}"/>
    <fail unless="dist.jdocs.dir">
      We are not properly initialized, as dist.jdocs.dir is undefined.
    </fail>
    <mkdir dir="${dist.jdocs.dir}"/>
  </target>


  <!--  assert that junit exists and fail if it is not there-->
  <target name="assert-junit" depends="init" >
    <available file="${junit.jar}" property="junit.found"/>
    <fail unless="junit.found">
     Not found: ${junit.jar}
    </fail>
  </target>

  <!-- ========================================================== -->
  <!-- this set of classpath targets is done to allow override of -->
  <!-- any stage of the process, with all the dependent classpaths -->
  <!-- being set up right, automatically -->
    <!-- define the common compile classpath, which includes
        smartfrog and our lib dir -->
  <!-- ========================================================== -->

  <target name="declare-base.compile.classpath" depends="init" >
    <path id="base.compile.classpath">
      <path refid="smartfrog.classpath"/>
    </path>
  </target>

 <target name="declare-compile.classpath"
    depends="declare-base.compile.classpath" unless="ivy.enabled">
   <path id="compile.classpath">
     <path refid="base.compile.classpath"/>
     <fileset dir=".">
       <include name="lib/**/*.jar"/>
     </fileset>
   </path>
    <echo level="verbose">compile.classpath=${toString:compile.classpath}</echo>
  </target>

  <target name="declare-exec.classpath" depends="declare-compile.classpath" unless="ivy.enabled">
    <path id="exec.classpath">
      <path refid="compile.classpath"/>
      <pathelement location="${build.classes.dir}"/>
    </path>
    <echo level="verbose">exec.classpath=${toString:exec.classpath}</echo>
  </target>

  <target name="declare-tests.compile.classpath"
      depends="declare-exec.classpath,use-smartfrog-testharness" unless="ivy.enabled">
    <path id="tests.compile.classpath">
      <path refid="exec.classpath"/>
      <pathelement location="${junit.jar}"/>
      <pathelement location="${testharness.jar}"/>
    </path>
    <echo level="verbose">tests.compile.classpath=${toString:tests.compile.classpath}</echo>
  </target>

  <target name="declare-tests.run.classpath" depends="declare-tests.compile.classpath"
      unless="ivy.enabled">
    <path id="tests.run.classpath">
      <path refid="tests.compile.classpath"/>
      <pathelement location="${test.classes.dir}"/>
    </path>
    <echo level="verbose">tests.run.classpath=${toString:tests.run.classpath}</echo>
  </target>

  <target name="declare-run.classpath" depends="declare-tests.run.classpath"
      unless="ivy.enabled">
    <path id="run.classpath">
      <path refid="tests.run.classpath"/>
    </path>
  </target>

  <target name="declare-run.classpath-no-tests" depends="declare-exec.classpath"
      unless="ivy.enabled">
    <path id="run.classpath">
      <path refid="exec.classpath"/>
    </path>
  </target>

  <!-- This target explicitly lists all dependencies so that if anyone starts overriding
    declarations, it doesnt matter if they omit dependencies. After this target, all classpaths
    are defined-->
  <target name="declare-classpaths"
    depends=
     "ivy-classpaths,declare-base.compile.classpath,declare-compile.classpath,
     declare-exec.classpath,declare-tests.compile.classpath,
     declare-tests.run.classpath,
     declare-run.classpath-no-tests,declare-run.classpath"/>


  <target name="ivy.compile.classpath" depends="maybe-ivy-resolve" if="ivy.enabled">
    <ivy:cachepath pathid="compile.classpath" conf="compile" />
    <echo level="verbose">compile.classpath=${toString:compile.classpath}</echo>
  </target>

  <target name="ivy.run.classpath" depends="maybe-ivy-resolve"  if="ivy.enabled">
    <ivy:cachepath pathid="run.classpath" conf="daemon" />
    <echo level="verbose">run.classpath=${toString:run.classpath}</echo>
  </target>

  <target name="ivy.exec.classpath" depends="ivy.compile.classpath"  if="ivy.enabled">
    <ivy:cachepath pathid="ivy.test.classpath" conf="test" />
    <path id="exec.classpath">
      <pathelement location="${target.jar}"/>
      <path refid="ivy.test.classpath"/>
    </path>
    <echo level="verbose">exec.classpath=${toString:exec.classpath}</echo>
  </target>

  <target name="ivy.tests.compile.classpath" depends="ivy.exec.classpath"  if="ivy.enabled">
    <path id="tests.compile.classpath">
      <path refid="exec.classpath"/>
    </path>
    <echo level="verbose">tests.compile.classpath=${tests.compile.classpath}</echo>
  </target>

  <target name="ivy.tests.run.classpath" depends="ivy.tests.compile.classpath"  if="ivy.enabled">
    <path id="tests.run.classpath">
      <pathelement location="${test.jar}"/>
      <path refid="tests.compile.classpath"/>
    </path>
    <echo level="verbose">tests.run.classpath=${toString:tests.run.classpath}</echo>
  </target>

  <target name="ivy-classpaths"
    depends="ivy.compile.classpath,ivy.exec.classpath,ivy.run.classpath,ivy.tests.run.classpath" />




  <!-- ========================================================== -->
  <!-- cleanup target -->
  <!-- This MUST work even if clean has already been run; test -->
  <!-- changes with ant clean clean -->
  <!-- ========================================================== -->
  <target name="clean" description="clean up build and dist"
      depends="init-common-simpledefinitions">
    <delete dir="${build.dir}" />
    <delete dir="${dist.dir}"  />
    <delete dir="releases"  />
    <delete file="version.properties"/>
  </target>

  <!-- ========================================================== -->
  <!-- probe for the smartfrog binaries existing in the dist dir. -->
  <!-- and exit if they are not -->
  <!-- ========================================================== -->

  <target name="assert-smartfrog"  depends="init-common,declare-classpaths"
    description="verify smartfrog is present, fail if not">
    <available
      classname="org.smartfrog.SFSystem"
      classpathref="smartfrog.classpath"
      property="sfSystem.present"/>
    <property name="sfjars.fullpath" refid="run.classpath"/>
    <fail unless="sfSystem.present">
      Smartfrog entry point not found in
      ${sfjars.fullpath}
    </fail>
    <echo level="verbose">Smartfrog found in ${smartfrog.dist.lib.dir}</echo>
  </target>

  <!-- ========================================================== -->
  <!-- left in for backwards naming compatibility -->
  <!-- ========================================================== -->

  <target name="verify-smartfrog"  depends="assert-smartfrog" />

  <!-- ========================================================== -->
  <!-- probe for tasks and use them if they are found; fail if not -->
  <!-- ========================================================== -->
  <target name="use-smartfrog-tasks" depends="init-common"
    description="declare the classpath and imports for the smartfrog tasks">
    <path id="smartfrog.tasks.classpath">
      <path refid="smartfrog.core.classpath"/>
      <pathelement location="${smartfrog.tasks.jar}"/>
    </path>
    <available
      classname="org.smartfrog.tools.ant.Parse"
      classpathref="smartfrog.tasks.classpath"
      property="sfTasks.present"/>
    <property name="sftasks.fullpath" refid="smartfrog.tasks.classpath"/>
    <fail unless="sfTasks.present">
      Smartfrog tasks not found in
      ${sftasks.fullpath}
    </fail>
    <typedef
      resource="org/smartfrog/tools/ant/tasks.properties"
      classpathref="smartfrog.tasks.classpath"
      />
  </target>

  <!-- ========================================================== -->
  <!-- declare presets and macrodefs to enhance the tasks better
    for our needs -->
  <!-- ========================================================== -->
  <target name="declare-extended-smartfrog-tasks"
      depends="init,use-smartfrog-tasks,declare-classpaths">
    <presetdef name="sf-startdaemon-debug">
      <sf-startdaemon classpathref="run.classpath"
        logStackTraces="true" spawn="true">
          <!-- assertions are enabled -->
        <assertions enableSystemAssertions="true">
          <enable/>
        </assertions>
        <!--copy all proxy settings from the running JVM-->
        <syspropertyset refid="proxy.settings"/>
          <!-- load in a property file if it is present -->
        <propertyfile file="${runtime.properties}" optional="true"/>
      </sf-startdaemon>
    </presetdef>

    <presetdef name="sf-gui-debug">
      <sf-gui classpathref="run.classpath"
        logStackTraces="true" spawn="true">
          <!-- assertions are enabled -->
        <assertions enableSystemAssertions="true">
          <enable/>
        </assertions>
          <!-- load in a property file if it is present -->
        <propertyfile file="${runtime.properties}" optional="true"/>
      </sf-gui>
    </presetdef>

    <presetdef name="sf-console-debug">
      <sf-management-console classpathref="run.classpath"
        logStackTraces="true" >
          <!-- assertions are enabled -->
        <assertions enableSystemAssertions="true">
          <enable/>
        </assertions>
          <!-- load in a property file if it is present -->
        <propertyfile file="${runtime.properties}" optional="true"/>
      </sf-management-console>
    </presetdef>

  </target>

  <!-- ========================================================== -->
  <!-- set up an HTTP proxy -->
  <!-- there is a bit of a problem here for laptops whose proxy varies from
  location to location; we are ignoring that for now. -->
  <!-- ========================================================== -->

  <target name="init-web-proxy" if="http.proxy.host" depends="init">
    <property name="http.proxy.port" value="80" />
    <property name="http.proxy.user" value="" />
    <property name="http.proxy.password" value="" />
    <setproxy
      proxyhost="${http.proxy.host}"
      proxyport="${http.proxy.port}"
      proxyuser="${http.proxy.user}"
      proxypassword="${http.proxy.password}"
      />
  </target>

  <!-- ========================================================== -->
  <!-- set up a socks proxy -->
  <!-- ========================================================== -->
  <target name="init-socks-proxy" if="socks.proxy.host" depends="init">
    <property name="socks.proxy.port" value="1080" />
    <setproxy
      socksproxyhost="${socks.proxy.host}"
      socksproxyport="${socks.proxy.port}"
      />
  </target>

  <!-- ========================================================== -->
  <!-- conditionally initialise socks or web proxy, if configured -->
  <!-- ========================================================== -->
  <target name="init-proxy" depends="init-web-proxy,init-socks-proxy"/>

  <!-- ========================================================== -->
  <!-- location of testharness; create a relevant path -->
  <!-- ========================================================== -->

  <target name="use-smartfrog-testharness" depends="init-common" >
        <!-- information about the test harness -->
      <!-- needs to be in sync w/ testharness/build.xml -->
      <!-- TODO :use maven lib to sync -->
    <property name="testharness.dir"
      location="${core.dir}/testharness" />
    <property name="testharness.jar.name"
      value="sf-testharness-${Version}.jar" />
    <property name="testharness.jar"
        location="${testharness.dir}/${dist.lib.dir.relative}/${testharness.jar.name}" />
    <available file="${testharness.jar}"
      property="testharness.present" />
  </target>

  <!-- ========================================================== -->
  <!-- verify that the testharness is present-->
  <!-- ========================================================== -->
  <target name="assert-smartfrog-testharness" depends="use-smartfrog-testharness" >
    <fail unless="testharness.present">
      Smartfrog testharness not found at
      ${testharness.jar}
    </fail>
  </target>

  <!-- ========================================================== -->
  <!--  look for a local daemon. Sets the property  local.daemon.running if
    one is listening on port 3800-->
  <!-- ========================================================== -->
  <target name="probe-local-daemon" depends="init-common">
    <sf-daemonfound property="local.daemon.running" />
  </target>

  <!-- ========================================================== -->
  <!-- conditionally start the daemon if one was not found already-->
  <!-- ========================================================== -->
  <target name="start-daemon-if-needed"
    depends="declare-extended-smartfrog-tasks,probe-local-daemon"
    unless="local.daemon.running">
      <sf-startdaemon-debug  />
  </target>

  <!-- ========================================================== -->
  <!-- start the daemon in the foreground                         -->
  <!-- ========================================================== -->
  <target name="start-daemon-fg"
    description="start a daemon in the foreground"
    depends="declare-extended-smartfrog-tasks"
    >
      <sf-startdaemon-debug  spawn="false" timeout="-1"/>
  </target>

  <!-- ========================================================== -->
  <!-- conditionally start the GUI if one was not found already-->
  <!-- ========================================================== -->
  <target name="start-gui"
    depends="declare-extended-smartfrog-tasks" >
      <sf-gui-debug  />
  </target>


  <!-- ========================================================== -->
  <!-- Start the console -->
  <!-- ========================================================== -->
  <target name="start-console"
    description="start a console"
    depends="declare-extended-smartfrog-tasks" >
      <sf-console-debug  timeout="-1"/>
  </target>

  <!-- ========================================================== -->
  <!-- conditionally start the daemon if one was not found already-->
  <!-- and do not complain if it could not start (or execution timed out) -->
  <!-- ========================================================== -->
  <target name="start-daemon-if-needed-no-failonerror"
    depends="declare-extended-smartfrog-tasks,probe-local-daemon"
    unless="local.daemon.running">
      <sf-startdaemon-debug failonerror="false"/>
  </target>


  <!-- ========================================================== -->
  <!-- this is the counterpoint to start-daemon-if-needed
    if the probe did not find a daemon, then we shut down any daemon
    that we created.-->
  <!-- ========================================================== -->
  <target name="stop-daemon-if-started"
    depends="use-smartfrog-tasks"
    unless="local.daemon.running" >
    <sf-stopdaemon failonerror="false" />
  </target>

  <!-- ========================================================== -->
  <!-- public startup operation -->
  <!-- ========================================================== -->
  <target name="startup"
    depends="start-daemon-if-needed"
    description="start a local daemon">
  </target>

  <!-- ========================================================== -->
  <!-- always shutdown a local daemon. keep going if one is not running -->
  <!-- ========================================================== -->
  <target name="shutdown"
    depends="use-smartfrog-tasks"
    description="shut down a local smartfrog daemon">
    <sf-stopdaemon timeout="60000" failonerror="false" />
  </target>


  <!-- ========================================================== -->
  <!-- this is an override point -->
  <!-- ========================================================== -->
  <target name="init" depends="init-standard-output-dirs"/>


  <!-- ========================================================== -->
  <!-- this is here to set up the depends graph properly for
       overriden verify-prerequisites targets -->
  <!-- ========================================================== -->

  <target name="pre-verify-prerequisites" depends="init,declare-classpaths">
  </target>

  <!-- ========================================================== -->
  <!-- this is an override point -->
  <!-- set the verified.ok property if everything needed is present -->
  <!-- Do Not Fail. This test is used to control conditional builds -->
  <!-- NB, set property verify.fail.message to something meaningful
       for better diagnostic messages on failure (see assert-prerequisites)
       -->
  <!-- ========================================================== -->
  <target name="verify-prerequisites" depends="pre-verify-prerequisites">
    <property name="verified.ok" value="true"/>
  </target>

  <!-- ========================================================== -->
  <!-- entry point for the components/build.xml delegation;
       probe for needed libraries, and skip the operation if they
       are missing -->
  <!-- ========================================================== -->

  <target name="maybe-dist" depends="verify-prerequisites" if="verified.ok">
    <antcall target="dist" />
  </target>

  <!-- ========================================================== -->
  <!-- entry point for the components/build.xml delegation;
       default implementation runs batch-test if the
       prerequisites are met -->
  <!-- ========================================================== -->
  <target name="maybe-test" depends="verify-prerequisites" if="verified.ok">
    <antcall target="batch-test" />
  </target>

  <!-- ========================================================== -->
  <!-- entry point for the components/build.xml delegation;
       probe for needed libraries, and skip the operation if they
       are missing -->
  <!-- ========================================================== -->
  <target name="maybe-install" depends="verify-prerequisites" if="verified.ok">
    <antcall target="install" />
  </target>

  <!-- ========================================================== -->
  <!-- assert the prerequisites were found.
    Use this before you compile for a more meaningful failure message
    preset the property verify.fail.message for better diagnostics
    -->
  <!-- ========================================================== -->
  <target name="assert-prerequisites" depends="verify-prerequisites"
    unless="verified.ok">
    <property name="verify.fail.message"
      value="The prerequisite classes for this project were not found"/>
    <fail>${verify.fail.message}</fail>
  </target>


  <!-- ========================================================== -->
  <!-- this is an override point -->
  <!-- it does nothing but declare all the dependencies for compilation -->
  <!-- anything that overrides compile can declare a dependency on this -->
  <!-- target to get its dependencies right -->
  <!-- ========================================================== -->
  <target name="pre-compile"
      depends="init,declare-classpaths,assert-smartfrog,assert-prerequisites">
  </target>

  <!-- ========================================================== -->
  <!-- this is an override point -->
  <!-- compile everything, copy useful files over-->
  <!-- ========================================================== -->
  <target name="compile"
      depends="pre-compile">
      <depend srcdir="${src.dir}"
          destdir="${build.classes.dir}"
          cache="${build.dir}/depends"
          closure="yes"/>
      <sf-javac
          classpathref="compile.classpath"
          srcdir="${src.dir}"
          destdir="${build.classes.dir}"
          />
      <copy-useful-files src="${src.dir}" dest="${build.classes.dir}"/>
  </target>

  <!-- ========================================================== -->
  <!-- this is an override point -->
  <!-- RMI compile by looking for all remote classes in the
       compiled project-->
  <!-- ========================================================== -->
  <target name="rmi" depends="compile"
      description="create the RMI classes">
      <sf-rmic
          base="${build.classes.dir}"
          verify="true"
          compiler="${rmic.compiler}"
          includes="**/*.class">
          <classpath refid="compile.classpath"/>
      </sf-rmic>
  </target>

  <!-- another name for rmi -->
  <target name="compile-RMI" depends="rmi" />


  <!-- ========================================================== -->
  <!-- this is an override point -->
  <!-- compile everything, copy useful files over-->
  <!-- ========================================================== -->
  <target name="compile-tests"
      depends="package,assert-smartfrog-testharness,declare-classpaths">
      <depend
          srcdir="${test.src.dir}"
          destdir="${test.classes.dir}"
          cache="${build.test.dir}/depends"
          closure="yes"/>
      <sf-javac
          srcdir="${test.src.dir}"
          destdir="${test.classes.dir}"
          classpathref="tests.compile.classpath"
          />
      <copy-useful-files src="${test.src.dir}" dest="${test.classes.dir}"/>
  </target>


  <!--
  component only logic to create a versioned jar name.
  this is simpler now we read it from the source file
  -->
  <target name="generateversion" depends="generate-versioned-jar"/>

  <target name="generate-versioned-jar" if="is.component.enabled" depends="rmi">
    <presetdef name="get-version">
      <java classname="org.smartfrog.Version" failonerror="true" fork="true">
        <classpath>
          <pathelement location="${build.classes.dir}"/>
          <fileset refid="smartfrog.lib.fileset"/>
        </classpath>
      </java>
    </presetdef>
<!--    <get-version outputproperty="CVersion">
      <arg value="-b"/>
    </get-version>
    <get-version outputproperty="minVersion">
      <arg value="-min"/>
    </get-version>
    <get-version outputproperty="maxVersion">
      <arg value="-max"/>
    </get-version>-->
    <property name="jar.name" value="${artifact.name}${jarfile.suffix}-${Version}.${jarfile.extension}"/>
    <property name="target.jar"
        location="${dist.lib.dir}/${jar.name}"/>
    <sf-jar destfile="${target.jar}"
        basedir="${build.classes.dir}"
        includes="**/*"/>
    <echo level="verbose">created package ${target.jar}</echo>

    <!-- save everything to a file -->
    <!-- keep this in sync w/ common.xml's declaration -->
    <property name="sf.version.file" location="${dist.dir}/version.properties"/>
    <propertyfile
        file="${sf.version.file}"
        comment="This is machine generated. Do Not Edit!">
      <entry key="sf.build.date" type="date" value="now"/>
      <entry  key="sf.build.version" value = "${sf.build.version}"/>
      <entry key="sf.majorRelease" value="${sf.majorRelease}"/>
      <entry key="sf.minorRelease" value="${sf.minorRelease}"/>
      <entry key="sf.build" value="${sf.build}"/>
      <entry key="sf.status" value="${sf.status}"/>
<!--
      <entry key="sf.build.version" value="${CVersion}"/>
      <entry key="sf.min.version" value="${minVersion}"/>
      <entry key="sf.max.version" value="${maxVersion}"/>
-->
    </propertyfile>
    <echo level="verbose">version=${sf.build.version}</echo>
    <!--property name="Version" value="${sfversion}"/-->

  </target>

  <!--
    bypass all the self-referential stuff here.
  -->
  <target name="createjar" depends="generate-versioned-jar" if="is.component.not.enabled">
    <sf-jar destfile="${target.jar}"
             basedir="${build.classes.dir}"
             includes="**/*"/>
     <echo level="verbose">created package ${target.jar}</echo>
  </target>

  <!-- ========================================================== -->
  <!-- this is an override point -->
  <!-- create the JAR ${target.jar}-->
  <!-- ========================================================== -->
  <target name="package" depends="createjar"
    description="create the JAR files">
   </target>

  <target name="packaged" depends="package"
      description="create the JAR files">
  </target>

  <!-- ========================================================== -->
  <!-- this is an override point -->
  <!-- create the test jar ${test.jar}-->
  <!-- ========================================================== -->
  <target name="package-tests" depends="compile-tests"
      description="create the JAR file for the tests">
      <sf-jar destfile="${test.jar}"
        basedir="${test.classes.dir}"
        includes="**/*"/>
      <echo level="verbose">created package ${test.jar}</echo>
  </target>

  <!-- ========================================================== -->
  <!-- this is an override point -->
  <!-- everything for distribution -->
  <!-- ========================================================== -->
  <target name="dist" depends="package"
    description="create a distribution">
  </target>

  <target name="all" description="build, test and publish the code"
      depends="test,published,dist">
  </target>

  <!-- =================================================================== -->
  <!-- a clean distribution                                               -->
  <!-- =================================================================== -->
  <target name="fromclean" depends="clean,dist"
      description="create a clean distribution"/>

  <!-- ========================================================== -->
  <!-- this is an override point -->
  <!-- copy all dependencies -->
  <!-- ========================================================== -->
  <target name="install-dependencies" depends="package"
      if="smartfrog.dist.lib.dir">
    <copy-useful-files src="${lib.dir}"
        pattern="**/*.jar"
        dest="${smartfrog.dist.lib.dir}"
        failonerror="false"/>
  </target>

  <!-- ========================================================== -->
  <!-- this is an override point -->
  <!-- install the jar, if we know where to put it -->
  <!-- ========================================================== -->
  <target name="install" depends="package,install-dependencies"
      if="smartfrog.dist.lib.dir"
      description="copy the jar file to the SmartFrog distribution directory">
    <copy file="${target.jar}" todir="${smartfrog.dist.lib.dir}"/>
  </target>

  <!-- ========================================================== -->
  <!-- this is an override point -->
  <!-- generate test reports and break on failure-->
  <!-- ========================================================== -->

  <target name="reports" depends="init"
    description="generate the test reports" >
    <sf-test-report data="${test.data.dir}"
      reports="${test.reports.dir}"
      failed="test.failed"/>
    <echo>reports in ${test.reports.dir}</echo>
  </target>

  <!-- ========================================================== -->
  <!-- this is an override point -->
  <!-- generate test reports; ignore failur results-->
  <!-- ========================================================== -->

  <target name="reports-no-failure" depends="init"
    description="generate the test reports" >
    <sf-test-report data="${test.data.dir}"
      reports="${test.reports.dir}"
      failed="a.property.that.had.better.never.be.set"/>
    <echo>reports in ${test.reports.dir}</echo>
  </target>


  <!-- ========================================================== -->
  <!-- this is an override point -->
  <!-- system tests : anything that is tested on a live daemon
       not to be run on public machines for
       security reasons, unless security is active-->
  <!-- ========================================================== -->
  <target name="system-tests" if="system.tests.enabled"
          depends="init,package,package-tests,declare-extended-smartfrog-tasks"
    description="run the system tests">
  </target>

  <!-- ========================================================== -->
  <!-- this is an override point -->
  <!-- unit tests : anything which does not need deployment to run-->
  <!-- ========================================================== -->
  <target name="unit-tests" depends="init,package,package-tests"
      if="unit.tests.enabled"
    description="run the unit tests">
  </target>

  <!-- ========================================================== -->
  <!-- run tests, both unit and system  -->
  <!-- ========================================================== -->
  <target name="run-tests"
    depends="unit-tests,system-tests" />


  <!-- ========================================================== -->
  <!-- public entry point does all tests and the reports -->
  <!-- ========================================================== -->
  <target name="test"
    depends="run-tests,reports"
    description="compile and run all the tests"
    />

  <!-- ========================================================== -->
  <!-- public entry point does all tests and the reports -->
  <!-- ========================================================== -->
  <target name="batch-test"
    depends="run-tests,reports-no-failure"
    description="compile and run all the tests; do not break on test failure"
    />

  <!-- ========================================================== -->
  <!-- this is the gump entry point; it does packaging and tests -->
  <!-- ========================================================== -->
  <target name="gump"
    depends="test,dist,published"
    description="target for gump builds"
    />

  <!-- ========================================================== -->
  <!-- shortcut for testing -->
  <!-- ========================================================== -->
  <target name="smartfrog-dist"
    depends="init-common"
    >
    <ant dir="${smartfrog.home}" target="published" inheritall="false"/>
  </target>

  <!-- ========================================================== -->
  <!-- rebuild smartfrog, then run the tests
       this target is useful if you are changing smartfrog core
       as well as a component-->
  <!-- ========================================================== -->
  <target name="buildtest"
    depends="smartfrog-dist,test"
    description="compile the smartfrog distribution,
      compile and run all the tests, generate reports on failure"
    />

  <target name="buildtest-noreports"
    depends="smartfrog-dist,run-tests"
    description="compile the smartfrog distribution,
    compile and run all the tests, without any report stage"
    >
    <fail if="test.failed">Test failure</fail>
  </target>

  <!-- ========================================================== -->
  <!-- print meaningful diagnostics -->
  <!-- ========================================================== -->
 <target name="diagnostics" depends="init"
    description="build file diagnostics">
    <diagnostics/>
  </target>

 <target name="diag2" depends="init,verify-prerequisites">
    <echo>
      ant.version ${ant.version}
      build file ${ant.project.name}
      base dir ${basedir}
      core dir ${core.dir}
      junit.jar ${junit.jar}
      verified.ok=${verified.ok}

    </echo>
  </target>

   <!-- ========================================================== -->
  <!-- this is an override point -->
  <!-- default target -->
  <!-- ========================================================== -->
  <target name="default" depends="published"
    description="default target creates a distribution" />


 <!-- ========================================================== -->
  <!-- entry point for the components/buildRelease.xml delegation;
       probe for needed libraries, and skip the operation if they
       are missing -->
  <!-- ========================================================== -->

  <target name="maybe-buildrelease">
    <antcall target="release"/>
  </target>


  <!-- ========================================================== -->
  <!-- Security corner -->
  <!-- ========================================================== -->

  <target name="init-security" depends="init" >
    <!-- TODO -->
  </target>

  <target name="sign-dependent-jars" depends="init-security"
    description="sign all jars that we depend upon">
    <!-- TODO -->
  </target>

  <target name="sign-target-jar"
    description="sign our target jar" depends="package,init-security">
    <!-- TODO -->
  </target>

  <target name="checksum-target-jar"
    description="checksum our target jar" depends="sign-target-jar">
    <checksum file="${target.jar}" algorithm="md5"/>
    <checksum file="${target.jar}" algorithm="sha1"/>
  </target>

  <!-- ========================================================== -->
  <!-- init all the maven2 support   -->
  <!-- ========================================================== -->
   <target name="m2-init" depends="init,init-proxy,declare-extended-smartfrog-tasks,load-versions">
    <!-- Maven2 stuff
      All components build into the org.smartfrog group, unless otherwise stated, but
      are their own artifacts.
      -->
    <property name="m2.repository" location="${user.home}/.m2/repository" />


    <!-- make the root path of an artifact -->
    <macrodef name="m2-makepath">
      <attribute name="property"/>
      <attribute name="groupIDpath"/>
      <attribute name="artifactID" default="@{groupIDpath}"/>
      <attribute name="version"/>
      <sequential>
        <property name="@{property}"
          location="${m2.repository}/@{groupIDpath}/@{artifactID}/@{version}" />
      </sequential>
    </macrodef>

    <property name="m2.groupID" value="org.smartfrog" />
    <property name="m2.groupID.path" value="org/smartfrog" />
    <m2-makepath property="m2.subdir"
      groupIDpath="${m2.groupID.path}"
      artifactID="${artifact.name}"
      version="${Version}" />
<!--     <property name="m2.subdir"
      location="${m2.repository}/${m2.groupID.path}/${artifact.name}/${Version}" />
 -->
    <!-- pom setup -->
     <property name="target.pom"
         location="${dist.lib.dir}/${jarfile.stub}.pom"/>
     <property name="project.pom" location="project-template.pom"/>
     <available property="project.haspom" file="${project.pom}"/>
     <property name="m2.tasks.uri"
         value="antlib:org.apache.maven.artifact.ant"/>
     <available property="m2.tasks.available"
         resource="org/apache/maven/artifact/ant/antlib.xml"/>

     <property name="m2.ibiblio.repository"
         value="http://ibiblio.org/maven2"/>

     <property name="m1.local.repository"
         location="${user.home}/.maven/repository"/>
     <!--if there is no m1 repository, create it-->
     <mkdir dir="${m1.local.repository}"/>
     <sf-tourl file="${m1.local.repository}"
         property="m1.local.repository.url"/>
   </target>


   <!-- look for local then remote definitions of library versions -->
  <target name="load-versions" depends="init">
    <property file="libraries.properties"/>
    <property file="${smartfrog.components.dir}/libraries.properties"/>
  </target>

  <!-- ========================================================== -->
  <!-- POM creation/copy, depending on whether it exists or not   -->
  <!-- ========================================================== -->

   <target name="m2-copy-pom" depends="m2-init" if="project.haspom">
     <copy file="${project.pom}" tofile="${target.pom}" >
      <!-- we expand ant properties here.  -->
       <filterchain>
        <expandproperties/>
       </filterchain>
     </copy>
   </target>

   <!-- inline creation of a very minimal (zero dependency) pom -->
   <target name="m2-make-pom" depends="m2-init" unless="project.haspom">
   <echo message="Creating Pom ${target.pom}" level="verbose"/>
   <echo file="${target.pom}"><![CDATA[<project>
  <modelVersion>4.0.0</modelVersion>
  <groupId>${m2.groupID}</groupId>
  <artifactId>${artifact.name}</artifactId>
  <packaging>jar</packaging>
  <version>${Version}</version>
</project>
]]></echo>

   </target>

   <target name="m2-pom" depends="m2-copy-pom,m2-make-pom" />

  <!-- ========================================================== -->
  <!-- this is not  normally for overriding -->
  <!-- install the jar, to the local maven2 repository -->
  <!-- ========================================================== -->
  <target name="m2-install" depends="checksum-target-jar,m2-pom"
      description="copy the JAR file local maven repository">

    <mkdir dir="${m2.subdir}"/>
    <copy file="${target.jar}" todir="${m2.subdir}"/>
    <!-- copy a pom -->
    <copy file="${target.pom}" todir="${m2.subdir}" failonerror="false"/>
    <copy file="${target.jar}.md5" todir="${m2.subdir}" failonerror="false"/>

  </target>


  <target name="ivy-properties" depends="init-common-simpledefinitions,load-versions" >
    <property name="ivy.dir" location="${build.dir}/ivy" />
    <property name="ivy.lib.dir" location="${ivy.dir}/lib" />
    <property name="ivy.version" value="1.4.1" />
    <property name="ivy.resource" value="fr/jayasoft/ivy/ant/antlib.xml" />
    <property name="ivy.reports.dir" location="${ivy.dir}/reports"/>
    <property name="ivy.jar"
        location="${core.dir}/antbuild/ivy/lib/ivy-${ivy.version}.jar"/>
    <property name="ivy.ibiblio.root"
        value="http://www.ibiblio.org/maven2/"/>
    <available property="ivy.jar.found" file="${ivy.jar}" />
    <available property="ivy.resource.found" resource="${ivy.resource}" />
    <condition property="ivy.found" >
      <or >
        <isset property="ivy.jar.found"/>
        <isset property="ivy.resource.found"/>
      </or>
    </condition>
    <mkdir dir="${ivy.reports.dir}" />
    <mkdir dir="${ivy.lib.dir}" />
  </target>

  <target name="maybe-declare-ivy" if="ivy.enabled"
          depends="ivy-properties">
    <typedef uri="antlib:fr.jayasoft.ivy.ant" onerror="fail"
             resource="${ivy.resource}">
      <classpath>
        <pathelement location="${ivy.jar}"/>
      </classpath>
    </typedef>
  </target>

  <target name="declare-ivy" unless="ivy.enabled"
          depends="maybe-declare-ivy"
          >
    <typedef uri="antlib:fr.jayasoft.ivy.ant" onerror="fail"
             resource="fr/jayasoft/ivy/ant/antlib.xml">
      <classpath>
        <pathelement location="${ivy.jar}"/>
      </classpath>
    </typedef>
  </target>

  <target name="maybe-ivy-init"
          depends="declare-ivy"
          if="ivy.enabled" >
    <ivy:configure file="${core.dir}/antbuild/ivy/ivyconf.xml"/>
  </target>

  <target name="maybe-ivy-resolve" depends="maybe-ivy-init"
          if="ivy.enabled" >
    <ivy:resolve />
  </target>

  <target name="ivy-probe-repository"
      description="check that the repository is reachable"
      depends="ivy-properties">
    <property name="ivy.probe.path"
        value="${ivy.ibiblio.root}org/apache/ant/"/>
    <echo>Probing ${ivy.probe.path}</echo>
    <condition property="ivy.repository.reachable">
      <or>
<!--
        <isreachable url="${ivy.ibiblio.root}" timeout="10"/>
-->
        <http url="${ivy.probe.path}" />
      </or>
    </condition>
  </target>

  <target name="ivy-require-repository" depends="ivy-probe-repository"
      unless="ivy.repository.reachable">
    <fail>
      Unable to reach ${ivy.ibiblio.root}
    </fail>
  </target>

  <!--This is a trick. by running the same stuff
  as "maybe-ivy-init" with the opposite condition we, guarantee
  that the target code runs once, but only once-->
  <target name="ivy-init"
          depends="maybe-ivy-init"
      unless="ivy.enabled">
    <property name="ivy.lib.dir" location="${build.dir}/lib" />
    <ivy:configure file="${core.dir}/antbuild/ivy/ivyconf.xml"/>
  </target>

  <target name="ivy-resolve" depends="maybe-ivy-resolve,ivy-init"
          unless="ivy.enabled">
    <ivy:resolve />
  </target>

  <target name="ivy-retrieve" depends="ivy-resolve" >
    <property name="ivy.retrieve.pattern"
        value="[conf]/[artifact]-[revision].[ext]" />
    <property name="ivy.retrieve.path"
        value="${ivy.lib.dir}/${ivy.retrieve.pattern}" />
    <ivy:retrieve pattern="${ivy.retrieve.path}" sync="true" />
  </target>

  <target name="ivy-report" depends="ivy-resolve" >
    <ivy:report todir="${ivy.reports.dir}"/>
    <echo> published Ivy report to
${ivy.reports.dir}
    </echo>
  </target>

  <!--jars,-->
  <target name="ready-to-publish" depends="checksum-target-jar,ivy-report"/>

  <!--publish all artifacts-->
  <target name="ivy-publish" depends="ready-to-publish"
      xmlns:ivy="antlib:fr.jayasoft.ivy.ant">
    <ivy:publish resolver="local" pubrevision="${Version}"
        overwrite="true"
          conf="master"
        artifactspattern="${dist.lib.dir}/[artifact]-[revision].[ext]" />
  </target>

  <target name="ready-to-publish-all"
          depends="ready-to-publish,package-javadocs,package-documents"/>

  <!--publish everything, rather than just artifacts in the master config-->
  <target name="ivy-publish-all" depends="ready-to-publish-all"
          xmlns:ivy="antlib:fr.jayasoft.ivy.ant">
    <ivy:publish resolver="local" pubrevision="${Version}"
       overwrite="true"
       haltonmissing="false"
       artifactspattern="${dist.lib.dir}/[artifact]-[revision].[ext]" />
  </target>

  <target name="published" depends="ivy-publish-all,m2-install"
      description="Publish artifacts to the local repositories"
      />

  <target name="installed" depends="published"
    description="Place the system in a state in which the components are installed for reuse" />
  
  
</project>   


