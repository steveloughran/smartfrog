\documentclass[draft]{article}
%twocolumn , a4, ,twoside

%see http://ringlord.com/publications/latex-pdf-howto/
\newif\ifpdf
\ifx\pdfoutput\undefined
    \pdffalse           % we are not running PDFLaTeX
\else
    \pdfoutput=1        % we are running PDFLaTeX
    \pdftrue
\fi
%----------------------------------------------------------------------
\ifpdf
    \usepackage[pdftex,
        colorlinks=true,
        urlcolor=rltblue,       % \href{...}{...} external (URL)
        filecolor=rltgreen,     % \href{...} local file
        linkcolor=rltred,       % \ref{...} and \pageref{...}
        pdftitle={What's wrong with the Java SOAP API?},
        pdfauthor={Steve Loughran},
        pdfsubject={Web Service Development},
        pdfkeywords={Web Services, SOAP, WSDL, JAX-RPC, JAX-M},
        pdfpagemode=None,
        bookmarksopen=true]{hyperref}
%        pagebackref,
    \pdfcompresslevel=9
    \usepackage[pdftex]{graphicx}
\else
    \usepackage[
        colorlinks=true,
        urlcolor=rltblue,               % \href{...}{...}
        anchorcolor=rltbrightblue,
        filecolor=rltgreen,             % \href*{...}
        linkcolor=rltred,               % \ref{...} and \pageref{...}
        menucolor=webdarkblue,
        citecolor=webbrightgreen]{hyperref}
    \usepackage{graphicx}
\fi
\usepackage{color}
\definecolor{rltred}{rgb}{0.75,0,0}
\definecolor{rltgreen}{rgb}{0,0.5,0}
\definecolor{rltblue}{rgb}{0,0,0.75}
\definecolor{rltbrightblue}{rgb}{0,0,1}
\definecolor{webdarkblue}{rgb}{0,0,0.5}
\definecolor{webbrightgreen}{rgb}{0,0,0.75}

\begin{document}

% line spacing of 1.5 lines
%\renewcommand{\baselinestretch}{1.5}

%gaps between paragraphs
%\setlength{\parskip}{3ex}

%don't indent new paragraphs
%\parindent 0pt


\title{What's wrong with the Java SOAP API?}
\author{
    Steve Loughran, HP Laboratories,\\
    Edward Smith, Edinburgh University. 
%    \\
%    slo@hplb.hpl.hp.com, 
    }
\maketitle
\begin{abstract}

This paper looks at the primary api for SOAP in Java, JAX-RPC, and
shows how it is fundamentally flawed. The core problem is that attempting
to make SOAP messaging resemble method calls on remote Java objects, leads
to a whole variety of options. 

First, it misleads users into thinking that JAX-RPC enables arbitrary Java classes
to be exported as SOAP endpoints, exchanging abitrary Java data. Not only do 
inexperienced users get caught out by the fact that this is not possible, 

Secondly, the automatic generation of WSDL from Java code leads to a blurring
of implentation with the interface specification, making it impossible to prevent
unexpected contamination of interface and implementation.

Even if a strict WSDL-first process is followed, the results prove unacceptable.
The naming rules for generated classes and members have flaws that we will cover.
Most seriously, this compile-time generation of java source from WSDL,
be it client or server creates java code that is inordinately brittle. A single change
in the XML Schema can result in generating a new set of classes that is not
at all compatible with the predecessor -even if the existing code would still have worked.

We believe that there has to be a better approach, and outline an alternative.



\end{abstract}

%\tableofcontents



\section{Introduction: JAX-RPC}

JAX-RPC is the acronym of ``Java API for XML-based RPC'' \cite{spec:JAX-RPC-11}, 
one of the two official APIs for SOAP in Java. 
The other, SAAJ, SOAP with Attachments API for Java \cite{spec:SAAJ-11}
The two APIs represent alternate viewpoints. In JAX-M, the developer works with the
XML body of the message, in JAX-RPC all the details of how the message is encoded
is hidden, and the developer works with Java objects that are automatically mapped
to and from XML data. 

JAX-M is essentially defunct. There is no apparent work on a successor;
instead the focus is on an improved version of JAX-RPC. 

JAX-RPC is widely implemented, in the open source Apache Axis SOAP stack \cite{axis},
along with commercial versions from vendors such as Sun, IBM and BEA. It is the de-jure
and the de-facto standard for making and processing SOAP calls in Java. 


\section{the hard lessons of service implementation}

Both authors have recently been making independent implementations of a SOAP API
for deployment. This API is defined by a set of XML Schema and WSDL files, the
end result of which is a service endpoint which supports seven operations. The 
operations permit suitably authenticated callers to deploy distributed applications
to indivudual machines, or a whole grid fabric. This service was defined in the pure way, 
by writing the XSD and WSDL files first, the goal being a platform-independent, highly
interoperable deployment mechanism. 

One of the features of this service was that it was intended to support 
multiple deployment languages, and multiple deployment engines, each potentially
with different capabilities and options. To this end, some features of the design
stand out. 

Firstly, the deployment payload is arbitrary XML. It is not appropriate 
or possible for the service definition to declare what deployment languages are 
supported. 

Secondly, we defined an option mechanism, in which callers can set
arbitrary options on a deployment. Each option can have a string, integer or XML value,
and is identified in a set of options by a URI. We plan to define some normative options
within the working group, and allow implementations to define new ones. 
Following the example of the WebDAV and SOAP header designs, a 

Thirdly, we need to raise lifecycle event notifications with callers. In the absence
of a single, stable notification protocol, we chose to allow services to support multiple
mechanism (again, each defined by arbitrary inline XML).

The XSD file for the service messages is approximately 2000 lines, of which  seventy-five percent
is either comment or XSD annotations. 

\section{Why SOAP?}

Before proceeding, we must recall the core rationales for using SOAP 
were:
\begin{enumerate}
\item simplicity: SOAP was to be easy to work with.
\item interoperability: more interoperable than binary predecessors
\item extensibility: the SOAP Header allowed extra data to be attached to a
request. 
\item self-describing: messages could contain type definitions with the
data, and provide human readable names
\item flexibility: participants could handle variable amounts of
incoming data.
\item XML-centric: which should make it easier to insert arbitrary XML
inside a request.
\item long-haul: designed to work through firewalls, over HTTP
\item loosely-coupled: participants were not expected to share
implementation code.
\end{enumerate}

SOAP has become just an extension of XML-RPC
\cite{spec:XML-RPC} with richer content, but the underpinning of many
organisations vision of the future of the Internet. It also strived to
overcome many of the failings of precursor technologies such as CORBA or
DCOM. These technologies work well over local area networks, and enable
rich bidirectional communications, but are not completely cross
platform\footnote{albeit for political rather than technical reasons},
and ended up being used to produce distributed object systems that were
too \emph{tightly coupled}.

"Tightly coupled" has come to be viewed as a bad thing in a distributed
system. If components are too tightly coupled, it implies that the
separate components have merged to become one large system, one which
cannot be treated except as a whole. And in a sufficiently large system,
it is impossible to co-ordinate the whole \cite{deutsch, jini}. The move
towards SOAP and a Service Oriented Architecture was advocated as a
means of dealing with loose organisational coupling, by forcing a loose
data coupling between applications. 

The SOAP communications can be viewed as an XML-based remote procedure
calling mechanism, or as a way of submitting XML documents to remote
URLs, optionally with responses coming back as XML documents. These
represent the RPC-centric and message-centric viewpoints. For better or
worse, an RPC-centric model is what appears to have succeeded in Java as
the primary means to model SOAP communications. 





\section{the tar pit of Object-XML Mapping}

Ted Neward has described that \emph{"object-relational mapping is the Vietnam of
Computer Science"}, by which he means that it is neer a problem you can declare
victory over, merely invest more and more effort to get deeper into the
quagmire.
%http://www.neward.net/ted/weblog/index.jsp?date=20041003#1096871640048

The problem of translating between XML and objects is similar, except there is
less experience of dealing with the problem, and we have forgotten how many
failed attempts there have been to solve the O/R mapping problem. We show that
we forget this by using the terms \emph{serialization} and \emph{deserialization} 
to describe the mapping stages, rather than the phrase \emph{O/X mapping}.

At first glance, O/X mapping seems simple: convert 1:1 between Java and XML
objects, create a DAG graph when serializing to rpc/encoded SOAP, a tree with
doc/lit messages. Read or write between attributes and class fields, bind to
children and that's it. Isn't it? 

If only. Here are some of the problems.

\begin{itemize}

\item deciding which classes to use for an endpoint, and
deciding which XML elements to use for a Java class. 

\item deciding which types to use for the XML encoding. In rpc/enc messages,
this type must be explicitly declared from the small set of possible types. In
doc/lit messages, the type is omitted in messages. 

\item generating the WSDL description of service types through introspection.

\item map from XML names to valid Java names.

\end{itemize}

One particular problem is that the language of XML Schema is much richer than 
the object model of Java. In Java, inheritance can extend a type, and change
some existing semantics, but inheritance-by-restriction is not explictly
supported. Whereas in XML Schema, it is simple to declare that a dog is a mammal 
with four legs, and a three legged dog is a restriction where the number of legs
must be three. 

\subsection{The enum problem}

One specific example that deserves special mention is how \verb$xsd:enumeration$
declarations are mapped to Java. Prior to Java1.5, there was no explict
\verb$enum$ clause in the language, so workarounds were developed. The JAX-RPC
solution is that of a common pattern: to declare a class with a public static
instance representing a valid enumeration value. The WSDL to Java code generates
such a class, with the name of each static class taken from the name of each
value in the enumeration. 

This is a simple example of how O/X mapping should work. Except, what if the
value of the one of the enumeration types is a reserved word, such as in the
lifecycle state machine we wrote:

\verb$$
 %<xsd:simpleType name="lifecycleStateEnum">
%    <xsd:restriction base="xsd:string">
%      <xsd:enumeration value="initialized"/>
%      <xsd:enumeration value="running"/>
%      <xsd:enumeration value="failed"/>
%      <xsd:enumeration value="terminated"/>
%      <xsd:enumeration value="null"/>
%    </xsd:restriction>
%  </xsd:simpleType>
%$

One element in the enumeration is reserved, \verb|null|, so the enumeration must
now enumerate all states as \verb|value1|, \verb|value2|, and so on, for
the entire list. This means the enumeration names in the Java source no longer 
contains any value at all, other than the position number in the set. This is
inordinately brittle, as any change to the enumeration could reorder the values,
without the code detecting a change.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%pull this; no longer valid
% 
% \subsection{the mystery of unsigned long}
% 
% There is an \verb|unsignedLong| datatype in XML Schema. The JAX-RPC1.0 documents
% blissfully ignored this fact. Why so? Presumably because there is no way to
% represent an unsigned long in a simple java datatype. 
% 
% The implication of this absence is that there was no guarantee that a Java
% application can make SOAP requests of a service which uses unsigned long
% numbers. This is unfortunate, as there is nothing to stop a C++ or .NET SOAP
% endpoint from using such numbers. This was a foundational barrier to
% cross-platform interoperability. 
% 
% It has appeared in the JAX-RPC1.1 specification, for which we must be grateful,
% although we are still unable to use it our service for fear of a version1.1
% client attempting to talk to us

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{XSD validation}

An XML schema document, as used to describe a doc/lit payload, can contain many
declarations about what constitutes a valid XML document. \emph{Restrictions}
can restrict the type of a value, such as the range of an integer from zero to
ten. The \verb|minOccurs| and \verb|maxOccurs| declarations are used to declare
what allowed number of occurences of an element are. None of these values are
used. Restricted integer types are just mapped to normal integers, while element
occurence declarations are ignored. 

This means that the set of XML documents which an endpoint can receive, is
significantly larger than the set of XML documents which its XML schema will
declare that it can support. With no built-in validation, developers must either
write validation logic themselves -and corresponding tests, or ignore the
problem. Given that there is no warning that the problem occurs, we suspect that
ignorance is the common process. Not writing the logic to recognise and reject
illegal documents is not likely to show up in development -especially if a
test-centric process is not followed- but is inevitable once a service goes live,
and callers using other languages invoke the service. Such insidious defects,
defects that only show up in production, are never welcome. 

We note that there is a trivial solution to this problem, one that is common to
other XML stacks. It is: validate incoming messages against the XML schema of
the service. This is not done for performance, yet the effect is to hide
defects.  



\section{Fault processing}

\footnote{Before we criticise faults, we must note that one of the authors has his name
in the source of the AxisFault fault class, so may not be without blame
himself.}

JAX-RPC tries to marshall Java faults over the network, in such a way as they
can be reconstituted at the far end into the same fault. To manage this is a
somewhat complex process, as the classname of the fault must be exchanged as the
fault code

We believe that attempting to seamlessly marshall faults is a mistaken approach.
It propagates the still controversial "declare all possible faults" rule of Java
into remote interfaces, and so exposes platform implementation details into the
service interface. If a service could only raise a normal SOAPFault, or
developers were forced to declare and then implement custom wsdl:fault elements,
then a service definition would be platform-neutral. 

As well as the marshalled faults, the specification includes one
standard fault, SoapFaultException. 

\section{Blocking RPC is often inappropriate}

One fast network, RPC invocation is often a good choice as a
communication paradigm. Other models of communication are harder to
code, and the benefits are not apparent. 

It is only when working over long-haul connections, or with large
content -such as a fifteen megabyte attachment- that the limitations of
RPC patterns become clear. The only option we currently have is
to split network communication into a separate thread from any
interactive GUI thread, keeping the front end usable. While this keeps 
the front end responsive, JAX-RPC provides no way to give the user
effective feedback or control over the communications. Specifically,  
there is no way to receive
progress notifications or cancel an active call, even though the underlying 
transport code invariably permits such features. 


\section{Java RMI is the wrong metaphor}

JAX-RPC suffers from a greater flaw than simply the classic limitations
of RPC invocation. JAX-RPC tries to make the communications is
that it tries to make it look like Java RMI. Java RMI is a simple and effective
mechanism for connecting Java classes running on different machines. It is an
IDL-free communication mechanism, which relies on introspection to create proxy
classes and to marshall classes. It works because the systems at both ends are
Java, usually different pieces of a single larger application. 

With synchronized versions of common code, objects can be trivially
serialized and sent over a network connection. Exceptions are just
another type of object, and so too can be sent over the wire. There is
no need for an IDL, as Java interface declarations can perform much of
the same role. And as the recipient is a remote object, state is
automatic.

JAX-RPC tries to reuse as much of the programming patterns of RMI. For example,
the runtime will attempt to serialize classes marked as \verb|serializable|,
ignoring those fields marked as \verb|transient|. It will even serialize complex
compound objects, if possible. The user appears to have a reference to something
like an object, though one that represents the current conversation with an endpoint,
not a direct endpoint proxy. 

When a message gets delivered to its endpoint, the normal handler for
dispatching the message creates an instance of the relevant Java class and then
dispatches the request to it. The message is turned into an invocation of an
instance of a remote object, which certainly looks like RMI, even if the
lifecycle of the class is radically different. 


We can see the consequence of this metaphor on the mailing list of users of
Apache Axis. All too often, someone is confused by the errors displayed when
they try and do something that they expect to work, such as send an low level
class such as \verb|java.io.File| instance, or a \verb|javax.swing.JPanel|. The
latter is serializable in RMI, yet clearly does not make sense for an
interoperable web service. 

While it would be easy to laugh at their naiive and unrealistic
expectations, we have to recognise that these users have been led to
such expectations through a combination of marketing "Web Services!
They're easy!" and the fact that JAX-RPC creates the illusion of being
just like RMI. It is often even relatively easy to write the code that
looks like a SOAP service, and then try and deploy it, only to find at
runtime that the introspection system rejects Java classes as
unacceptable, or the serialization logic raises deserialization
exceptions when inbound messages are processed. A quick perusal of the
Apache Axis User
list\footnote{http://mail-archives.apache.org/eyebrowse/SummarizeList?listId=209}
will demonstrate that these -along with deployment failures- are the
common problems.




\section{the danger of code-first service declaration}



\section{Implications}

What are the implications of these problems?

Let's put those people writing web services into two categories: those
who know and want to work with XML, and those who don't. 

JAX-RPC only benefits those who do not want to work with XML, by hiding
all the details, giving developers a model of remote method calls of
serialized java graphs. We have argued that this is a mistake, 
as it leads to O/X mapping problems, and retains an invocation model
that is inappropriate to long-distance networks or slow communications. 

JAX-RPC may hide the details of the XML, but instead present the users
with serialization errors, interoperability problems, and the challenge
of trying to maintain version consistency when the interface is derived
solely from introspection of the implementation classes.


For users who do want to work with XML, JAX-RPC is inappropriate because
it hides everything. Trying to integrate custom XML documents with
JAX-RPC serializations is possible, but very hard work and somewhat
inefficient, as DOM trees get recreated when assigning or extracting DOM
trees from SoapMessageElement implementations -at least with Apache
Axis.

There is one further problem with the JAX-RPC design and open source
projects. By isolating all the XML in the implementation, it creates a
big gulf between the exceedingly complex implementation code -low level
SAX and DOM processing, code generation from WSDL metadata, WSDL
generation from introspection, fault processing- and the end user code.
This makes it hard for end users to become developers, which is exactly
what open source platforms want. Open source projects succeed from the
contributions of the users, so depend upon users who are able and
willing to understand the implementation. JAX-RPC, by its very nature,
places too hard a boundary between end users and developers.

For the developers of proprietary implementations, this is not an issue,
and the inherent complexity of the implentation results in a product the
vendors can charge for. It is hard to get serialization,
interoperability, WSDL processing and introspection right, and then
there is the performance issue. Perhaps this is why both webMethods GLUE
and the BEA JAX-RPC implementations have a reputation for being faster
and more reliable than the open source version. 

It can only get worse. JAX-RPC has moved to become the centerpiece of
enterprise Java, in which RMI- and CORBA- based distributed
communications are considered legacy protocols. That is not by itself a
bad thing, but we believe that migration to Web Service should be done
from a position of understanding the XML and the message. Instead, more
and more developers will feel obliged to write Web Service accessors to
their code, and in doing so, fall into the traps that JAX-RPC creates
for them.




\section{JAX-RPC 2.0}

The forthcoming JAX-RPC2.0 specification promises to correct some of the
flaws, but not enough. An alternate O/X mapping is used, the JAX-B
specification. This is independent from the SOAP Stack, but it still
represents a compile-time declaration of what XML is to be expected.


It also retains the core metaphor of service invocation as methods, with the 
payload of most invocations being Java objects that are somehow mapped to XML content.
Furthermore, the automated generation of WSDL from Java source is hard. 

We understand the rationale for much of this. Working with raw XML is hard. 
Writing good XML Schema documents is hard. WSDL is exceedingly painful to work with,
it is like an interface definition language only more verbose and more complex. 

Yet if service developers do not go to the effort of writing their XSD
and WSDL definitions of messages, then they will never have control of
the format of the messages that get sent over the wire. Without that
control, interoperability and XML-based processing will be hard. Instead
the developers will be stuck at the mercy of JAX-RPC and JAX-B.

\section{Alpine: a proposed alternative}

We are in the preliminary stages of designing an alternative SOAP stack
for Java, by the name of \emph{Alpine}. 

\subsection{Manifesto}

Our goal is a SOAP stack that is easy to use, client or server, 
\emph{by Java developers who know XML}. 


There will be no attempt to perform O/X mapping, so bypassing all the
related problems. Similarly, a WSDL file must be hand written if it is
desired, so there is no need (or option) to generate one through
introspection.

Developers will be expected to use XPath specifications to work with
contents of the message; we well depend upon XOM for our XML binding
\cite{harold:xom}.

The full design goals are as follows:

\begin{enumerate}

\item Stay in the XML Space as much as possible
\item Take advantage of as much leading edge infrastructure as we can
\item Adopt the the handler chain pattern of Axis/JAX-RPC
\item Target SOAP1.2 (POST) only, WS-I 1.1
\item Document/literal only
\item Java 1.5 or later 
\item Server side and client side, with both sides looking similary. 
\item No support for JAX-RPC or JAX-M/SAAJ.
\item Configurable only procedurally -or through JMX. 
\item One supported parser: Xerces

\item No provision of side features such as a built in HTTP server (e.g.
\verb|SimpleAxisServer|), or declarative configuration mechanism.
These are delegated to other products.
\end{enumerate}

By removing extraneous yet useful features, we introduce dependencies on
many other components to work correctly. Yet we also reduce development
and support effort. 

What is alpine going to consist of then? With so much stripped out, a
SOAP stack gets reduced to its essentials: a system for managing the
flow of messages through a set of handlers, and transports libraries to
handle transport across supported protocols. Core compliance with the
SOAP protocol would be provided: envelope validation,
\verb|mustUnderstand| processing of headers. 

This is not going to be a SOAP stack for use by anyone who wants to make
SOAP operations look like a remote procedure call; it is not going to be
for anyone who wants to ignore the format of the messages sent or
received over the wire. 

Instead, it is going to provide the basic housekeeping and handler chain
management to make life simpler for XML experts who are prepared to work with XOM. 

\section{Acknowledgements}

Ias. Tim Ewald. Ted Neward.  


---------------------------






%pull in our bibliography

\onecolumn

%\bibliographystyle{plain}
\bibliographystyle{alpha}
\bibliography{bibliography}

\end{document}
