\section{Introduction}
\label{introduction}

In any discussion of SOAP-based technologies, it is important to
remember the core reasons for adopting SOAP originally. We
characterise them as follows:

\begin{enumerate}
\item \textbf{simplicity}: It is intended to be easy to work with.
\item \textbf{interoperability}: It is more interoperable than binary predecessors
\item \textbf{extensibility}: \tocheck{The header construct allows extra data to be attached to a
request, without breaking existing clients.}
\item \textbf{self-describing}: Messages can contain type definitions alongside
data, and provide human readable names.
\item \textbf{flexibility}: Participants can handle variable amounts of
incoming data.
\item \textbf{XML-centric}: Inserting arbitrary XML inside a requests
is easier.
\item \textbf{long-haul}: It is designed to work through firewalls, over HTTP.
\item \textbf{loosely-coupled}: Participants are not expected to share
implementation code.
\end{enumerate}

We will refer to these criteria throughout our discussion, as the
desiderata against which any SOAP technology should be judged.

\subsection{SOAP in Java}
\label{intro:java}

Communication with SOAP can be viewed as XML-based remote procedure
calls, or as a way of submitting XML documents to remote URLs ( with
optional responses coming back as XML documents). These two different
perspectives represent the RPC-centric and message-centric
viewpoints. An RPC-centric model appears to have become the primary
focus of SOAP modelling in Java.

The Java APIs representing the two different underlying perspectives
are JAX-RPC\footnote{Java API for XML-based RPC}
\cite{spec:JAX-RPC-11} and JAX-M\footnote{Java API for XML Messaging}
\cite{spec:JAX-M-11}. In JAX-M, the developer works with the XML body
of the message, in JAX-RPC all the details of how the message was
encoded are hidden, and the developer works with Java objects created
automatically from the XML data using a mapping process.

JAX-M lives on in the form of \todo{.... finish this sentence!}

- there is no apparent work on a
successor, with focus instead being placed on an improved version of
JAX-RPC. JAX-RPC, in contrast, is widely implemented, both by open
source projects (for example Apache Axis \cite{axis}), and by
commercial vendors like Sun, IBM and BEA.  The bias is such that, for
Java development, SOAP has essentially become just an extension of
XML-RPC \cite{spec:XML-RPC} with richer content.

\subsection{The Hard Lessons of Service Implementation}
\label{intro:experience}

Both authors have recently been making independent implementations of
a SOAP API for deployment. This API, specified in a set of XML Schema
(XSD) \cite{spec:XSD} and Web Services Description Language (WSDL)
files \cite{spec:WSDL} defines a service endpoint which providing
seven operations. These operations permit suitably authenticated
callers to deploy distributed applications to a grid fabric.

This service was defined in a ``pure way'', by writing the XSD and
WSDL files first. \tocheck{This approach is believed to aid in
creating a platform-independent system, and represents current best
practice.} However, the XSD file for the service messages is
approximately 2000 lines, of which seventy-five percent is either
comment or XSD annotations. That it takes so many lines to describe a
relatively simple service is clearly one reason why this approach,
despite its superiority of output, is so unpopular. 

\todo{Any other problems we experienced that were clearly related to
JAX-RPC sucking would be good here, eg. namespaces, introspection and
so forth}.

In section \ref{objections} we discuss a number of problems we believe
this work highlighted with JAX-RPC. Section \ref{objections:wsdl-gen}
outlines the particular problems we believe typical JAX-RPC oriented
approaches to WSDL generation create.

%% The subsequent sections do not establish their own relevance to 
%% the question of why JAX-RPC sucks. We either need to find a link
%% between these issues and JAX-RPC sucking, or cut them.

% One of the features of this service was that it was intended to
% support multiple deployment languages, and multiple deployment
% engines, each potentially with different capabilities and options. To
% this end, some features of the design stand out.

% Firstly, the deployment payload is arbitrary XML. It is not
% appropriate or possible for the service definition to declare what
% deployment languages are supported.

% Secondly, we defined an option mechanism, in which callers can set
% arbitrary options on a deployment. Each option can have a string,
% integer or XML value, and is identified in a set of options by a
% URI. We plan to define some normative options within the working
% group, and allow implementations to define new ones.  Following the
% example of the WebDAV and SOAP header designs, options can be ignored
% unless their \verb|mustUnderstand| attribute is set. With a few well
% known option types defined for the nested XML option, we wanted
% to treat options just like other received data, and use the XML to Java
% mapping facility of the classes. 

% Thirdly, we need to raise lifecycle event notifications with
% callers. In the absence of a single, stable notification protocol, we
% chose to allow services to support multiple mechanism (again, each
% defined by arbitrary inline XML).



