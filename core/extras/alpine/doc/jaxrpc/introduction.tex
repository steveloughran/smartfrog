\section{Introduction}
\label{introduction}

In any discussion of SOAP-based technologies, it is important to
remember the core reasons for adopting SOAP originally. We
characterise them as follows:

\begin{enumerate}
\item \textbf{simplicity}: It is intended to be easy to work with.
\item \textbf{interoperability}: It is more interoperable than binary predecessors
\item \textbf{XML-centric}: Built on XML, and intended to integrate
with XML-based technologies.
\item \textbf{extensibility}: The envelope/header/body structure allows extra data to be attached to a
request, potentially without breaking existing systems.
\item \textbf{self-describing}: Messages can contain type definitions alongside
data, and provide human readable names.
\item \textbf{flexibility}: Participants can handle variable amounts of
incoming data.
\item \textbf{long-haul}: It is designed to work through firewalls, over HTTP.
\item \textbf{loosely-coupled}: Participants are not expected to share
implementation code.
\end{enumerate}

We will refer to these criteria throughout our discussion, as the
desiderata against which any SOAP technology should be judged.

\subsection{SOAP in Java}
\label{intro:java}

Communication with SOAP can be viewed as XML-based remote procedure
calls, or as a way of submitting XML documents to remote URLs ( with
optional responses coming back as XML documents). These two different
perspectives represent the RPC-centric and message-centric
viewpoints. The RPC-centric model has become the primary
model of SOAP APIs in Java.

The Java APIs representing the two different underlying perspectives
are JAX-RPC\footnote{Java API for XML-based RPC}
\cite{spec:JAX-RPC-11} and JAXM\footnote{Java API for XML Messaging}
\cite{spec:JAX-M-11}. 


\subsubsection{JAXM}

JAXM was written to support basic SOAP, and more complex scenarious
such as asynchronous ebXML message exchange over SOAP, a requirement
which introduces extra complexity to the design. 

Over time, the ebXML focus of JAXM has declined, while the API itself
has been renamed  SOAP with Attachments API for Java ---SAAJ \cite{spec:SAAJ-12}. 

In JAXM/SAAJ, the developer has a Java interface, bound to a 
class that represents the body of the message, with operations to
manipulate the pieces. These operations include accessors and
manipulators of the envelope, headers, the body and any binary attachments. In
SAAJ, all these pieces of the model are accessed via interfaces which
implement the DOM \cite{spec:DOM} model of navigating around XML nodes.

JAXM does not provide significant transport support. The primary method
of receiving JAXM messages is to implement and deploy an HTTP servlet.
The sole method of sending a servlet is to ask a
\verb|SOAPConnectionFactory| for a \verb|SOAPConnection| instance, and
then make a blocking call of the endpoint.

JAXM is an orphan specification. If ebXML had taken off, perhaps it
would be more popular, and message-centric SOAP development in Java
commonplace. Instead JAX-RPC is touted as the recommended way to work
with SOAP in Java. 


\subsubsection{JAX-RPC}

In JAX-RPC, all the details of how the message was
encoded are hidden, and the developer works with Java objects created
automatically from the XML data using a semi-standardised mapping process.

Java classes can be automatically turned into SOAP endpoints, with each
public method in the class exported as a SOAPAction; an operation with a
request message and a response message. The message structure is
described in a WSDL file, which can be hand-written, or automatically
extracted from the Java classes through intospection. Client side
proxy classes can be generated from the WSDL files, proxy classes which
again provide a method for every SOAPAction. In Java-Java
communications, the result is that methods called on the proxy class
result in the passing of the method parameters to remote methods 
on an instance of the implementation class, a behaviour that superficially
resembles Java RMI \cite{paper:RMI}.

A good architectural feature of JAX-RPC is its \emph{handler chain}; an
ordered sequence of classes that are configured to handle requests and
responses. It is through the handler chain that support for new SOAP
headers can be added to existing services, or extra diagnostics applied.
Dispatch of operations to java methods, EJB methods or other
destinations is actually implemented in specific handlers, showing that
the handler chain is the foundation for the rest of the system.

JAX-RPC is widely implemented, both by open source projects (for example
Apache Axis \cite{apache:axis}), and by commercial vendors like Sun, IBM
and BEA. The SOAP toolkits do all implement the appropriate version of
JAXM/SAAJ to go alongside the RPC model, but this feature is not broadly
covered. All the \emph{evangelisation} of SOAP focuses on JAXRPC, as do
most of the examples in the vendors' documentation.

The bias is such that, for Java development, JAXRPC \emph{is} SOAP. 

\subsection{The Hard Lessons of Service Implementation}
\label{intro:experience}

Both authors have recently been making independent implementations of
a SOAP API for deployment. This API, specified in a set of XML Schema
(XSD) \cite{spec:XSD} and Web Services Description Language (WSDL)
files \cite{spec:WSDL-11} defines a service endpoint which providing
seven operations. These operations permit suitably authenticated
callers to deploy distributed applications to a grid fabric.

This service was defined in a ``pure way'', by writing the XSD and
WSDL files first. This approach is believed to aid in
creating a platform-independent system, and represents current best
practice. However, the XSD file for the service messages is
approximately 2000 lines, of which seventy-five percent is either
comment or XSD annotations. That it takes so many lines to describe a
relatively simple service is clearly one reason why this approach,
despite its superiority of output, is so unpopular. 

Many problems were encountered turning this WSDL specification into
functional clients and servers, problems that we attribute to JAX-RPC.

In section \ref{objections} we discuss a number of problems we believe
this work highlighted with JAX-RPC. Section \ref{objections:wsdl-gen}
outlines the particular problems we believe typical JAX-RPC oriented
approaches to WSDL generation create.

%% The subsequent sections do not establish their own relevance to 
%% the question of why JAX-RPC sucks. We either need to find a link
%% between these issues and JAX-RPC sucking, or cut them.

% One of the features of this service was that it was intended to
% support multiple deployment languages, and multiple deployment
% engines, each potentially with different capabilities and options. To
% this end, some features of the design stand out.

% Firstly, the deployment payload is arbitrary XML. It is not
% appropriate or possible for the service definition to declare what
% deployment languages are supported.

% Secondly, we defined an option mechanism, in which callers can set
% arbitrary options on a deployment. Each option can have a string,
% integer or XML value, and is identified in a set of options by a
% URI. We plan to define some normative options within the working
% group, and allow implementations to define new ones.  Following the
% example of the WebDAV and SOAP header designs, options can be ignored
% unless their \verb|mustUnderstand| attribute is set. With a few well
% known option types defined for the nested XML option, we wanted
% to treat options just like other received data, and use the XML to Java
% mapping facility of the classes. 

% Thirdly, we need to raise lifecycle event notifications with
% callers. In the absence of a single, stable notification protocol, we
% chose to allow services to support multiple mechanism (again, each
% defined by arbitrary inline XML).



