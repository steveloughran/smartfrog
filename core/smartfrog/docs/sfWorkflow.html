<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>SmartFrog WorkFlow</title>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="breadtrail">
<script src="skin/breadcrumbs.js" language="JavaScript" type="text/javascript"></script>
</div>
<div class="header">
<div class="grouplogo">
<a href="http://www.SmartFrog.org/"><img class="logoImage" alt="SmartFrog" src="images/group.png" title="SmartFrog"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.SmartFrog.org"><img class="logoImage" alt="" src="images/frog.gif"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="index.html">Home</a>
</li>
<li>
<a class="base-not-selected" href="sfcore.html">SmartFrog Core</a>
</li>
<li>
<a class="base-not-selected" href="comp.html">Components</a>
</li>
<li>
<a class="base-not-selected" href="anttasks.html">Ant Tasks</a>
</li>
<li>
<a class="base-not-selected" href="extras.html">Extras</a>
</li>
<li>
<a class="base-not-selected" href="examples.html">Examples</a>
</li>
<li>
<a class="base-not-selected" href="jdocs_index.html">Java Docs</a>
</li>
<li>
<a class="base-not-selected" href="Copyright.html">Copyright</a>
</li>
<li>
<a class="base-not-selected" href="lpgl.html">License Terms</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="content">
<h1>SmartFrog WorkFlow</h1>
<div class="abstract"></div>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#SmartFrog+WorkFlow">SmartFrog WorkFlow</a>
</li>
</ul>
</div>
<a name="N1000C"></a><a name="SmartFrog+WorkFlow"></a>
<h2 class="boxed">SmartFrog WorkFlow</h2>
<div class="section">
<p class="P3"></p>
<p class="P3">DRAFT</p>
<p class="Standard"></p>
<p class="P4">
<a class="external" href="http://www.smartfrog.org/">http://www.smartfrog.org</a>
</p>
<p class="P4"></p>
<p class="P4">HP Laboratories, Bristol</p>
<p class="P4">Last revision: 2005-07-21</p>
<p class="P4"></p>
<p class="P8"></p>
<p class="Heading 2">Introduction</p>
<p class="Standard">This document shows how the SmartFrog system has been extended to become a simple and lightweight workflow-like system (known as SmartFlow) for carrying out complex tasks requiring distributed actions on clusters of machines, and where ordering, recovery from failure, etc. are important features.</p>
<p class="Standard"></p>
<p class="Standard">The system is very much in its infancy and largely experimental, so the constructs provided here may be inadequate in some significant ways. However, as new components or variants of semantics are identified, these can easily be programmed and added to the SmartFlow system. At a few points in the document, issues and problems with the workflow framework are highlighted. If others are identified or additional functionality desired, please inform the SmartFrog team.</p>
<p class="Standard"></p>
<p class="Standard">The SmartFlow system provide some of the core features for distributed scripting of synchronized actions, as required by a workflow system. Some key components for a full-blown system are missing &ndash; such as transactions and persistence - but concepts such as parallel and sequential composition of distributed tasks are provided.</p>
<p class="Standard"></p>
<p class="Standard">The document covers a number of aspects:</p>
<ol>
<li>
<p class="P9">How SmartFrog is a suitable framework for such as system.</p>
</li>
<li>
<p class="P9">The features that should be provided.</p>
</li>
<li>
<p class="P9">The design of the SmartFlow system itself and details of its components.</p>
</li>
<li>
<p class="P9">An example showing some of the features in action. This example is supplied with the distribution of the system.</p>
</li>
</ol>
<p class="Standard">The document assumes that the reader has a good understanding of the SmartFrog system.</p>
<p class="Heading 2">Core SmartFrog Concepts</p>
<p class="Standard">SmartFrog is a notation and supporting infrastructure for the development of components for instantiation on potentially remote processors. The current SmartFrog supports two kinds of component &ndash; the <span class="T1">Primitive</span> component (which is the user-defined components that carry out some activity for the system), and the <span class="T1">Compound</span> component which is a grouping of other components, be they compound or primitive. The sub-components may be started on whichever set of processors of a cluster they needs to be started &ndash; this association between component and processor being an attribute of the component itself. Each sub-component may be on a different processor if necessary.</p>
<p class="Standard"></p>
<p class="Standard">The core semantics of compound are that </p>
<ul>
<li>
<p class="P10">on creation, its sub-components are also created</p>
</li>
<li>
<p class="P10">if any of the sub-components terminate, so does it</p>
</li>
</ul>
<ul>
<li>
<p class="P11">and similarly for a number of lifecycle stages</p>
</li>
</ul>
<p class="P12">This semantics makes sense if we are trying to define a notion of an atomic collection &ndash; all of which is in the same state (created, idle, running, terminated, etc.). This must be extended if we are to have the concept of sequential creation of components, for example.</p>
<p class="P12"></p>
<p class="P12">Fortunately, SmartFrog is a framework &ndash; it has been designed to allow further types of component to be defined and incorporated into the system. In particular it is possible to introduce new types of collections of sub-components with varying semantics suiting different target systems. Thus this document described a number of new component types that allow the definition of workflow-style applications. This is done without in any way modifying the SmartFrog notation or system, merely introducing some new classes of component in a way the framework already enables.</p>
<p class="P12"></p>
<p class="P13">Workflow</p>
<p class="P12"></p>
<p class="P12">Consider the following system management task. There is a cluster of machines, each running a version of a daemon. The system manager needs to update the version of this daemon on all machines, or if he fails he must rollback to the previous version. The system manager must carry out the following sequential steps:</p>
<ul>
<li>
<p class="P14">save a copy of the old software, and old daemon configuration on each machine;</p>
</li>
</ul>
<ul>
<li>
<p class="P15">download the new software to each machine; </p>
</li>
<li>
<p class="P15">restart all the daemons;</p>
</li>
<li>
<p class="P15">if any failure occurs &ndash; replace the old software and if necessary restart the old daemon.</p>
</li>
</ul>
<p class="Standard">The identical actions on the separate machines may all be done in parallel, whilst the individual steps must be done sequentially &ndash; completing each before moving to the next. It is this combination of sequenced and parallel activities that is termed, for the purposes of this document, a <span class="T1">workflow</span>.</p>
<p class="Standard"></p>
<p class="Standard">It is clear from the example that there are several features that make SmartFrog a suitable framework for progress</p>
<ul>
<li>
<p class="P16">there is the notion of component, specific ones may be provided to carry out a specific task such as moving files, restarting a daemon, etc.;</p>
</li>
</ul>
<ul>
<li>
<p class="P17">there is the notion of composition (though with different semantics to Compound);</p>
</li>
<li>
<p class="P17">there is the notion of remote creation of components on remote machines.</p>
</li>
</ul>
<p class="Standard">Thus if we can define a new set of composite components, such as sequence, parallel, etc. we can create workflows of primitive or compound components to achieve complex configuration procedures.</p>
<p class="Heading 2">Event Framework</p>
<p class="Standard">SmartFlow requires the provision of an event framework. The framework is a very simple distribution mechanism for events that hides from the components from where events are to be received or who are to receive any events they generate. The framework is slightly misleadingly called an event bus as though it differs significantly from the more traditional meanings of the term. </p>
<p class="Standard"></p>
<p class="Standard">The SmartFlow event framework consists of a graph of component nodes and event forwarding arcs. Events are passed between components along the arcs of this graph, potentially along multiple paths, until they reach their end-points. At any intermediate point, a component may chose to act on the event or to ignore it acting merely as an event forwarder.</p>
<p class="Standard"></p>
<p class="Standard">There are a number of new interfaces associated with the event framework.</p>
<ol>
<li>
<p class="WW-List Bullet 2">
<span class="T2">EventBus</span> &ndash; the public interface used by components that defines the template and API methods for components using events.</p>
</li>
<li>
<p class="WW-List Bullet 2">
<span class="T2">EventRegistration</span> &ndash; an internal interface provided for use by the SmartFlow system for carrying out registrations for event forwarding.</p>
</li>
<li>
<p class="WW-List Bullet 2">
<span class="T2">EventSink</span> &ndash; an internal interface provided for use by the SmartFlow system for forwarding events from one component to another.</p>
</li>
</ol>
<p class="P18"></p>
<p class="Standard">The <span class="T3">EventBus</span> interface is the only one that needs further explanation. The interface is implemented by two new Java classes, <span class="T3">EventPrimImpl</span> and <span class="T3">EventCompoundImpl</span>, and these may be used in place of <span class="T3">PrimImpl</span> and <span class="T3">CompoundImpl</span> if a component needs to be part of the event framework. </p>
<p class="Standard"></p>
<p class="Standard">The <span class="T3">EventBus</span> interface provides two methods:</p>
<p class="Standard"></p>
<p class="Code">void handleEvent(Object event)</p>
<p class="Code">void sendEvent(Object event)</p>
<p class="Code"></p>
<p class="Standard">The first of these is a template method; i.e. one that is pre-defined with a default action (ignore the event) but is available for the component to overwrite if some action is desired. It is called whenever an event arrives at the component. Note that this method is called in addition to forwarding the event to all registered components.</p>
<p class="Standard"></p>
<p class="Standard">The second, <span class="T3">sendEvent</span>, is an API method and should be called by the component whenever it wishes to send an event into the system.</p>
<p class="Standard"></p>
<p class="Standard">Events are serializable objects. They may have structure beyond that, in that the objects may be used by a receiving component, and pattern-matched to extract internal structure. However, the event framework is unaware of this structure and does no filtering. </p>
<p class="Standard"></p>
<p class="Standard">Forwarding relationships are defined in the SmartFrog descriptions, using links, and the <span class="T3">EventPrims</span> and <span class="T3">EventCompounds</span> automatically set up the forwarding graph. The key to defining this graph is the definitions of the <span class="T3">EventPrim</span> and <span class="T3">EventCompound</span> component descriptions. These are:</p>
<p class="P19"></p>
<p class="Code">EventPrim extends Prim {</p>
<p class="Code">sfClass "org.smartfrog.sfcore.workflow.eventbus.EventPrimImpl";</p>
<p class="Code">sendTo extends LAZY {}</p>
<p class="Code">registerWith extends LAZY {}</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">EventCompound extends Compound {</p>
<p class="Code">sfClass "org.smartfrog.sfcore.workflow.eventbus.EventCompoundImpl";</p>
<p class="Code">sendTo extends LAZY {}</p>
<p class="Code">registerWith extends LAZY {}</p>
<p class="Code">}</p>
<p class="Standard"></p>
<p class="Standard">As can be seen, they both have <span class="T4">sendTo</span> and <span class="T4">registerWith</span> LAZY components. These may contain LAZY links to other components that implement the event framework and define the graph of event forwarding. Note that the registration can be done in both directions, i.e. deciding which components a component wishes to receive from or the other way around. This provides a great deal of flexibility in providing the configuration for the event-forwarding graph.</p>
<p class="Standard"></p>
<p class="Standard">Every SmartFlow component implements the event framework and may therefore be used to forward events around the system. An example of the use of events is given in the worked example at the end of the document.</p>
<p class="Standard"></p>
<p class="Standard">Note: The event framework is a first pass at the concept, and is not without its problems. In particular, it is sometimes hard to find out how to synchronize parts of the workflow because inevitably there is a race condition between the event being generated (say the creation of a <span class="T3">SendEvent</span>, see below) in one sequence and the creation of the interested component (for example the creation of an <span class="T3">OnEvent</span>, see below) in another sequence. Events are transient, so if the event is generated before the registration of interest, it is lost forever. This will be fixed in the next release of the framework &ndash; a number of solutions are being evaluated. </p>
<p class="Standard"></p>
<p class="Standard">Currently the solution lies in providing top-level receivers for events, created before the generation, that act as schedulers for the rest of the workflow; these must currently be provided by the user. This concept is one of the generalised solutions to the problem being investigated, as is caching events within the system for forwarding to interested components as registrations occur.</p>
<p class="Heading 2">SmartFlow</p>
<p class="Standard"></p>
<p class="Standard">The primary purpose of this section is to define the various components that may be used for creating workflows. This will be done in two parts &ndash; first showing the overall list of components provided to get a feel for the scope of SmartFlow, the second describing in detail how these are used.</p>
<p class="Heading 3">The List of Components</p>
<p class="Standard"></p>
<ol>
<li>
<p class="P20">
<span class="T2">Parallel</span> &ndash; to provide the simultaneous execution of multiple sub-components. The parallel component only terminates when all sub-components independently terminate.</p>
</li>
<li>
<p class="P20">
<span class="T2">Sequence</span> &ndash; starts the sub-components one at a time, starting the next when the previous one terminates.</p>
</li>
<li>
<p class="P20">
<span class="T2">Timeout</span> &ndash; waits a certain period for the completion of its sub-component, if not terminated in that time &ndash; fails itself and its sub-component. Early termination propagates the sub-components failure mode.</p>
</li>
<li>
<p class="P20">
<span class="T2">During</span> &ndash; waits for a certain period of time after which it terminates its sub-component if not already terminated &ndash; terminates itself normally at that point. Early termination propagates the sub-components failure mode.</p>
</li>
<li>
<p class="P20">
<span class="T2">Retry</span> &ndash; tries to execute its sub-component, if it fails, tries again and so on for some maximum number of retries with some time-delay between retries.</p>
</li>
<li>
<p class="P20">
<span class="T2">Repeat</span> &ndash; executes its sub-component. If the sub-component terminates normally, repeats this a given number of times.</p>
</li>
<li>
<p class="P20">
<span class="T2">Try</span> &ndash; tries to carry out its primary sub-component. When it terminates it will invoke the appropriate sub-component indexed by termination code. Its normal use is for rollback after failure, with the ability to invoke some further action even after normal termination such as issuing a notification of success.</p>
</li>
<li>
<p class="P20">
<span class="T2">Delay</span> &ndash; wait for a period and then proceed with its sub-component. Termination of the delay component is the same as that for its sub-component.</p>
</li>
</ol>
<p class="P21"></p>
<p class="P21">In addition to these scripting components, there are others required for starting and stopping other applications as part of the workflow process. For this there are two components provided:</p>
<p class="P21"></p>
<ol>
<li>
<p class="P22">
<span class="T2">Run</span> &ndash; starts its sub-components as independent agents, then terminates normally, not remaining the &lsquo;parent&rsquo; composite component for the subcomponents. It is used for launching long-term services, using the workflow part to ensure the appropriate conditions have been achieved, and that the agents are started in the right order.</p>
</li>
<li>
<p class="P22">
<span class="T2">Terminator </span>&ndash; given a reference to an application, call sfTerminate upon it with an appropriate termination type, then terminate self.</p>
</li>
<li>
<p class="P22">
<span class="T2">Attribute </span>&ndash; given a reference to an component, and the name of an attribute within it, add, replace or remove that attribute as appropriate.</p>
</li>
</ol>
<p class="P21"></p>
<p class="P21">These composites allow the construction of complex sequencing and interleaving of actions, however this is not enough on its own. There will in general be the need to synchronise components from different parts of the workflow. This can be done using the event framework (modulo the issues described above).</p>
<p class="P21"></p>
<p class="P21">To simplify the use of the event framework and synchronize the various parts of the workflow, a number of components are provided:</p>
<p class="P21"></p>
<ol>
<li>
<p class="P23">
<span class="T2">OnEvent</span> &ndash; a compound component that registers with the event framework (if necessary), waits for an event and dispatches an appropriate sub-components according to event structure. </p>
</li>
<li>
<p class="P23">
<span class="T2">EventSend</span> &ndash; a primitive component to send a specific event to the event framework, perhaps to a waiting EventCounter or OnEvent, and terminates. Typically it is used in a sequence to signal progress to a parallel sequence.</p>
</li>
<li>
<p class="P23">
<span class="T2">EventCounter</span> - a dual of EventSend is the EventCounter, a component that counts the events it receives and when it reaches a trigger level, terminates. It can be used in a sequence to pause until some other tasks have been completed.</p>
</li>
<li>
<p class="P24">EventQueue<span class="T5"> &ndash;</span><span class="T6"> a buffer of events, forwarding all the events it has received to any component that registers &ndash; even if this is after the event has been received. This allows for the synchronization of seperate sequences of actions.</span>
</p>
</li>
</ol>
<p class="P21"></p>
<p class="P21">Finally, a do-nothing component is required, if only as commentary or for test purposes.</p>
<p class="P21"></p>
<ol>
<li>
<p class="P25">
<span class="T2">DoNothing</span> does more-or-less absolutely nothing for a period and terminates in a way defined by its description. Also provides event reciept and message printing, so is very useful for debugging and tracing of workflows,</p>
</li>
</ol>
<p class="P21"></p>
<p class="P26">Detailed Description of Components</p>
<p class="P21"></p>
<p class="P21">The components will now each be described in detail, in roughly reverse order of grouping. They all have some similarity in that</p>
<ul>
<li>
<p class="P27">they all leave the lifecycle of the defined templates until their own <span class="T3">sfStart</span> phase, at this point they choose the necessary templates (defined as LAZY component descriptions) and create, initialise and start the cub-component.</p>
</li>
<li>
<p class="P27">all (but <span class="T3">Parallel</span> and <span class="T3">Sequence</span>) use the template defined in the attribute <span class="T3">action</span> to determine the initial sub-component that must be created</p>
</li>
<li>
<p class="P27">Parallel steps all the templates synchronously through their lifecycle unless otherwise specified with the attribute &ldquo;asynchCreateChild&rdquo;, Sequence only steps the first. </p>
</li>
<li>
<p class="P27">
<span class="T3">Parallel</span> names its children after the names they had in the component description, this is because more than one runs at a time, and so a single name is insufficient.</p>
</li>
</ul>
<p class="P28">DoNothing</p>
<p class="P21"></p>
<p class="P29">DoNothing extends EventPrim {</p>
<p class="P29">sfClass "org.smartfrog.sfcore.workflow.components.DoNothing";</p>
<p class="P29">time 10000000; // time in milliseconds to wait</p>
<p class="P29">terminationType "normal"; // termination record type</p>
<p class="P29">printEvents false;</p>
<p class="P29">// message "a message to print on the console prefixed by full name"</p>
<p class="P29">}</p>
<p class="P21"></p>
<p class="P21">The <span class="code-inline">DoNothing</span> construct does nothing for a time, then terminates as required. Its purpose is primarily to act as a stub for bits of workflow yet to be written during testing. If <span class="T3">terminationType</span> is set to <span class="T3">&rdquo;none&rdquo;</span>, it waits for ever.</p>
<p class="P21"></p>
<p class="P21">The component prints the message to stdout and starts the timer during its start phase and terminates when the timer has fired. If the time is 0, the component will terminate immediately &ndash; though a thread is started to do this so some asynchrony occurs. If no message is provided, no message is printed.</p>
<p class="P21"></p>
<p class="P21">If the attribute <span class="T3">printEvents</span> is set to <span class="T3">true</span>, any events that it receives will be printed on the console. If <span class="T3">printEvents</span> is <span class="T3">false</span>, it does nothing internal with events, merely forwarding them as required.</p>
<p class="P21"></p>
<p class="P28">EventSend</p>
<p class="P21"></p>
<p class="P29"></p>
<p class="P29">EventSend extends EventPrim {</p>
<p class="P29">sfClass "org.smartfrog.sfcore.workflow.components.EventSend";</p>
<p class="P29">// event "the string to send as an event"; </p>
<p class="P29">}</p>
<p class="P21"></p>
<p class="P21">An event sender contains an event to send, and it forwards the event to any registered components as defined in the event framework.</p>
<p class="P21"></p>
<p class="P21">The component sends its event during the start phase, and then terminates asynchronously. It does nothing internal with received events.</p>
<p class="P28">EventCounter</p>
<p class="P21"></p>
<p class="P29">EventCounter extends EventPrim {</p>
<p class="P29">sfClass "org.smartfrog.sfcore.workflow.components.EventCounter";</p>
<p class="P29">count 1;</p>
<p class="P29">allDifferent "true";</p>
<p class="P29">}</p>
<p class="P21"></p>
<p class="P21">Event counter waist for events, when they arrive it decrements its counter (default 1). When the counter reaches 0, the component terminates. If the attribute <span class="code-inline">allDifferent</span> is set to <span class="code-inline">true</span>, the counter is not decremented if the event it receives is an identical string.</p>
<p class="P28">OnEvent</p>
<p class="P21"></p>
<p class="P29">OnEvent extends EventCompound {</p>
<p class="P29">sfClass "org.smartfrog.sfcore.workflow.components.OnEvent";</p>
<p class="P29">singleEvent true;</p>
<p class="P29">//event1 extends LAZY ... { ... }</p>
<p class="P29">//event2 extends LAZY ... { ... }</p>
<p class="P29">//otherwise extends LAZY ... { ... }</p>
<p class="P29">}</p>
<p class="P21"></p>
<p class="P21">The OnEvent event dispatcher provides a number of named event handlers as attributes &ndash; defined as LAZY components. When an event arrives, it is compared to the names of the attributes using Java string equality, and if a matching attribute is found the component description is taken and deployed. If no match is found, the <span class="T3">otherwise</span> template is taken. </p>
<p class="P21"></p>
<p class="P21">The component has two modes, defined by the <span class="code-inline">singleEvent</span> attribute. If this is <span class="code-inline">true</span>, only the first event that arrives is dispatched, and on termination of the associated action, the <span class="code-inline">OnEvent</span> component terminates. If the <span class="code-inline">singleEvent</span> attribute is <span class="code-inline">false</span>, the <span class="code-inline">onEvent</span> component dispatches an action for each event that it receives until it is terminated by another component or the dispatched event action.</p>
<p class="P21"></p>
<p class="P21">If an event arrives for which there is no handler the event is simply ignored.</p>
<p class="P21"></p>
<p class="P21">Once a handler has been started, it runs as the newly created sub-component as a child using the name of the event handler post-fixed by a unique index. When that child terminates, so does the <span class="code-inline">OnEvent</span> if it is in single event mode, with the same termination type.</p>
<p class="P28">EventQueue</p>
<p class="P21"></p>
<p class="P29">EventQueue extends EventPrim {</p>
<p class="P29">sfClass "org.smartfrog.sfcore.workflow.components.EventQueue";</p>
<p class="P29">}</p>
<p class="Standard"></p>
<p class="Standard">The <span class="code-inline">EventQueue</span> component forwards events to registered components as all other workflow components do. However, there are two additional differences:</p>
<ol>
<li>
<p class="P30">The events are stored and any future registrations will receive all the events in the order in which they arrived at the <span class="code-inline">EventQueue</span>, not only new ones. This makes the <span class="code-inline">EventQueue</span> a suitable component to provide the synchronization point between two sequences where one cannot be certain that the event receiver will be ready (or exist) before the sender is required to send the synchronization event.</p>
</li>
<li>
<p class="P30">The event forwarding is asynchronous. In other words, the thread that delivers the event to the Queue returns before the events are necessarily forwarded. This is not so of the default event forwarding which is synchronous. Thus an <span class="code-inline">EventQueue</span> can be used wherever it is required to provide that level of asynchrony.</p>
</li>
</ol>
<p class="P28">Run</p>
<p class="P21"></p>
<p class="P29">Run extends EventCompound {</p>
<p class="P29">sfClass "org.smartfrog.sfcore.workflow.combinators.Run";</p>
<p class="P29">// action extends LAZY ...;</p>
<p class="P29">// parent ref to optional parent compound</p>
<p class="P29">// asName a string to be the name in the parent compound</p>
<p class="P29">}</p>
<p class="P21"></p>
<p class="P21">
<span class="code-inline">Run</span> is a component that, during its start phase locates the action attribute &ndash; which must be a component description provided as a <span class="code-inline">LAZY</span> component &ndash; and deploys it as a separately running application. Once this is done, the run component terminates asynchronously. It fails if the application has not been started correctly. </p>
<p class="P21"></p>
<p class="P21">The launched application would normally name itself on some host so that it may later be found &ndash; normally using the <span class="code-inline">sfProcessComponentName</span> attribute.</p>
<p class="P21"></p>
<p class="P21">Alternatively, it is possible to provide a link to a parent compound and the name the component should have in that compound. This is done using the attributes parent and asName as defined in the prototype above.</p>
<p class="P28">Terminator</p>
<p class="P31"></p>
<p class="P32">Terminator extends EventPrim {</p>
<p class="P32">sfClass "org.smartfrog.sfcore.workflow.components.Terminator";</p>
<p class="P32">// kill LAZY RefToComdemnedComponent;</p>
<p class="P32">type "normal";</p>
<p class="P32">description "terminator action";</p>
<p class="P32">detachFirst false;</p>
<p class="P32">}</p>
<p class="P21"></p>
<p class="P21">
<span class="code-inline">Terminator</span> is a component that, during its start phase, de-references its kill attribute to find a component (it is an error if it does not do so). It then constructs a termination record from the type and description attributes and invokes the <span class="code-inline">sfTerminate</span> method on the referenced component.</p>
<p class="P21"></p>
<p class="P21">Frequently, the reference will be a host reference, followed by the application name as set by the application&rsquo;s top-level <span class="code-inline">sfProcessComponentName</span> attribute.</p>
<p class="P21"></p>
<p class="P21">If the component is a sub-component of a compound that should not be terminated, the component may first be detached. This is done by setting the <span class="code-inline">detachFirst</span> attribute to <span class="code-inline">true</span>.</p>
<p class="P21"></p>
<p class="P28">Attribute</p>
<p class="P33"></p>
<p class="P33"></p>
<p class="P34">Attribute extends EventPrim {</p>
<p class="P34">sfClass "org.smartfrog.sfcore.workflow.components.Attribute";</p>
<p class="P34">/*</p>
<p class="P34">component RefToComponent;</p>
<p class="P34">name &ldquo;a string&rdquo;;</p>
<p class="P34">value newValue; // not present implies remove...</p>
<p class="P34">*/</p>
<p class="P34">}</p>
<p class="P33"></p>
<p class="P21">Attribute replaces, removes or adds an attribute of a primitive or compound component as defined by the attributes provided. The component is a reference to the component containing the compound. The name indicates the name of the attribute in that component. The value, if present, determines the value this attribute should take, or if absent defines that the attribute should be removed.</p>
<p class="P28">Parallel</p>
<p class="P21"></p>
<p class="P29">Parallel extends EventCompound {</p>
<p class="P29">sfClass "org.smartfrog.sfcore.workflow.combinators.Parallel";</p>
<p class="P29">//asynchCreateChild false;</p>
<p class="P29">}</p>
<p class="P21"></p>
<p class="P21">
<span class="code-inline">Parallel</span> is the closest SmartFlow comes to the standard <span class="code-inline">Compound</span>. It differs in a number of ways.</p>
<p class="P21"></p>
<p class="P21">Firstly, to conform to the structure and lifecycle of all the other SmartFlow components, no sub-component is automatically created.</p>
<p class="P21"></p>
<p class="P21">Secondly, the sub-components are only created, initialised and started during the <span class="T4">sfStart</span> phase of the parallel, rather than during its equivalent phase. Again, this is to conform to the general structure of SmartFlow. The components are deployed and started sequentially unless otherwise specified using the configuration attribute &ldquo;asynchCreateChild&rdquo;, it the value of this attribute is true then the deploy and start of every subcomponent is done in independent threads.</p>
<p class="P21"></p>
<p class="P21">Thirdly, the parallel waits until each of the sub-components terminates before terminating itself. This is true, at least, for normal termination. Any abnormal termination is considered fatal and the whole parallel and its remaining sub-components will be terminated. This is also true of any forced termination by a non-child component.</p>
<p class="P21"></p>
<p class="P21">Note that the parallel components when asynchCreateChild is false have their lifecycle phased with respect with each other, so during their initialisation they may reference each other, locate each other, and so on. Note also, that once created they sub-components are children of the <span class="code-inline">Parallel</span> component itself. </p>
<p class="P28">Sequence</p>
<p class="P31"></p>
<p class="P32">Sequence extends EventCompound {</p>
<p class="P32">sfClass "org.smartfrog.sfcore.workflow.combinators.Sequence";</p>
<p class="P32">}</p>
<p class="P35"></p>
<p class="Standard">A <span class="code-inline">Sequence</span> takes each sub-component through its entire lifecycle, one at a time. As the first terminates, the second is created and starts. The templates for these components are are created, initialised and started in the order given in the component description.</p>
<p class="Standard"></p>
<p class="Standard">The first component is created, initialised and started during the <span class="T3">sfStart</span> of the sequence. It is then left to run to completion, at which point the next template is taken and a component created and started. This continues until one of the components terminates abnormally or all the components have completed their lifecycles.</p>
<p class="Heading 4">During</p>
<p class="Standard"></p>
<p class="Code">During extends EventCompound {</p>
<p class="Code">sfClass "org.smartfrog.sfcore.workflow.combinators.During";</p>
<p class="Code">// action extends LAZY &hellip;</p>
<p class="Code">time 0; // time in milliseconds</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Standard">
<span class="T3">During</span> runs a sub-component for a period of time and, if it has not terminated in that period, terminates it and itself normally. The sub-component to launch is defined by the <span class="T3">action</span> component description that must be a <span class="code-inline">LAZY</span> description. It is created and started in the <span class="T3">sfStart</span> phase of <span class="T3">During</span>. The default time is <span class="code-inline">0</span>, indicating that it should terminate immediately. The time is given in milliseconds.</p>
<p class="Standard"></p>
<p class="Standard">Note that the sub-component, when it is created, is known as <span class="T3">running</span>.</p>
<p class="Heading 4">Timeout</p>
<p class="Standard"></p>
<p class="Code">Timeout extends EventCompound {</p>
<p class="Code">sfClass "org.smartfrog.sfcore.workflow.combinators.Timeout";</p>
<p class="Code">// action extends LAZY &hellip;</p>
<p class="Code">time 0;</p>
<p class="Code">}</p>
<p class="P19"></p>
<p class="Standard">
<span class="T4">Timeout</span> runs a sub-component for a period of time and, if it has not terminated in that period, terminates it and itself abnormally. The sub-component to launch is defined by the <span class="T4">action</span> component description that must be a LAZY description. It is created and started in the <span class="T4">sfStart</span> phase of <span class="T4">Timeout</span>. The default time is 0, indicating that it should terminate immediately. The time is given in milliseconds.</p>
<p class="Standard"></p>
<p class="Standard">Note that the sub-component, when it is created, is known as <span class="T4">running</span>.</p>
<p class="Heading 4">Delay</p>
<p class="P36"></p>
<p class="P37">Delay extends EventCompound {</p>
<p class="P37">sfClass "org.smartfrog.sfcore.workflow.combinators.Delay";</p>
<p class="P37">// action extends LAZY &hellip;</p>
<p class="P37">time 0;</p>
<p class="P37">}</p>
<p class="Standard">
<span class="T3">Delay</span> starts a thread during its <span class="T3">sfStart</span> phase that delays a period of time, then creates a sub-component as a child of <span class="T3">Delay</span>. This child has the name <span class="T3">running</span>. <span class="code-inline">Delay</span> terminates when the child terminates with the same termination type. The default time is 0 and is given in milliseconds.</p>
<p class="Heading 4">Retry</p>
<p class="Standard"></p>
<p class="Code">Retry extends EventCompound {</p>
<p class="Code">sfClass "org.smartfrog.sfcore.workflow.combinators.Retry";</p>
<p class="Code">// action extends LAZY &hellip;</p>
<p class="Code">retry 1;</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Standard">
<span class="T3">Retry</span> creates and starts a sub-component during its <span class="code-inline">sfStart</span> phase, as defined by the <span class="T3">action</span> template, and waits for its termination. Whilst it is running, the child sub-component has the name <span class="T3">running</span>. If it terminates normally, so does <span class="T3">Retry</span>. If it terminates abnormally, <span class="T3">Retry</span> will start another instance of the action template, again called <span class="T3">running</span>. This continues until either the child terminates normally, or the specified number of retries is exhausted. The default number of retries is one.</p>
<p class="Heading 4">Repeat</p>
<p class="Standard"></p>
<p class="Code">Repeat extends EventCompound {</p>
<p class="Code">sfClass "org.smartfrog.sfcore.workflow.combinators.Repeat";</p>
<p class="Code">// action extends LAZY &hellip;</p>
<p class="Code">repeat 1;</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Standard">
<span class="T3">Repeat</span> creates and starts a sub-component during its sfStart phase, as defined by the <span class="T4">action</span> template, and waits for its termination. Whilst it is running, the child sub-component has the name <span class="T4">running</span>. If it terminates abnormally, so does <span class="T4">Repeat</span>. If it terminates normally, <span class="T4">Repeat</span> will start another instance of the action template, again called <span class="T3">running</span>. This continues until either the child terminates abnormally, or the specified number of repeats is exhausted. The default number of repetitions is one.</p>
<p class="Heading 4">Try</p>
<p class="Standard"></p>
<p class="Standard"></p>
<p class="Code">Try extends EventCompound {</p>
<p class="Code">sfClass "org.smartfrog.sfcore.workflow.combinators.Try";</p>
<p class="Code">// action extends LAZY &hellip;</p>
<p class="Code">// normal extends LAZY &hellip;</p>
<p class="Code">// abnormal extends LAZY &hellip;</p>
<p class="Code">// etc</p>
<p class="Code">}</p>
<p class="P38"></p>
<p class="Standard">
<span class="T3">Try</span> creates and starts a sub-component during its <span class="T3">sfStart</span> phase, as defined by the <span class="T3">action</span> template, and waits for termination. The running child has the name <span class="T3">running</span>. When termination occurs, the termination type is examined and <span class="T4">Try</span> finds an attribute whose name is the same as the termination type. If it does so, it creates and starts a sub-component as defined by the template attribute. If it does not have a continuation, <span class="T3">Try</span> terminates by propagating the termination of the initial child component. When the continuation component terminates, <span class="T3">Try</span> does so as well by propagating the termination.</p>
<p class="Heading 2">References</p>
<p class="Standard">As the component tree of a SmartFlow hierarchy is built during the <span class="code-inline">sfStart</span> phase, or afterwards triggered by the termination of a component or the arrival of an event, most components will not be available all the time. Indeed, some components will never be created.</p>
<p class="Standard"></p>
<p class="Standard">Consequently, assumptions that are usually made about the existence of components during initialisation are no longer valid. In some cases, the components may well be &ndash; for example in each branch of a <span class="code-inline">Parallel</span>. However, the general rule certainly does not apply.</p>
<p class="Standard"></p>
<p class="Standard">The trick is in general only to use references that go up the tree &ndash; these are always valid. Those referencing down the tree may not be valid, detailed knowledge of the lifecycle is important when using these.</p>
<p class="Standard"></p>
<p class="Standard">Note also, that the majority of sub-components created by the various components are called &ldquo;<span class="code-inline">running</span>&rdquo; within the parent. The main exception to this is the <span class="code-inline">Parallel</span>, where the children are known by the appropriate names within the <span class="T4">actions</span> component description, but are instantiated as direct children of the <span class="code-inline">Parallel</span> component.</p>
<p class="Heading 2">Termination</p>
<p class="Standard">Since SmartFlow is designed to carry out a series of tasks, each more or less short-lived, it is tempting to place the entire logic of the component to carry out a task in the <span class="T3">sfStart</span> method. This is in general OK, however termination of the component may not be directly initiated from inside the <span class="T3">sfStart</span> method, i.e. <span class="T3">sfTerminate</span> may not be called in <span class="T3">sfStart</span> as it blocks under certain circumstances.</p>
<p class="Standard"></p>
<p class="Standard">Consequently, if termination is required at the end of the <span class="code-inline">sfStart</span> method, add the following snippet of code to trigger asynchronous termination or use the TerminatorThread (org.smartfrog.common.TerminatorThread).</p>
<p class="Standard"></p>
<p class="Code">Runnable terminator = new Runnable() {</p>
<p class="Code">public void run() {</p>
<p class="Code">sfTerminate(term);</p>
<p class="Code">}</p>
<p class="Code">};</p>
<p class="Code">new Thread(terminator).start();</p>
<p class="Standard"></p>
<p class="Standard">This starts a new thread to trigger termination, allowing the <span class="code-inline">sfStart</span> method to complete normally.</p>
<p class="Standard"></p>
<p class="Standard">It is likely the future versions of SmartFrog will provide components that are better suited to SmartFlow, but for now the underlying system assumes that termination is always triggered asynchronously.</p>
<p class="Heading 2">Example</p>
<p class="Standard"></p>
<p class="Standard">There is a simple example of the use of the SmartFlow system provided with the distribution &ndash; contained in package <span class="T3">org.smartfrog.examples.workflow</span>. This example is listed here with little addition commentary.</p>
<p class="Standard"></p>
<p class="Standard">The example is of running a number of applications for a short time period on a set of hosts. Each application consists of two parts, a web server and an application server. Before these applications can be run, some preparatory actions must be taken &ndash; downloading some files &ndash; and on termination, this must be undone to clean up.</p>
<p class="Standard"></p>
<p class="Standard">Note that the application is not real in that all the actions are stubs, simply printing their intended behaviour to the console of the daemon in which they are running.</p>
<p class="Standard"></p>
<p class="Standard">The example is divided into four files, building from the bottom up.</p>
<ul>
<li>
<p class="WW-List Bullet">
<span class="code-inline">base.sf</span> contains the basic building blocks for the application</p>
</li>
<li>
<p class="WW-List Bullet">
<span class="code-inline">application.sf</span> uses these to define the notion of an application as having a preparatory phase, and action, and a clean-up phase. Two application are defined &ndash; the web server and the application server.</p>
</li>
<li>
<p class="WW-List Bullet">
<span class="code-inline">node.sf </span>defines what should run on a particular node &ndash; namely a web server and application server. It also defines the notion of a reliable node, one that retries the applications for a number of times until successful</p>
</li>
<li>
<p class="WW-List Bullet">
<span class="code-inline">system.sf</span> contains the final system, with five hosts, and their mappings to the different physical servers for execution.</p>
</li>
</ul>
<p class="Standard">To make the example more interesting, in addition to a well-behaved application, one instance of the application has an additional component added which deliberately kills it, thus causing the reliability features to kick-in.</p>
<p class="Standard"></p>
<p class="Heading 4">File base.sf:</p>
<p class="P39"></p>
<p class="Code">#include "org/smartfrog/components.sf";</p>
<p class="Code">#include "org/smartfrog/functions.sf";</p>
<p class="Code">#include "org/smartfrog/sfcore/workflow/components.sf";</p>
<p class="Code">#include "org/smartfrog/services/scripting/components.sf";</p>
<p class="Code"></p>
<p class="Code"></p>
<p class="Code">/*</p>
<p class="Code">* Simulate a number of basic actions - such as </p>
<p class="Code">* copying and removing files</p>
<p class="Code">* running daemons</p>
<p class="Code">*</p>
<p class="Code">* These are simulated (view them as testing stubs for the overall logic)</p>
<p class="Code">* using the DoNothing component and the scripting capability.</p>
<p class="Code">*/</p>
<p class="Code"></p>
<p class="Code"></p>
<p class="Code"></p>
<p class="Code">/* The copyfile component is given a URL of a file,</p>
<p class="Code">* and the name of the file to create,</p>
<p class="Code">* issues a message stating that the file has been</p>
<p class="Code">* copied, delays a couple of seconds, and terminates.</p>
<p class="Code">*/</p>
<p class="Code"></p>
<p class="Code">Copyfile extends DoNothing {</p>
<p class="Code">time 2000;</p>
<p class="Code"></p>
<p class="Code">//default URL to copy to file</p>
<p class="Code">fromURL "http://defaultHost/defaultFile";</p>
<p class="Code"></p>
<p class="Code">//default name for file</p>
<p class="Code">toFile "/tmp/default"; </p>
<p class="Code"></p>
<p class="Code">message extends concat {</p>
<p class="Code"> a "copied file from ";</p>
<p class="Code">b ATTRIB fromURL;</p>
<p class="Code"> c " to file ";</p>
<p class="Code"> d ATTRIB toFile;</p>
<p class="Code">}</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code"></p>
<p class="Code">/*</p>
<p class="Code">* The removefile component is given a filename to remove,</p>
<p class="Code">* simulates doing so by issueing a message to that fact,</p>
<p class="Code">* then terminates after two seconds.</p>
<p class="Code">*/</p>
<p class="Code"></p>
<p class="Code">Removefile extends DoNothing {</p>
<p class="Code">time 2000; // time in millisecs</p>
<p class="Code">file "/tmp/default"; // default name for file</p>
<p class="Code"></p>
<p class="Code">message extends concat {</p>
<p class="Code"> a "file ";</p>
<p class="Code"> b ATTRIB file;</p>
<p class="Code"> c " has been removed";</p>
<p class="Code">}</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code"></p>
<p class="Code">/* There are two choices for the daemon</p>
<p class="Code">* either we can have a component that starts it then terminates</p>
<p class="Code">* and then another that stops it or we can launch a component</p>
<p class="Code">* that exists whilst the daemon should be running, starting in sfStart</p>
<p class="Code">* and terminating in sfTerminateWith.</p>
<p class="Code">* We will do the latter using ScriptPrim to provide the simulation</p>
<p class="Code">* by issuing messages at the right point.</p>
<p class="Code">* </p>
<p class="Code">* A complete implementation for this would use the runCmd component</p>
<p class="Code">* in .../os/runCmd</p>
<p class="Code">*</p>
<p class="Code">* The component is given the command line as a string</p>
<p class="Code">*/</p>
<p class="Code"></p>
<p class="Code">RunDaemon extends ScriptPrim {</p>
<p class="Code">commandLine "echo running daemon";</p>
<p class="Code"></p>
<p class="Code">sfStartCode ##</p>
<p class="Code"> System.out.println("starting " + prim.sfFind("commandLine"));</p>
<p class="Code">#;</p>
<p class="Code"></p>
<p class="Code">sfTerminateWithCode ##</p>
<p class="Code"> System.out.println("stoping " + prim.sfFind("commandLine"));</p>
<p class="Code">#;</p>
<p class="Code">}</p>
<p class="P39"></p>
<p class="Standard"></p>
<p class="Heading 4">File application.sf</p>
<p class="P39"></p>
<p class="Code">#include "org/smartfrog/examples/workflow/base.sf"</p>
<p class="Code"></p>
<p class="Code">/*</p>
<p class="Code">* define an application to be a sequence of</p>
<p class="Code">* copy file; run command for a period of time; remove file; </p>
<p class="Code">*</p>
<p class="Code">* running a command for a period involves wrapping in "during"</p>
<p class="Code">* to limit the time of the run</p>
<p class="Code">*</p>
<p class="Code">* an application is parameterised by the file URL, filename</p>
<p class="Code">* and the commandline, plus the length of time to run the daemon</p>
<p class="Code">*</p>
<p class="Code">*/</p>
<p class="Code"></p>
<p class="Code"></p>
<p class="Code">Application extends Sequence {</p>
<p class="Code">commandLine "echo default command";</p>
<p class="Code">filename "/tmp/default";</p>
<p class="Code">fileURL "http://defaultHost/defaultfile";</p>
<p class="Code">time 10000; // default time in millisecs</p>
<p class="Code">sfSyncTerminate "true";</p>
<p class="Code"> a extends Copyfile {</p>
<p class="Code"> toFile ATTRIB filename;</p>
<p class="Code"> fromURL ATTRIB fileURL;</p>
<p class="Code"> }</p>
<p class="Code"> b extends During {</p>
<p class="Code"> sfSyncTerminate "true"; // child stops before telling parent</p>
<p class="Code"> time PARENT:ATTRIB time; //avoid a loop..!</p>
<p class="Code"> action extends LAZY RunDaemon {</p>
<p class="Code"> commandLine PARENT:ATTRIB commandLine; //avoid a loop..!</p>
<p class="Code"> }</p>
<p class="Code"> }</p>
<p class="Code"> c extends Removefile {</p>
<p class="Code"> file ATTRIB filename;</p>
<p class="Code"> }</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code"></p>
<p class="Code"></p>
<p class="Code">/*</p>
<p class="Code">* Now to have some specific examples of applications</p>
<p class="Code">*</p>
<p class="Code">* a web server and an application server</p>
<p class="Code">*</p>
<p class="Code">*/</p>
<p class="Code"></p>
<p class="Code">WebServer extends Application {</p>
<p class="Code">file "webServerCode";</p>
<p class="Code">fileURL "http://codeserver/webServerCode";</p>
<p class="Code">commandLine "httpd";</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">AppServer extends Application {</p>
<p class="Code">file "appServerCode";</p>
<p class="Code">fileURL "http://codeserver/appServerCode";</p>
<p class="Code">commandLine "bluestone";</p>
<p class="Code">}</p>
<p class="P39"></p>
<p class="Standard"></p>
<p class="Heading 4">File Node.sf</p>
<p class="P39"></p>
<p class="Code">#include "org/smartfrog/examples/workflow/application.sf"</p>
<p class="Code">#include "org/smartfrog/services/trace/components.sf"</p>
<p class="Code"></p>
<p class="Code">/* </p>
<p class="Code">* define a node to be a sequence of</p>
<p class="Code">* a compound consisting of a web server and an app server</p>
<p class="Code">* notification of completion to a completion monitor</p>
<p class="Code">*/</p>
<p class="Code"></p>
<p class="Code">Node extends Compound {</p>
<p class="Code">sfSyncTerminate "true";</p>
<p class="Code">webs extends WebServer;</p>
<p class="Code">pps extends AppServer;</p>
<p class="Code">}</p>
<p class="Code"> 
</p>
<p class="Code"></p>
<p class="Code"></p>
<p class="Code">/*</p>
<p class="Code">* to experiment with failures - we can simulate a</p>
<p class="Code">* rogue node where everything fails ungracefully</p>
<p class="Code">* by addding a component which terminates abnormally</p>
<p class="Code">* after a very short time - say 4 seconds</p>
<p class="Code">*</p>
<p class="Code">*/</p>
<p class="Code"></p>
<p class="Code">RogueNode extends Node {</p>
<p class="Code">failure extends DoNothing {</p>
<p class="Code"> terminationType "abnormal";</p>
<p class="Code"> time 4000;</p>
<p class="Code">}</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code"></p>
<p class="Code"></p>
<p class="Code">/*</p>
<p class="Code">* we can now make a "reliableNode"</p>
<p class="Code">* which is one that tries 3 times to launch</p>
<p class="Code">* the correct action and if it fails sends a message</p>
<p class="Code">* to the sys admin</p>
<p class="Code">*</p>
<p class="Code">* parameterised on the action and retries</p>
<p class="Code">*</p>
<p class="Code">*/</p>
<p class="Code"></p>
<p class="Code">NotifySysAdmin extends ScriptPrim {</p>
<p class="Code">sfStartCode ##</p>
<p class="Code"> System.out.println("Houston - we have a problem with component ");</p>
<p class="Code">System.out.println(prim.sfCompleteName());</p>
<p class="Code">#;</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">ReliableNode extends Try {</p>
<p class="Code">nodeAction extends LAZY DoNothing; // default action for reliable node</p>
<p class="Code">retries 1;</p>
<p class="Code">sfSyncTerminate "true";</p>
<p class="Code"></p>
<p class="Code">action extends LAZY Retry {</p>
<p class="Code"> sfSyncTerminate "true";</p>
<p class="Code"> action ATTRIB nodeAction;</p>
<p class="Code"> retry PARENT:ATTRIB retries;</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">// on abnormal termination, notify admin</p>
<p class="Code">abnormal extends LAZY NotifySysAdmin; }</p>
<p class="Code"></p>
<p class="Code"></p>
<p class="Code">/*</p>
<p class="Code">* Given this, we can now define a reliable system node and a rogue system </p>
<p class="Code">* node as being the reliable node wrapping the node and reliablenode</p>
<p class="Code">*/</p>
<p class="Code"></p>
<p class="Code">SysNode extends ReliableNode {</p>
<p class="Code">nodeAction extends LAZY Node;</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">RogueSysNode extends ReliableNode {</p>
<p class="Code">nodeAction extends LAZY RogueNode;</p>
<p class="Code">}</p>
<p class="P39"></p>
<p class="Heading 4"></p>
<p class="Heading 4">File system.sf</p>
<p class="Standard"></p>
<p class="Code"></p>
<p class="Code">#include "org/smartfrog/examples/workflow/node.sf"</p>
<p class="Code">#include "org/smartfrog/examples/workflow/notifier.sf"</p>
<p class="Code"></p>
<p class="Code">/*</p>
<p class="Code">* Now define a system as containing a number of nodes, </p>
<p class="Code">* say 4 normal and one rogue</p>
<p class="Code">*</p>
<p class="Code">* These are run in parallel to provide independant termination, </p>
<p class="Code">* the system terminating when all the sub components do</p>
<p class="Code">* </p>
<p class="Code">* parameterize by their hostnames</p>
<p class="Code">* set to localhost by default</p>
<p class="Code">*</p>
<p class="Code">*/</p>
<p class="Code"></p>
<p class="Code">System extends Parallel {</p>
<p class="Code">host1 "localhost";</p>
<p class="Code">host2 "localhost";</p>
<p class="Code">host3 "localhost";</p>
<p class="Code">host4 "localhost";</p>
<p class="Code">rogueHost "localhost";</p>
<p class="Code"></p>
<p class="Code"> h1 extends SysNode {</p>
<p class="Code"> sfProcessHost ATTRIB host1;</p>
<p class="Code"> }</p>
<p class="Code"> h2 extends SysNode {</p>
<p class="Code"> sfProcessHost ATTRIB host1;</p>
<p class="Code"> }</p>
<p class="Code"> h3 extends SysNode {</p>
<p class="Code"> sfProcessHost ATTRIB host1;</p>
<p class="Code"> }</p>
<p class="Code"> h4 extends SysNode {</p>
<p class="Code"> sfProcessHost ATTRIB host1;</p>
<p class="Code"> }</p>
<p class="Code"> rh extends RogueSysNode {</p>
<p class="Code"> sfProcessHost ATTRIB rogueHost;</p>
<p class="Code"> }</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code"></p>
<p class="Code"></p>
<p class="Code">/*</p>
<p class="Code">* deploy a system - setting host names as required</p>
<p class="Code">*</p>
<p class="Code">*/</p>
<p class="Code"></p>
<p class="Code">sfConfig extends System {</p>
<p class="Code">host1 "localhost";</p>
<p class="Code">host2 "localhost";</p>
<p class="Code">host3 "localhost";</p>
<p class="Code">host4 "localhost";</p>
<p class="Code">rogueHost "localhost";</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code"></p>
<p class="P40">License</p>
<p class="Code"></p>
<p class="Code">/** (C) Copyright 1998-2005 Hewlett-Packard Development Company, LP</p>
<p class="Code"></p>
<p class="Code">This library is free software; you can redistribute it and/or</p>
<p class="Code">modify it under the terms of the GNU Lesser General Public</p>
<p class="Code">License as published by the Free Software Foundation; either</p>
<p class="Code">version 2.1 of the License, or (at your option) any later version.</p>
<p class="Code"></p>
<p class="Code">This library is distributed in the hope that it will be useful,</p>
<p class="Code">but WITHOUT ANY WARRANTY; without even the implied warranty of</p>
<p class="Code">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU</p>
<p class="Code">Lesser General Public License for more details.</p>
<p class="Code"></p>
<p class="Code">You should have received a copy of the GNU Lesser General Public</p>
<p class="Code">License along with this library; if not, write to the Free Software</p>
<p class="Code">Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</p>
<p class="Code"></p>
<p class="Code">For more information: www.smartfrog.org</p>
<p class="Code"></p>
<p class="Code">*/</p>
<p class="Code"></p>
</div>
</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2005 Hewlett Packard Company</div>
<div class="host">
<a href="http://sourceforge.net/projects/smartfrog"><img class="logoImage" alt="" src="images/sourceforge.gif"></a>
</div>
</div>
</body>
</html>
