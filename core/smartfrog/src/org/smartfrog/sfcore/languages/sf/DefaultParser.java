/* Generated By:JavaCC: Do not edit this line. DefaultParser.java */
package org.smartfrog.sfcore.languages.sf;

import org.smartfrog.sfcore.languages.sf.*;
import org.smartfrog.sfcore.languages.sf.sfcomponentdescription.*;
import org.smartfrog.sfcore.reference.*;
import java.io.*;
import java.util.*;

public class DefaultParser implements DefaultParserConstants {
  protected IncludeHandler includeHandler;
  static int nextId = 0;

  public DefaultParser(InputStream is, IncludeHandler handler) {
    this(is);
    this.includeHandler = handler;
  }

  private String fixEscapes(String s) {
    int index = 0;
    int length = s.length();
    StringBuffer fixed = new StringBuffer(length);

    while (index < length) {
      if (s.charAt(index) == '\\') {
        index++;
        switch (s.charAt(index)) {
          case 'n':
            fixed.append('\n'); break;
          case 't':
            fixed.append('\t'); break;
          case 'b':
            fixed.append('\b'); break;
          case 'r':
            fixed.append('\r'); break;
          case 'f':
            fixed.append('\f'); break;
          case '0': case '1': case '2': case '3':
          case '4': case '5': case '6': case '7':
            int i = ((s.charAt(index) - '0') * 64) +
                    ((s.charAt(index+1) - '0') * 8) +
                    ((s.charAt(index+2) - '0'));
            index = index + 2;
            fixed.append((char) i);
            break;
          default:
            fixed.append(s.charAt(index));
        }
      } else {
        fixed.append(s.charAt(index));
      }
      index++;
    }
    return fixed.toString();
  }

  protected Vector parseInclude(String fName) throws ParseException {
    try {
      return includeHandler.parseInclude(fName);
    } catch (TokenMgrError tex) {
      throw new TokenMgrError("In include file " + fName + " : " +
                              tex.getMessage(),
                              tex.errorCode);
    } catch (Exception ex) {
      throw new ParseException("Parsing include file " + fName + " : " +
                               ex.getMessage());
    }
  }

/*
 * Entry point to the grammar for component parser
 */
  final public void Attributes(SFComponentDescription descr) throws ParseException {
    AttributesNoEOF(descr);
    jj_consume_token(0);
  }

/*
 * Entry point for default include handler
 */
  final public Vector AttributeList() throws ParseException {
    Vector res;
    res = AttributeListNoEOF();
    jj_consume_token(0);
          {if (true) return res;}
    throw new Error("Missing return statement in function");
  }

/*
 * Entry point for Reference parser
 */
  final public Reference Reference() throws ParseException {
  Reference res;
    res = ReferenceNoEOF();
    jj_consume_token(0);
          {if (true) return res;}
    throw new Error("Missing return statement in function");
  }

/*
 * Main body of grammar
 */
  final public void AttributesNoEOF(SFComponentDescription descr) throws ParseException {
  Vector attrs;
    attrs = AttributeListNoEOF();
    for (Enumeration e = attrs.elements(); e.hasMoreElements(); ) {
      Object[] attribute = (Object[])e.nextElement();
      descr.getContext().put(attribute[0], attribute[1]);
      if (attribute[1] instanceof SFComponentDescription)
        ((SFComponentDescription)attribute[1]).setParent(descr);
    }
  }

  final public Vector AttributeListNoEOF() throws ParseException {
    Vector res = new Vector(10, 5);
    Object[] c;
    String fName;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEMICOLON:
      case UNIQUE:
      case INCLUDE:
      case WORD:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case UNIQUE:
      case WORD:
        c = Attribute();
                       res.addElement(c);
        break;
      case INCLUDE:
        jj_consume_token(INCLUDE);
        fName = String();
           Vector tmp = parseInclude(fName);
           for(Enumeration e = tmp.elements(); e.hasMoreElements(); )
             res.addElement(e.nextElement());
        break;
      case SEMICOLON:
        jj_consume_token(SEMICOLON);
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      {if (true) return res;}
    throw new Error("Missing return statement in function");
  }

  final public Object[] Attribute() throws ParseException {
  Object[] attribute = new Object[2];
  Reference name = new Reference();
    Name(name);
    attribute[1] = Value();
     if (name.size() == 1)
      attribute[0] = ((HereReferencePart)name.firstElement()).value;
     else
      attribute[0] = name;
     if (attribute[1] == null) attribute[1] = ((HereReferencePart)name.lastElement()).value;
     {if (true) return attribute;}
    throw new Error("Missing return statement in function");
  }

  final public void Name(Reference res) throws ParseException {
  res.setEager(true);
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case UNIQUE:
      jj_consume_token(UNIQUE);
        res.addElement(ReferencePart.here("unique" + nextId++));
      break;
    case WORD:
      IdReferencePart(res);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case REFPARTSEP:
        jj_consume_token(REFPARTSEP);
        Name(res);
        break;
      default:
        jj_la1[2] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public Object Value() throws ParseException {
  Object res=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXTENDS:
      res = Component();
      break;
    case LAZY:
    case ROOT:
    case ATTRIB:
    case THIS:
    case PROPERTY:
    case IPROPERTY:
    case PARENT:
    case HOST:
    case PROCESS:
    case WORD:
      res = ReferenceNoEOF();
      jj_consume_token(SEMICOLON);
      break;
    case LBRACKET:
    case TRUE:
    case FALSE:
    case STRING:
    case MULTILINESTRING:
    case INTEGER:
    case DOUBLE:
    case LONG:
    case FLOAT:
      res = Basic();
      jj_consume_token(SEMICOLON);
      break;
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return res;}
    throw new Error("Missing return statement in function");
  }

  final public SFComponentDescription Component() throws ParseException {
  SFComponentDescription component;
  String componentClass="default";
  Token id;
    jj_consume_token(EXTENDS);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case REFPARTSEP:
      jj_consume_token(REFPARTSEP);
      id = jj_consume_token(WORD);
                                       componentClass = id.image;
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
    component = ComponentType(componentClass);
     {if (true) return component;}
    throw new Error("Missing return statement in function");
  }

  final public SFComponentDescription ComponentType(String componentClass) throws ParseException {
  SFComponentDescription component =
      SFParser.componentFactory(componentClass);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
    case LBRACE:
    case NULLPROTO:
    case ROOT:
    case ATTRIB:
    case THIS:
    case PROPERTY:
    case IPROPERTY:
    case PARENT:
    case HOST:
    case PROCESS:
    case WORD:
      EagerComponent(component);
      break;
    case LAZY:
      LazyComponent(component);
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return component;}
    throw new Error("Missing return statement in function");
  }

  final public void EagerComponent(SFComponentDescription comp) throws ParseException {
    BaseComponent(comp);
                        comp.setEager(true);
  }

  final public void LazyComponent(SFComponentDescription comp) throws ParseException {
    jj_consume_token(LAZY);
    BaseComponent(comp);
                               comp.setEager(false);
  }

  final public void BaseComponent(SFComponentDescription comp) throws ParseException {
  Reference protoType = new Reference();
  protoType.setEager(true);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NULLPROTO:
    case ROOT:
    case ATTRIB:
    case THIS:
    case PROPERTY:
    case IPROPERTY:
    case PARENT:
    case HOST:
    case PROCESS:
    case WORD:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NULLPROTO:
        jj_consume_token(NULLPROTO);
        break;
      case ROOT:
      case ATTRIB:
      case THIS:
      case PROPERTY:
      case IPROPERTY:
      case PARENT:
      case HOST:
      case PROCESS:
      case WORD:
        BaseReference(protoType);
        break;
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[8] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    case LBRACE:
      jj_consume_token(LBRACE);
      AttributesNoEOF(comp);
      jj_consume_token(RBRACE);
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    if (protoType.size() > 0 &&
        (protoType.firstElement() instanceof HereReferencePart)) {
      HereReferencePart firstPart = (HereReferencePart)
        protoType.firstElement();
      protoType.setElementAt(firstPart.asAttribReferencePart(), 0);
    }
    comp.setType(protoType.size() == 0 ? null : protoType);
  }

  final public Reference ReferenceNoEOF() throws ParseException {
  Reference res = new Reference();
  res.setEager(true);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LAZY:
      jj_consume_token(LAZY);
            res.setEager(false);
      break;
    default:
      jj_la1[10] = jj_gen;
      ;
    }
    BaseReference(res);
                                                        {if (true) return res;}
    throw new Error("Missing return statement in function");
  }

  final public void BaseReference(Reference ref) throws ParseException {
    ReferencePart(ref);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case REFPARTSEP:
        ;
        break;
      default:
        jj_la1[11] = jj_gen;
        break label_2;
      }
      jj_consume_token(REFPARTSEP);
      ReferencePart(ref);
    }
  }

  final public void ReferencePart(Reference ref) throws ParseException {
  Token id;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ROOT:
      jj_consume_token(ROOT);
              ref.addElement(ReferencePart.root());
      break;
    case PARENT:
      jj_consume_token(PARENT);
                ref.addElement(ReferencePart.parent());
      break;
    case ATTRIB:
      jj_consume_token(ATTRIB);
      id = jj_consume_token(WORD);
                          ref.addElement(ReferencePart.attrib(id.image));
      break;
    case THIS:
      jj_consume_token(THIS);
              ref.addElement(ReferencePart.thisref());
      break;
    case PROPERTY:
      jj_consume_token(PROPERTY);
      id = jj_consume_token(WORD);
                            ref.addElement(ReferencePart.property(id.image));
      break;
    case IPROPERTY:
      jj_consume_token(IPROPERTY);
      id = jj_consume_token(WORD);
                             ref.addElement(ReferencePart.iproperty(id.image));
      break;
    case HOST:
      jj_consume_token(HOST);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WORD:
        id = jj_consume_token(WORD);
                    ref.addElement(ReferencePart.host(id.image));
        break;
      case STRING:
        id = jj_consume_token(STRING);
                      ref.addElement(ReferencePart.host(id.image.substring(1, id.image.length() - 1)));
        break;
      default:
        jj_la1[12] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    case PROCESS:
      jj_consume_token(PROCESS);
                 ref.addElement(ReferencePart.process());
      break;
    case WORD:
      IdReferencePart(ref);
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void IdReferencePart(Reference ref) throws ParseException {
  Token id;
    id = jj_consume_token(WORD);
               ref.addElement(ReferencePart.here(id.image));
  }

  final public Object Basic() throws ParseException {
  Object res, tmp;
  Token id;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING:
    case MULTILINESTRING:
      res = String();
      break;
    case INTEGER:
    case DOUBLE:
    case LONG:
    case FLOAT:
      res = Number();
      break;
    case TRUE:
    case FALSE:
      res = Boolean();
      break;
    case LBRACKET:
      jj_consume_token(LBRACKET);
                   res = new Vector();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
      case TRUE:
      case FALSE:
      case STRING:
      case MULTILINESTRING:
      case INTEGER:
      case DOUBLE:
      case LONG:
      case FLOAT:
        tmp = Basic();
                         ((Vector)res).addElement(tmp);
        label_3:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[14] = jj_gen;
            break label_3;
          }
          jj_consume_token(COMMA);
          tmp = Basic();
                                 ((Vector)res).addElement(tmp);
        }
        break;
      default:
        jj_la1[15] = jj_gen;
        ;
      }
      jj_consume_token(RBRACKET);
      break;
    default:
      jj_la1[16] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return res;}
    throw new Error("Missing return statement in function");
  }

  final public Number Number() throws ParseException {
    Token res;
    Number num;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOUBLE:
      res = jj_consume_token(DOUBLE);
      if (res.image.toUpperCase().charAt(res.image.length() - 1) == 'D')
        num =  Double.valueOf(res.image.substring(0, res.image.length() - 1));
      else
        num =  Double.valueOf(res.image.substring(0, res.image.length()));
      break;
    case FLOAT:
      res = jj_consume_token(FLOAT);
      num = Float.valueOf(res.image.substring(0, res.image.length() - 1));
      break;
    case INTEGER:
      res = jj_consume_token(INTEGER);
      num = Integer.valueOf(res.image);
      break;
    case LONG:
      res = jj_consume_token(LONG);
      num = Long.valueOf(res.image.substring(0, res.image.length() - 1));
      break;
    default:
      jj_la1[17] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return num;}
    throw new Error("Missing return statement in function");
  }

  final public String String() throws ParseException {
    Token res;
    String s;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING:
      res = jj_consume_token(STRING);
                      s = fixEscapes(res.image.substring(1, res.image.length() - 1));
      break;
    case MULTILINESTRING:
      res = jj_consume_token(MULTILINESTRING);
                               s = fixEscapes(res.image.substring(2, res.image.length() - 1));
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     /* if (s.equals("true") | s.equals("false"))
        System.out.println("Using strings to represent boolean-valued attributes is deprecated - use true or false");
     */
      {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  final public Boolean Boolean() throws ParseException {
    Token res;
    Boolean b;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRUE:
      res = jj_consume_token(TRUE);
                    b = Boolean.TRUE;
      break;
    case FALSE:
      res = jj_consume_token(FALSE);
                     b = Boolean.FALSE;
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return b;}
    throw new Error("Missing return statement in function");
  }

  public DefaultParserTokenManager token_source;
  ASCII_UCodeESC_CharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[20];
  final private int[] jj_la1_0 = {0x202000,0x202000,0x80000,0x200000,0xffc22000,0x80000,0xff90a000,0xff100000,0xff100000,0xa000,0x800000,0x80000,0x0,0xff000000,0x4000,0x20000,0x20000,0x0,0x0,0x0,};
  final private int[] jj_la1_1 = {0x9,0x9,0x0,0x8,0x738e,0x0,0x8,0x8,0x8,0x0,0x0,0x0,0x88,0x8,0x0,0x7386,0x7386,0x7200,0x180,0x6,};

  public DefaultParser(java.io.InputStream stream) {
    jj_input_stream = new ASCII_UCodeESC_CharStream(stream, 1, 1);
    token_source = new DefaultParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
  }

  public DefaultParser(java.io.Reader stream) {
    jj_input_stream = new ASCII_UCodeESC_CharStream(stream, 1, 1);
    token_source = new DefaultParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
  }

  public DefaultParser(DefaultParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
  }

  public void ReInit(DefaultParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  final public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[47];
    for (int i = 0; i < 47; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 20; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 47; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
