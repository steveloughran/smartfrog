options {
  DEBUG_TOKEN_MANAGER = false;
  STATIC=false;
  JAVA_UNICODE_ESCAPE = true;
  FORCE_LA_CHECK=true;
}

PARSER_BEGIN(DefaultParser)
package org.smartfrog.sfcore.languages.csf;

import org.smartfrog.sfcore.languages.csf.csfcomponentdescription.CSFComponentDescriptionImpl;
import org.smartfrog.sfcore.languages.csf.csfcomponentdescription.CSFComponentDescription;
import org.smartfrog.sfcore.languages.csf.csfcomponentdescription.FreeVar;
import org.smartfrog.sfcore.languages.csf.constraints.Constraint;
import org.smartfrog.sfcore.languages.sf.sfreference.SFApplyReference;
import org.smartfrog.sfcore.languages.sf.sfreference.SFReference;
import org.smartfrog.sfcore.languages.sf.sfreference.SFAssertReference;
import org.smartfrog.sfcore.languages.sf.sfreference.SFTBDReference;

import org.smartfrog.sfcore.languages.sf.IncludeHandler;

import org.smartfrog.sfcore.reference.ReferencePart;
import org.smartfrog.sfcore.reference.HostReferencePart;
import org.smartfrog.sfcore.reference.PropertyReferencePart;
import org.smartfrog.sfcore.reference.IPropertyReferencePart;
import org.smartfrog.sfcore.reference.EnvPropertyReferencePart;
import org.smartfrog.sfcore.reference.IEnvPropertyReferencePart;
import org.smartfrog.sfcore.reference.HereReferencePart;
import org.smartfrog.sfcore.reference.RootReferencePart;
import org.smartfrog.sfcore.reference.AttribReferencePart;
import org.smartfrog.sfcore.reference.ThisReferencePart;

import org.smartfrog.sfcore.componentdescription.ComponentDescription;
import org.smartfrog.sfcore.common.Context;


import org.smartfrog.sfcore.common.SFNull;
import org.smartfrog.sfcore.common.SFByteArray;
import org.smartfrog.sfcore.common.SmartFrogException;
import java.io.InputStream;
import java.util.Vector;
import java.util.Enumeration;
import java.util.Set;
import java.util.HashSet;

public class DefaultParser {
  protected IncludeHandler includeHandler;
  static int nextId = 0;

  static final String appendOp = "org.smartfrog.sfcore.languages.sf.functions.Append";
  static final String concatOp = "org.smartfrog.sfcore.languages.sf.functions.Concatenate";
  static final String sumOp = "org.smartfrog.sfcore.languages.sf.functions.Sum";
  static final String timesOp = "org.smartfrog.sfcore.languages.sf.functions.Product";

  static final String andOp = "org.smartfrog.sfcore.languages.sf.functions.And";
  static final String orOp = "org.smartfrog.sfcore.languages.sf.functions.Or";

  static final String eqOp = "org.smartfrog.sfcore.languages.sf.functions.EQ";
  static final String neOp = "org.smartfrog.sfcore.languages.sf.functions.NE";
  static final String geOp = "org.smartfrog.sfcore.languages.sf.functions.GE";
  static final String leOp = "org.smartfrog.sfcore.languages.sf.functions.LE";
  static final String gtOp = "org.smartfrog.sfcore.languages.sf.functions.GT";
  static final String ltOp = "org.smartfrog.sfcore.languages.sf.functions.LT";

  static final String minusOp = "org.smartfrog.sfcore.languages.sf.functions.Minus";
  static final String divOp = "org.smartfrog.sfcore.languages.sf.functions.Divide";

  static final String notOp = "org.smartfrog.sfcore.languages.sf.functions.Not";
  static final String ifThenElseOp = "org.smartfrog.sfcore.languages.sf.functions.IfThenElse";
  static final String functionPhaseClass = "org.smartfrog.sfcore.languages.sf.ConstructFunction";

  static final String tbdOp = "org.smartfrog.sfcore.languages.sf.predicates.TBD";


  public DefaultParser(InputStream is, IncludeHandler handler) {
    this(is);
    this.includeHandler = handler;
  }


  private String fixEscapes(String s) {
    int index = 0;
    int length = s.length();
    StringBuffer fixed = new StringBuffer(length);

    while (index < length) {
      if (s.charAt(index) == '\\') {
        index++;
        switch (s.charAt(index)) {
          case 'n':
            fixed.append('\n'); break;
          case 't':
            fixed.append('\t'); break;
          case 'b':
            fixed.append('\b'); break;
          case 'r':
            fixed.append('\r'); break;
          case 'f':
            fixed.append('\f'); break;
          case '=':
            fixed.append("\\="); break;
          case '#':        //this case is captured by the default, but is here for explicitness
            fixed.append('#'); break;  
          case '0': case '1': case '2': case '3':
          case '4': case '5': case '6': case '7':
            int i = ((s.charAt(index) - '0') * 64) +
                    ((s.charAt(index+1) - '0') * 8) +
                    ((s.charAt(index+2) - '0'));
            index = index + 2;
            fixed.append((char) i);
            break;
          default:
            fixed.append(s.charAt(index));
        }
      } else {
        fixed.append(s.charAt(index));
      }
      index++;
    }
    return fixed.toString();
  }

  private String eliminateWhitespace(String s) {
    int index = 0;
    int length = s.length();
    StringBuffer fixed = new StringBuffer();

    while (index < length) {
        switch (s.charAt(index)) {
          case '\n':
          case '\t':
          case ' ':
            break;
          default:
            fixed.append(s.charAt(index));
        }
        index++;
    }
    return fixed.toString();
  }


  protected Vector parseInclude(String fName, String codebase) throws ParseException {
    try {
      return includeHandler.parseInclude(fName, codebase);
    } catch (TokenMgrError tex) {
      throw new TokenMgrError("In include file " + fName + " : " +
                              tex.getMessage(),
                              tex.errorCode);
    } catch (Exception ex) {
      throw new ParseException("Parsing include file " + fName + " : " +
                               ex.getMessage());
    }
  }

}

PARSER_END(DefaultParser)


/* WHITE SPACE */

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* COMMENTS */

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
| <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
| "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <( ~[ "\n" , "\r" ] )* > : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

/**
 * if you change this, dont forget to update the reference documentation
 */
TOKEN : /* reserved words */
{
   <APPLY: "APPLY">
 | <ASSERT: "ASSERT">
 | <ATTRIB: "ATTRIB">
 | <CODEBASE: "#codebase">
 | <COMMA: ",">
 | <DATA: "DATA">
 | <EXTENDS: "extends">
 | <FALSE: "false">
 | <HERE: "HERE">
 | <HOST: "HOST">
 | <INCLUDE: "#include">
 | <PROPERTY: "PROPERTY">
 | <IPROPERTY: "IPROPERTY">
 | <ENVPROPERTY: "ENVPROPERTY">
 | <IENVPROPERTY: "IENVPROPERTY">
 | <LAZY: "LAZY">
 | <LBRACE: "{">
 | <LBRACKET: "[">
 | <NULL: "NULL">
 | <OPTIONAL: "OPTIONAL">
 | <PARENT: "PARENT">
 | <PROCESS: "PROCESS">
 | <RBRACE: "}">
 | <RBRACKET: "]">
 | <REFPARTSEP: ":">
 | <ROOT: "ROOT">
 | <SEMICOLON: ";">
 | <TBD: "TBD">
 | <THIS: "THIS">
 | <TRUE: "true">
 | <VECTOREND: "|]" >
 | <VECTORSTART: "[|">
 | <UNIQUE: "--">

 | <OPSTART: "(">
 | <OPEND: ")">

 | <SUM: "+">
 | <MINUS: "-">
 | <TIMES: "*">
 | <DIV: "/">
 | <CONCAT: "++">
 | <APPEND: "<>">

 | <EQ: "==">
 | <NE: "!=">
 | <GE: ">=">
 | <LE: "<=">
 | <GT: ">">
 | <LT: "<">

 | <AND: "&&">
 | <OR: "||">
 | <NOT: "!">

 | <IF: "IF">
 | <THEN: "THEN">
 | <ELSE: "ELSE">
 | <FI: "FI">

 | <VAR: "VAR" ("/" (<DIGIT>)+ )? >
}

TOKEN :
{
  < WORD: <LETTER> (<LETTER>|<DIGIT>|<SPECIAL>)* >
| < #SPECIAL: [".", "_", "-", "+", "@", "#", "~", "$", "%", "^", "&"] >
| < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}


TOKEN : /* Literals */
{
      <STRING:
      ("\"" (
          (~["\"","\\","\n","\r"])
          | ("\\"
              ( ["n","t","b","r","f","\\","'","\""]
              | ["0"-"3"] ["0"-"7"] ["0"-"7"]
              )
            )
        )* "\"")
      >
    | <MULTILINESTRING: ("##" (
          (~["#","\\"])
          | ("\\"
              ( ["n","t","b","r","f","\\","'","#"]
              | ["0"-"3"] ["0"-"7"] ["0"-"7"]
              )
            )
        )* "#")
      >
    | <SELECTING: ("#selecting#" (               // for backward compatibility
          (~["#","\\"])
          | ("\\"
              ( ["n","t","b","r","f","\\","'","#","="]
              | ["0"-"3"] ["0"-"7"] ["0"-"7"]
              )
            )
        )* "#")
      >
    | <ALLOCATE: ("#allocate(" (["A"-"Z","a"-"z"]) (["A"-"Z","a"-"z","0"-"9"])* ")##")>
    | <BINDING: ("#binding#" (                        // for backward compatibility
          (~["#","\\"])
          | ("\\"
              ( ["n","t","b","r","f","\\","'","#","="]
              | ["0"-"3"] ["0"-"7"] ["0"-"7"]
              )
            )
        )* "#")
      >
     | <CHECKING: ("#checking#" (                      // for backward compatibility
          (~["#","\\"])
          | ("\\"
              ( ["n","t","b","r","f","\\","'","#","="]
              | ["0"-"3"] ["0"-"7"] ["0"-"7"]
              )
            )
        )* "#")
      >
     | <CONSTRAINT: ("#constraint:" (["0"-"9"])+ "#" (
          (~["#","\\"])
          | ("\\"
              ( ["n","t","b","r","f","\\","'","#","="]
              | ["0"-"3"] ["0"-"7"] ["0"-"7"]
              )
            )
        )* "#")
      >
     | <DECL: ("#decl#" (
          (~["#","\\"])
          | ("\\"
              ( ["n","t","b","r","f","\\","'","#","="]
              | ["0"-"3"] ["0"-"7"] ["0"-"7"]
              )
            )
        )* "#")
      >
     | <SEARCH: ("#search:" (["0"-"9"])+ "#" (
          (~["#","\\"])
          | ("\\"
              ( ["n","t","b","r","f","\\","'","#","="]
              | ["0"-"3"] ["0"-"7"] ["0"-"7"]
              )
            )
        )* "#")
      >
     | <SUCHTHAT: ("#suchThat#" (                     // for backward compatibility
          (~["#","\\"])
          | ("\\"
              ( ["n","t","b","r","f","\\","'","#","="]
              | ["0"-"3"] ["0"-"7"] ["0"-"7"]
              )
            )
        )* "#")
      >
    | <INTEGER: (("-")? ["0"-"9"] (["0"-"9"])*)
        | "0" >
    | <#FLOAT_BASE:
        ("-")?
        (
          (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?
        | "." (["0"-"9"])+ (<EXPONENT>)?
        | (["0"-"9"])+ <EXPONENT>
        | (["0"-"9"])+ (<EXPONENT>)?
        )
      >
    | < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
    | <DOUBLE:
        <FLOAT_BASE> ["d", "D"]
      >
    | <LONG:
        <INTEGER> ["l", "L"]
      >
    | <FLOAT:
        <FLOAT_BASE> (["f", "F"])?
      >
    | <BYTEARRAY:
          (("#HEX#")
          (["0"-"9", "a"-"f", "A"-"F", " ", "\n", "\t"])*
           ("#"))
          |(("#DEC#")
           (["0"-"9", " ", "\n", "\t"])*
           ("#"))
          |(("#OCT#")
           (["0"-"7", " ", "\n", "\t"])*
           ("#"))
          |(("#BIN#")
           (["0"-"1", " ", "\n", "\t"])*
           ("#"))
          |(("#B64#")
           (["0"-"9", "a"-"f", "A"-"F", "=", "+", "/", " ", "\n", "\t"])*
           ("#"))
       >
}


/*
 * Entry point to the grammar for component parser
 */

void Attributes(CSFComponentDescription descr) :
{
}
{
  AttributesNoEOF(descr) <EOF>
}

/*
 * Entry point for default include handler
 */

Vector AttributeList() :
{
    Vector res;
}
{
    res = AttributeListNoEOF() <EOF>
    { return res; }
}

/*
 * Entry point for Reference parser
 */

SFReference Reference() :
{
  SFReference res;
}
{
    res = ReferenceNoEOF() <EOF>
    { return res; }
}

/*
 * Entry point for any value parser (e.g. for parsing values in Management Console)
 */
 Object AnyValue() :
{
  Object res;
}
{
     (res=Component() | res=SimpleValue()) <EOF>
     { return res; }
}


 /*
  * Entry point for basic value parser (e.g. for parsing properties)
  */
 Object PrimitiveValue() :
{
  Object res;
}
{
    res = Primitive() <EOF>
    { return res; }
}

 /*
  * Entry point for tags parser (e.g. for tags in management console)
  */
 Object TagsSet() :
{
  Set tags = new HashSet();
}
{
    [ <LBRACKET> Tags(tags) <RBRACKET> ] <EOF>
    { return tags; }
}

/*
 * Main body of grammar
 */
void AttributesNoEOF(CSFComponentDescription descr) :
{
  Vector attrs;
}
{
  attrs = AttributeListNoEOF()
  {
    for (Enumeration e = attrs.elements(); e.hasMoreElements(); ) {
      Object[] attribute = (Object[])e.nextElement();
      descr.sfContext().put(attribute[0], attribute[1]);
      try {
         if (((Set)attribute[2]).size() > 0)descr.sfContext().sfSetTags(attribute[0], (Set)attribute[2]);
      } catch (SmartFrogException sce) {
         //shouldn't happen
         sce.printStackTrace();
    }
      if (attribute[1] instanceof CSFComponentDescription)
        ((CSFComponentDescription)attribute[1]).setParent(descr);
    }
  }
}


Vector AttributeListNoEOF() :
{
    Vector res = new Vector(10, 5);
    Object[] c;
}
{
    ( c = Attribute() {res.addElement(c);}
    | Includes(res)
    | <SEMICOLON>
    )*
    { return res; }
}

void Includes(Vector res) :
{
     String codebase = null;
     String fName;
}
{
( [<CODEBASE> codebase = String() ] <INCLUDE> fName = String()
         { Vector tmp = parseInclude(fName, codebase);
           for(Enumeration e = tmp.elements(); e.hasMoreElements(); )
             res.addElement(e.nextElement());
       } )
}

Object[] Attribute() :
{
  Object[] attribute = new Object[3];
  SFReference name = new SFReference();
  Set tags = new HashSet();
}
{
  ([ <LBRACKET> Tags(tags) <RBRACKET> ] Name(name) attribute[1]=Value()
   { if (name.size() == 1)
        attribute[0] = ((HereReferencePart)name.firstElement()).getValue();
     else
        attribute[0] = name;
     if (attribute[1] == null) attribute[1] = SFNull.get();
     attribute[2] = tags;
     return attribute;
   })
}

void Tags(Set tags) :
{
    Token t;
}
{
    [t=<WORD> {tags.add(t.image);}
      [<COMMA>] Tags(tags)
    ]
}


void Name(SFReference res) :
{
  res.setEager(true);
  Token t;
}
{
     (<UNIQUE>
       {
           res.addElement(ReferencePart.here("unique" + nextId++));
       }
     )
    |
     (
       (t=<WORD> {res.addElement(ReferencePart.here(t.image));})
       [(<REFPARTSEP> Name(res))]
     )
}






Object Value() :
{
  Object res=null;
}
{
    (
    res=Component()
    | res=SimpleValue() <SEMICOLON>
    | <SEMICOLON>
    ) { return res; }
}


Object Var() :
{
   Token res = null;
}
{
   res = <VAR> { return new FreeVar(res.image);}
}



Object SimpleValue() :
{
  Object res=null;
}
{
    (
    res=ReferenceNoEOF()
    | res=Basic()
    | res = Operator()
    | res = IfThenElse()
    ) { return res; }
}


Object Operator() :
{
    Object res;
    int arity = 0; //0=nary, 1=unary, 2=binary

    Object a = null;
    Object b = null;
    Vector v = new Vector();
    String operator = "";
}
{
    <OPSTART>
    ((<NOT> {operator = notOp; arity = 1;} a = SimpleValue() )
     |
     (a = SimpleValue() {v.add(a);}) [
     (
      ((<APPEND> {operator = appendOp; arity=0;}) (b = SimpleValue() {v.add(b);}) (<APPEND> (b = SimpleValue() {v.add(b);}))*)
         |((<CONCAT> {operator = concatOp; arity=0;}) (b = SimpleValue() {v.add(b);}) (<CONCAT> (b = SimpleValue() {v.add(b);}))*)
         |((<SUM> {operator = sumOp; arity=0;}) (b = SimpleValue() {v.add(b);}) (<SUM> (b = SimpleValue() {v.add(b);}))*)
         |((<TIMES> {operator = timesOp; arity=0;}) (b = SimpleValue() {v.add(b);}) (<TIMES> (b = SimpleValue() {v.add(b);}))*)
         |((<AND> {operator = andOp; arity=0;}) (b = SimpleValue() {v.add(b);}) (<AND> (b = SimpleValue() {v.add(b);}))*)
         |((<OR> {operator = orOp; arity=0;}) (b = SimpleValue() {v.add(b);}) (<OR> (b = SimpleValue() {v.add(b);}))*)

     |((<EQ> {operator = eqOp; arity=2;}) (b = SimpleValue()))
     |((<NE> {operator = neOp; arity=2;}) (b = SimpleValue()))
     |((<GE> {operator = geOp; arity=2;}) (b = SimpleValue()))
     |((<LE> {operator = leOp; arity=2;}) (b = SimpleValue()))
     |((<GT> {operator = gtOp; arity=2;}) (b = SimpleValue()))
     |((<LT> {operator = ltOp; arity=2;}) (b = SimpleValue()))
         |((<MINUS> {operator = minusOp; arity=2;}) (b = SimpleValue()))
         |((<DIV> {operator = divOp; arity=2;}) (b = SimpleValue()))
     )
      ]
    )
    <OPEND>
    {
    if (operator.equals("")) {
        res = a;
    } else {
        res = SFParser.componentFactory("default");
        if (arity==0) {
        for (Enumeration e = v.elements(); e.hasMoreElements(); ) {
            Object attribute = e.nextElement();
            ((CSFComponentDescription)res).sfContext().put("unique" + nextId++, attribute);
            if (attribute instanceof CSFComponentDescription)
            ((CSFComponentDescription)attribute).setParent((CSFComponentDescription)res);
        }
        } else if (arity == 2) {
        ((CSFComponentDescription)res).sfContext().put("left", a);
        if (a instanceof CSFComponentDescription)
            ((CSFComponentDescription)a).setParent((CSFComponentDescription)res);
        ((CSFComponentDescription)res).sfContext().put("right", b);
        if (b instanceof CSFComponentDescription)
            ((CSFComponentDescription)b).setParent((CSFComponentDescription)res);
        } else { // (arity == 1)
        ((CSFComponentDescription)res).sfContext().put("data", a);
        if (a instanceof CSFComponentDescription)
            ((CSFComponentDescription)a).setParent((CSFComponentDescription)res);
        }
        ((CSFComponentDescription)res).sfContext().put("phase.function", functionPhaseClass);
        ((CSFComponentDescription)res).sfContext().put("sfFunctionClass", operator);
    }
    return res;
    }
}


Object IfThenElse() :
{
    Object i,t,e;
}
{
    <IF> i = SimpleValue() <THEN> t = SimpleValue() <ELSE> e = SimpleValue() <FI>
    {
    CSFComponentDescription ifte = SFParser.componentFactory("default");
    if (i instanceof CSFComponentDescription)
        ((CSFComponentDescription)i).setParent((CSFComponentDescription)ifte);

    if (t instanceof CSFComponentDescription)
        ((CSFComponentDescription)t).setParent((CSFComponentDescription)ifte);

    if (e instanceof CSFComponentDescription)
        ((CSFComponentDescription)e).setParent((CSFComponentDescription)ifte);

    ifte.sfContext().put("phase.function", functionPhaseClass);
    ifte.sfContext().put("sfFunctionClass", ifThenElseOp);

    ifte.sfContext().put("if", i);
    ifte.sfContext().put("then", t);
    ifte.sfContext().put("else", e);
    return ifte;
    }
}

//
// Note that the Component() term may include a different node type builder.
// This is used as follows:
//
//   foo extends:someClass etc...
//
// Where the default is "default". This is used by the
// component factory to map to a class to represent that node. This is
// CSFComponentDescriptionImpl in the default factory.
// This is not documented anywhere (deliberately) and maybe should
// be removed... (IT has been useful in some special uses of the language
// outside of SmartFrog).
//
CSFComponentDescription Component() :
{
  CSFComponentDescription component;
  String componentClass="default";
  Token id;
}
{
  <EXTENDS> [ <REFPARTSEP> id=<WORD> { componentClass = id.image; } ] component=ComponentType(componentClass)
   { return component; }
}

CSFComponentDescription ComponentType(String componentClass) :
{
  CSFComponentDescription component =
      SFParser.componentFactory(componentClass);
}
{
  (EagerComponent(component)|DataComponent(component))
    { return component; }
}

void EagerComponent(CSFComponentDescription comp) :
{
}
{
  BaseComponent(comp) { comp.setEager(true); }
}

void DataComponent(CSFComponentDescription comp) :
{
}
{
  (<DATA> | <LAZY>) BaseComponent(comp) { comp.setEager(false); }
}


void BaseComponent(CSFComponentDescription comp) :
{
}
{ (
  <SEMICOLON>
  | (<NULL> (BaseComponentRest(comp) | <SEMICOLON>))
  | (BaseComponentLinkType(comp) (BaseComponentRest(comp)  | <SEMICOLON>))
  | (BaseComponentAttributesType(comp) [BaseComponentRest(comp)]) // for backward compat...
  )
  {    // fix the case when the extends is only of a single {...} as assumptions have been made that
       // type resolution is not required in this case - true before multiple extends!
       // This is done by moving contexts, as the contained CD may be of the wrong node type!
       if (comp.getTypes().size() == 1) {
          Object type = comp.getTypes().firstElement();
          if (type instanceof CSFComponentDescription) {
               CSFComponentDescription cdType = (CSFComponentDescription) type;
               Context cxt = cdType.sfContext();
               comp.setContext(cxt);

               // re-parent any descriptions in super sfContext
               for (Enumeration e = cxt.keys(); e.hasMoreElements(); ) {
                   Object key = e.nextElement();
                   Object value = cxt.get(key);
                   if (value instanceof CSFComponentDescription) {
                       ((CSFComponentDescription) value).setParent(comp);
                   }
               }
               comp.setTypes(new Vector());
               comp.setConstraints(cdType.getConstraints());
          }
       }
  }
}


void BaseComponentRest(CSFComponentDescription comp) :
{
}
{
  (<COMMA>  (BaseComponentLinkType(comp)|BaseComponentAttributesType(comp)|<NULL>) (BaseComponentRest(comp)  | <SEMICOLON>))
  | (BaseComponentAttributesType(comp)) // for backward compat...
}

void BaseComponentLinkType(CSFComponentDescription comp) :
{
   SFReference prototype = null;
}
{
   prototype = LinkReference()
   {prototype.setEager(true); comp.addType(prototype);}
}

void BaseComponentAttributesType (CSFComponentDescription comp) :
{
   CSFComponentDescriptionImpl compType = new CSFComponentDescriptionImpl(new Vector(), null, null, true);
}
{
   <LBRACE> AttributesNoEOF(compType) <RBRACE> Constraints(compType)
   {comp.addType(compType);}
}

void Constraints(CSFComponentDescription comp) :
{
    String suchThat = "";
    int priority = 0;
    boolean allocating = false;
    Token t;
}
{
    (
       ( (t = <CHECKING> | t = <SUCHTHAT>)           //note important that checking and suchthat have 8 chars!!!:-)
            { priority = 25;
              suchThat = fixEscapes(t.image.substring(10, t.image.length() - 1)); }
       | t = <DECL>
            { priority = 0;
              suchThat = fixEscapes(t.image.substring(6, t.image.length() - 1));  }
       | t = <CONSTRAINT>
            { priority = (new Integer(t.image.substring(12, t.image.indexOf("#", 12)))).intValue();
              suchThat = fixEscapes(t.image.substring(t.image.indexOf("#", 12) + 1, t.image.length() - 1)); }
       | t = <SEARCH>
            { priority = -(new Integer(t.image.substring(8, t.image.indexOf("#", 8)))).intValue();
              suchThat = fixEscapes(t.image.substring(t.image.indexOf("#", 8) + 1, t.image.length() - 1)); }
       | t = <BINDING>
            { priority = 50;
              suchThat = fixEscapes(t.image.substring(9, t.image.length() - 1));  }
       | t = <SELECTING>
            { priority = 75;
              suchThat = fixEscapes(t.image.substring(11, t.image.length() - 1)); }
       | t = <ALLOCATE>
	   { suchThat = t.image.substring(10, t.image.indexOf(")", 10));
             allocating = true; }
       )
      {
       try {
	   if (allocating)
	       comp.addConstraint(new Constraint(suchThat));
           else 
               comp.addConstraint(new Constraint(suchThat, priority));
       } catch (Exception  se) {
            throw new ParseException("Error creating constraint, exception thrown: " + se);
       }
      }
    )*
}

SFReference ReferenceNoEOF() :
{
  SFReference res;
  boolean lazy = false;
}
{
  [<LAZY> { lazy = true; }]  res = BaseReference() {res.setEager(!lazy);  return res; }
}

SFReference BaseReference() :
{
    CSFComponentDescription comp;
    SFReference ref;
    boolean optional = false;
    Object defaultValue = null;
}
{
  (
    ([<OPTIONAL> [<OPSTART> defaultValue = Primitive() ")"] { optional = true; } ] ref = LinkReference()
             { ref.setOptional(optional); if (defaultValue!=null) ref.setDefaultValue(defaultValue); })
  |
    (<APPLY> <LBRACE> {comp = SFParser.componentFactory("default");} AttributesNoEOF(comp) <RBRACE>
             {ref = new SFApplyReference(comp);})
  |
    (<ASSERT> <LBRACE> {comp = SFParser.componentFactory("default");} AttributesNoEOF(comp) <RBRACE>
             {ref = new SFAssertReference(comp);})
  ) {
    ref.setEager(true);
    ref.setData(false);
    return ref;
  }
}

SFReference LinkReference() :
{
    SFReference ref = new SFReference();
}
{
   ReferencePart(ref) (<REFPARTSEP> ReferencePart(ref))*
   { return ref; }
}

void ReferencePart(SFReference ref) :
{
  Token id;
}
{
    (<ROOT> { ref.addElement(ReferencePart.root()); })
  | (<PARENT> { ref.addElement(ReferencePart.parent()); })
  | (<ATTRIB> id=<WORD> { ref.addElement(ReferencePart.attrib(id.image)); })
  | (<HERE> id=<WORD> { ref.addElement(ReferencePart.here(id.image)); })
  | (<THIS> { ref.addElement(ReferencePart.thisref()); })
  | (<PROPERTY> id=<WORD> { ref.addElement(ReferencePart.property(id.image));})
  | (<IPROPERTY> id=<WORD> { ref.addElement(ReferencePart.iproperty(id.image));})
  | (<ENVPROPERTY> id=<WORD> { ref.addElement(ReferencePart.envproperty(id.image));})
  | (<IENVPROPERTY> id=<WORD> { ref.addElement(ReferencePart.ienvproperty(id.image));})
  | (<HOST> (
       (id=<WORD> { ref.addElement(ReferencePart.host(id.image));})
      |(id=<STRING> { ref.addElement(ReferencePart.host(id.image.substring(1, id.image.length() - 1)));})
     ))
  | (<PROCESS> { ref.addElement(ReferencePart.process());})
  | (id=<WORD> { if (ref.size() == 0) // id in first position - treat as an attrib, not a here
             ref.addElement(ReferencePart.attrib(id.image));
                 else
             ref.addElement(ReferencePart.here(id.image));
                })
}


Object Basic() :
{
  Object res, tmp;
  Token id;
}
{
  (
     (res=Primitive())
   | (<LBRACKET> { res = new Vector(); }
          [tmp=SimpleValue() { ((Vector)res).addElement(tmp); }
          (<COMMA> tmp=SimpleValue() { ((Vector)res).addElement(tmp); })*]
      <RBRACKET> {
      CSFComponentDescription component =
          SFParser.componentFactory("default");
      for (Enumeration e = ((Vector)res).elements(); e.hasMoreElements(); ) {
          Object attribute = e.nextElement();
          component.sfContext().put("unique" + nextId++, attribute);
          if (attribute instanceof CSFComponentDescription)
          ((CSFComponentDescription)attribute).setParent(component);
      }
      component.sfContext().put("phase.function", functionPhaseClass);
      component.sfContext().put("sfFunctionClass", "org.smartfrog.sfcore.languages.sf.functions.Vector");

      res = component;
      })
    ) { return res; }
}

Object Primitive() :
{
  Object res, tmp;
  Token id;
}
{
  (
   (<NULL> {res = SFNull.get();})
   | (res=String())
   | (res=Number())
   | (res=Boolean())
   | (res=ByteArray())
   | (<VECTORSTART> { res = new Vector(); }
          [tmp=Primitive() { ((Vector)res).addElement(tmp); }
          (<COMMA> tmp=Primitive() { ((Vector)res).addElement(tmp); })*]
      <VECTOREND>)
   | <DATA> res = BaseReference() {((SFReference)res).setData(true);}
   | <TBD> {res = new SFTBDReference();}
   | res=Var()
  ) { return res; }
}



Number Number() :
{
    Token res;
    Number num;
}
{
  (
    res=<DOUBLE >
    {
      if (res.image.toUpperCase().charAt(res.image.length() - 1) == 'D')
        num =  Double.valueOf(res.image.substring(0, res.image.length() - 1));
      else
        num =  Double.valueOf(res.image.substring(0, res.image.length()));
    }
  | res=<FLOAT>
    {
      num = Float.valueOf(res.image.substring(0, res.image.length() - 1));
    }
  | res=<INTEGER>
    {
      num = Integer.valueOf(res.image);
    }
  | res=<LONG>
    {
      num = Long.valueOf(res.image.substring(0, res.image.length() - 1));
    }
  ) { return num; }
}

String String() :
{
    Token res;
    String s;
}
{
  (  ( res=<STRING> { s = fixEscapes(res.image.substring(1, res.image.length() - 1)); })
   | ( res=<MULTILINESTRING> { s = fixEscapes(res.image.substring(2, res.image.length() - 1)); })
  ) {
      return s;
    }
}

Boolean Boolean() :
{
    Token res;
    Boolean b;
}
{
  (  res = <TRUE> { b = Boolean.TRUE; }
   | res = <FALSE> { b = Boolean.FALSE; }
  ) { return b; }
}

SFByteArray ByteArray() :
{
    Token res;
    String s;
    String type;
}
{
  (  ( res=<BYTEARRAY> { s = eliminateWhitespace(res.image.substring(5, res.image.length() - 1));
                         type = eliminateWhitespace(res.image.substring(1, 4)); })
  ) {
      try {
          SFByteArray ba = new SFByteArray(s, type, res.beginLine, res.beginColumn);
          return ba;
      } catch (Exception e) {
          throw new ParseException("error constructing binary data:" + e.toString());
      }
    }
}

