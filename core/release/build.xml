<?xml version="1.0" encoding="utf-8"?>
<project name="release" default="default"
    xmlns:ivy="antlib:org.apache.ivy.ant"
    xmlns:iz="http://www.izforge.com/">
  <!--
    /** (C) Copyright 2007-2008 Hewlett-Packard Development Company, LP
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.
    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.
    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
    For more information: www.smartfrog.org
    */
  -->
  <description>
    This build file aggregates artifacts from other projects to cut a release.

    In a normal distribution, the RPM smartfrog-private-security-keys contains nothing sensitive.
  </description>

  <!--we are a component -->
  <property name="is.component" value="true"/>
  <!--no javadocs until we have source-->
  <!--<property name="javadoc.disabled" value="true" />-->

  <!-- override point -->
  <property file="build.properties"/>


  <property name="root.dir" location=".."/>


  <property name="jarfile.suffix" value="-resources"/>
  <property name="jarfile.extension" value="jar"/>
  <property name="project.name" value="sf-${ant.project.name}"/>
  <property name="artifact.name" value="${project.name}"/>
  <property name="jarfile.stub" value="${artifact.name}${jarfile.suffix}"/>
  <property name="trace.enabled" value="true"/>
  <property name="ivy.artifact.retrieve.pattern"
      value="[conf]/[artifact]-[revision].[ext]"/>

  <!-- override this to get a different release, such as a hard coded version.
  -->
  <property name="ivy.smartfrog.version" value="latest.integration"/>

  <echo
      message="==================================================================="/>
  <echo message="= ${ant.project.name}"/>

  <!-- Import common stuff -->
  <import file="../common.xml"/>

  <!-- main distribution target-->
  <target name="dist"
      depends="common.dist,maven-artifacts,rpm,izpack,release-kernel,package-source"/>


  <target name="init" depends="common.init">
    <property name="izpack.jar"
        location="${dist.bin.dir}/smartfrog-install-${smartfrog.version}.jar"/>
    <!--presetdef for a copy with expansion of all properties in scope-->


    <newdir name="dist.rpm.dir" location="${dist.dir}/rpm"/>
    <newdir name="dist.signed.rpm.dir" location="${dist.dir}/signedrpm"/>
    <property name="kernel.dir" location="../smartfrog"/>
    <newdir name="release.dir" location="${build.dir}/releases"/>
    <property name="ssh.trust" value="true"/>
    <newdir name="tmp.dir" location="${build.dir}/tmp"/>
    <newdir name="upload.dir" location="${build.dir}/upload"/>

    <property name="server.dir"
        location="metadata/servers/"/>

  </target>

  <target name="release" depends="published"/>
  <target name="published" depends="ivy-report,common.published"/>

  <!--
  //this is commented out because izpack isnt in the big repository
  <target name="declare-izpack" depends="ivy-resolve">
    <ivy:cachepath pathid="izpack.classpath" conf="izpack" />
    <taskdef name="izpack" classpathref="izpack.classpath"
        uri="http://www.izforge.com/"
        classname="com.izforge.izpack.ant.IzPackTask"/>
  </target>
  -->
  <target name="declare-izpack" depends="init">
    <taskdef name="izpack"
        uri="http://www.izforge.com/"
        classname="com.izforge.izpack.ant.IzPackTask">
      <classpath>
        <fileset dir="lib">
          <include name="**/*.jar"/>
        </fileset>
      </classpath>
    </taskdef>
  </target>

  <target name="prepare-resources" depends="init">
    <copy todir="${build.dir}/res">
      <fileset dir="src/res" includes="*"/>
    </copy>
  </target>

  <target name="prepare-executables"
      depends="ivy-retrieve,locate-core-artifacts">
  </target>

  <target name="locate-core-artifacts" depends="ivy-properties">
    <property name="sf-core-install.zip"
        location="${ivy.lib.dir}/package-core-install/sf-core-install-${smartfrog.version}.zip"/>
    <property name="sf-core-javadocs.zip"
        location="${ivy.lib.dir}/package-core/sf-core-javadocs-${smartfrog.version}.zip"/>

  </target>

  <target name="expand-izpack" depends="init">
    <expandingcopy todir="${build.dir}">
      <fileset file="izpack/smartfrog-install.xml"/>
    </expandingcopy>
    <property name="izpack.xml" location="${build.dir}/smartfrog-install.xml"/>
  </target>

  <target name="validate-izpack" depends="expand-izpack">
    <loadfile srcFile="izpack/doctype.txt" property="doctype.txt"/>
    <copy file="${izpack.xml}" tofile="build/izpack-dtd.xml" overwrite="true">
      <filterset begintoken="&lt;--@" endtoken="@--&gt;">
        <filter token="DOCTYPE-INSERT-POINT" value="${doctype.txt}"/>
      </filterset>
    </copy>
    <xmlvalidate file="build/izpack-dtd.xml" warn="false"/>
  </target>

  <target name="ready-to-izpack"
      depends="declare-izpack,prepare-resources,prepare-executables,packaged,expand-izpack"/>

  <!-- run izpack and copy in the file-->
  <target name="izpack" depends="ready-to-izpack">
    <iz:izpack input="${build.dir}/smartfrog-install.xml"
        output="${izpack.jar}"
        installerType="standard"
        basedir="${build.dir}"/>
  </target>

  <target name="ready-to-run" depends="izpack"/>

  <target name="run" depends="ready-to-run,run-no-rebuild"
      description="pack the application and run it">
  </target>


  <target name="run-no-rebuild" depends="init"
      description="run the izpack application in debug mode, with no rebuilding">
    <java jar="${izpack.jar}" fork="true">
      <sysproperty key="TRACE" value="${trace.enabled}"/>
    </java>
  </target>

  <target name="unzip" depends="izpack">
    <newdir name="unzip.dir" location="${build.dir}/unzip"/>
    <unzip src="${izpack.jar}" dest="${unzip.dir}"/>
  </target>

  <!-- hit the switches that declare which bits of the build-->
  <target name="init-automated-exec" depends="init">
    <property name="build.install.dir" location="${build.dir}/smartfrog"/>
    <property name="core.selected" value="true"/>
    <property name="minimal.selected" value="true"/>
    <property name="full.selected" value="true"/>
    <property name="ant.selected" value="true"/>
    <property name="anubis.selected" value="true"/>
    <property name="database.selected" value="true"/>
    <property name="jmx.selected" value="true"/>
    <property name="logging.selected" value="true"/>
    <property name="networking.selected" value="true"/>
    <property name="quartz.selected" value="true"/>
    <property name="scripting.selected" value="true"/>
    <property name="xunit.selected" value="true"/>
    <property name="junit.selected" value="true"/>
    <property name="www.selected" value="true"/>
    <property name="xml.selected" value="true"/>
    <property name="xmpp.selected" value="true"/>
    <!--
        <property name=".selected" value="true" />
    -->
  </target>

  <target name="copy-automated-template" depends="init-automated-exec">
    <property name="automated.xml" location="${dist.bin.dir}/automated.xml"/>
    <expandingcopy tofile="${automated.xml}" overwrite="true">
      <fileset file="izpack/auto-install-template.xml"/>
    </expandingcopy>
  </target>

  <target name="automated-exec" depends="ready-to-run,copy-automated-template">
    <java jar="${izpack.jar}" fork="true">
      <sysproperty key="TRACE" value="${trace.enabled}"/>
      <arg value="${automated.xml}"/>
    </java>
  </target>

  <target name="exec-version" depends="automated-exec">
    <condition property="script"
        value=".bat" else="">
      <os family="dos"/>
    </condition>
    <exec executable="${build.install.dir}/bin/sfVersion${script}">
      <env key="SFHOME" value="${build.install.dir}"/>
    </exec>
    <exec executable="${build.install.dir}/bin/sfDiag${script}">
      <env key="SFHOME" value="${build.install.dir}"/>
    </exec>
  </target>


  <!-- ============================================================================================= -->

  <target name="package-source" depends="init,ivy-resolve">
    <property name="source.zip"
        location="${upload.dir}/smartfrog-${smartfrog.version}-source.zip"/>

    <copy tofile="${source.zip}"
        file="${ivy.lib.dir}/package-antbuild-source/sf-antbuild-src-${smartfrog.version}.zip"/>
  </target>

  <!-- ============================================================================================= -->

  <target name="check-rpm" depends="init">
    <condition property="has.rpm.tools">
      <and>
        <os family="unix"/>
        <available file="rpmbuild" filepath="${env.PATH}"/>
        <not>
          <isset property="rpm.disabled"/>
        </not>
      </and>
    </condition>
    <echo level="verbose">
      has.rpm.tools=${has.rpm.tools}
    </echo>
  </target>

  <!--
  This target sets up all the RPM directories, and defined the properties that
  can refer to them.

  When we build an RPM, we have to use the built in tar and ln commands to get
  everything set up right, at least until ant gets the ability to set up
  symlinks in a <tar> file.
  -->
  <target name="check-source-artifacts" depends="prepare-executables">
    <fileset id="sf-core-install-artifacts"
      dir="${ivy.lib.dir}/package-core-install/" includes="*"/>
    <fail>
      <condition >
        <not>
          <available file="${sf-core-install.zip}" />
        </not>
      </condition>
      Unable to locate ${sf-core-install.zip};
      There is probably a mismatch between the version of SmartFrog that Ivy retrieved
      and the version that the build file is expecting, which is ${smartfrog.version}, and which
      is calculated by getting the SmartFrog version off the classpath.

      sf-core-install-artifacts=${toString:sf-core-install-artifacts}
      smartfrog.classpath=${toString:smartfrog.classpath}
    </fail>
  </target>

  <target name="init-rpm"
      depends="check-rpm,ivy-properties,use-smartfrog-tasks,check-source-artifacts">

    <property name="rpm.metadata.dir" location="metadata/rpm"/>
    <loadproperties srcFile="${rpm.metadata.dir}/rpm.properties"/>

    <newdir name="build.rpm.dir" location="${build.dir}/rpm"/>

    <newdir name="rpm.root.dir" location="${build.rpm.dir}/root/"/>

    <newdir name="rpm.image.dir"
        location="${build.rpm.dir}/rpm"/>
    <newdir name="rpm.SOURCES"
        location="${rpm.image.dir}/SOURCES"/>
    <newdir name="rpm.SRPMS"
        location="${rpm.image.dir}/SRPMS"/>
    <newdir name="rpm.SPECS"
        location="${rpm.image.dir}/SPECS"/>
    <newdir name="rpm.BUILD"
        location="${rpm.image.dir}/BUILD"/>
    <newdir name="rpm.RPMS"
        location="${rpm.image.dir}/RPMS"/>
    <newdir name="rpm.noarch"
        location="${rpm.RPMS}/noarch"/>
    <newdir name="core.install.dir"
        location="${rpm.root.dir}/${rpm.install.dir}"/>
    <newdir name="rpm.lib.dir"
        location="${core.install.dir}/lib"/>
    <property name="rpm.signed.lib.dir"
        location="${core.install.dir}/signedLib"/>

    <property name="smartfrog.rpmfiles.tar"
        location="${rpm.SOURCES}/smartfrog-${smartfrog.version}.tar"/>
    <property name="smartfrog.rpmfiles.tar.gz"
        location="${smartfrog.rpmfiles.tar}.gz"/>
    <property name="rpm.suffix"
        value="${smartfrog.version}-${rpm.release.version}.noarch.rpm"/>
    <property name="target.rpm.shortname"
        value="smartfrog-${rpm.suffix}"/>
    <property name="target.rpm"
        location="${dist.rpm.dir}/${target.rpm.shortname}"/>
    <property name="demo.rpm"
        location="${dist.rpm.dir}/smartfrog-demo-${rpm.suffix}"/>
    <property name="daemon.rpm"
        location="${dist.rpm.dir}/smartfrog-daemon-${rpm.suffix}"/>
    <property name="anubis.rpm"
        location="${dist.rpm.dir}/smartfrog-anubis-${rpm.suffix}"/>
    <property name="logging.rpm"
        location="${dist.rpm.dir}/smartfrog-logging-${rpm.suffix}"/>
    <property name="rpms.tar"
        location="${dist.rpm.dir}/smartfrog-rpm-bundle-${smartfrog.version}.tar"/>
    <property name="rpms.tar.gz"
        location="${upload.dir}/smartfrog-rpm-bundle-${smartfrog.version}.tar.gz"/>
    <property name="rpms.signed.tar"
        location="${dist.rpm.dir}/smartfrog-signed-rpm-bundle-${smartfrog.version}.tar"/>
    <property name="rpms.signed.tar.gz"
        location="${upload.dir}/smartfrog-signed-rpm-bundle-${smartfrog.version}.tar.gz"/>
    <property name="private-rpm-package.tar"
        location="${upload.dir}/smartfrog-private-rpms-${smartfrog.version}.tar"/>
    <property name="private-rpm-package.tar.gz"
        location="${private-rpm-package.tar}.gz"/>



    <property name="remote-smartfrogd" value="/etc/init.d/${rpm.daemon.name}"/>

    <mkdir dir="${build.rpm.dir}/root${rpm.log.dir}"/>

    <macrodef name="rpmpackage">
      <attribute name="package"/>
      <sequential>
        <copy todir="${rpm.lib.dir}">
          <fileset file="${ivy.lib.dir}/package-@{package}/*.jar"/>
        </copy>
      </sequential>
    </macrodef>
  </target>

  <target name="copy-rpm-specs" depends="init-rpm">
    <expandingcopy todir="${rpm.SPECS}">
      <fileset dir="${rpm.metadata.dir}" includes="**/*.spec"/>
    </expandingcopy>
  </target>

  <!--
  this is a a wierd target as it patches the macros file rpmmacros with the
  location of the output. With ant-contrib's try/finally tasks we could
  copy and restore this -provided only one build per user was live.
  As it is, unless you set the rpm.skip.macros property, your
  ~/.rpmmacros file gets trashed by Ant.

  Notes
   * the specfile attr is the name of the spec file under SPECS; it is not a full path to the file
   * - is not allowed in the version number
  -->
  <target name="rpmmacros" unless="rpm.skip.macros" depends="init-rpm">
    <echo file="${user.home}/.rpmmacros">
      #GENERATED by rpmmacros task in ${basedir}
      %_topdir ${build.rpm.dir}
    </echo>
  </target>


  <target name="ready-to-rpm" depends="prepare-private-rpm,prepare-binary-rpm"/>

  <target name="release-rpm" description="release the rpm" depends="rpm"/>

  <target name="rpm" depends="gzip-rpm" description="create the gzipped RPM"/>

  <target name="build-rpm" depends="package-private-rpm,ready-to-rpm"
      if="has.rpm.tools"
      description="create an RPM file of the core smartfrog libraries">
    <rpm
        specFile="smartfrog.spec"
        topDir="${rpm.image.dir}"
        cleanBuildDir="true"
        failOnError="true"/>
  </target>
  
  <target name="dont-build-rpm" depends="package-private-rpm,ready-to-rpm"
      unless="has.rpm.tools">
    <echo>No rpm-build package installed here, or its a windows machine</echo>
  </target>

  <target name="expand-core" depends="init-rpm,prepare-executables">
    <unzip src="${sf-core-install.zip}"
        dest="${core.install.dir}"/>
  </target>

  <target name="copy-scripts" depends="init-rpm">
    <property name="profile.d" location="${rpm.root.dir}/etc/profile.d"/>
    <property name="init.d" location="${rpm.root.dir}/etc/init.d"/>
  </target>


  <!--set up the javadocs by
    -unzipping the JAR into its own location
  -->
  <target name="rpm-javadocs" if="has.rpm.tools"
      depends="init-rpm,prepare-executables">
    <newdir name="rpm.javadocs.install.dir"
        location="${rpm.root.dir}${rpm.javadocs.path}"/>
    <unzip src="${sf-core-javadocs.zip}"
        dest="${rpm.javadocs.install.dir}"/>
  </target>


  <target name="rpm-components"
      if="has.rpm.tools"
      depends="expand-core">
  </target>


  <!-- create the link dir and its symlinks -->
  <target name="create-link-dir" if="has.rpm.tools"
      depends="copy-scripts,rpm-components">
    <property name="rpm.link.dir"
        location="${build.rpm.dir}/root${rpm.install.dir}/links"/>
    <mkdir dir="${rpm.link.dir}"/>
    <!-- macro to create a symlink on Unix for the RPM.
      The artifact is verified as living in the reparented filesystem, 
      but the symlinks is set to point to the destination relative to root.
      This is because tar does not fix links up during the packaging.
    -->
    <macrodef name="ln">
      <attribute name="artifact"/>
      <attribute name="version"/>
      <sequential>
        <fail>
          <condition>
            <not>
              <available file="${rpm.lib.dir}/@{artifact}-@{version}.jar"/>
            </not>
          </condition>
          Missing destination artifact: ${rpm.lib.dir}/@{artifact}-@{version}.jar
        </fail>
        <exec executable="ln" failonerror="true">
          <arg value="-sf"/>
          <arg value="${rpm.install.dir}/lib/@{artifact}-@{version}.jar"/>
          <arg value="${rpm.link.dir}/@{artifact}.jar"/>
        </exec>
      </sequential>
    </macrodef>
    <!--core-->
    <ln artifact="smartfrog" version="${smartfrog.version}"/>
    <ln artifact="sfExamples" version="${smartfrog.version}"/>
    <ln artifact="sfServices" version="${smartfrog.version}"/>

    <!-- ant -->
    <rpmpackage package="ant"/>
    <ln artifact="sf-ant" version="${smartfrog.version}"/>
    <ln artifact="ant" version="${apache.ant.version}"/>
    <ln artifact="ant-launcher" version="${apache.ant.version}"/>

    <!-- anubis -->
    <rpmpackage package="anubis"/>
    <ln artifact="sf-anubis" version="${smartfrog.version}"/>
    
    <!-- cloudfarmer -->
    <rpmpackage package="cloudfarmer"/>
    <ln artifact="sf-cloudfarmer" version="${smartfrog.version}"/>
    <ln artifact="commons-beanutils" version="${commons-beanutils.version}"/>
    <ln artifact="commons-chain" version="${commons-chain.version}"/>
    <ln artifact="commons-digester" version="${commons-digester.version}"/>
    <ln artifact="commons-validator" version="${commons-validator.version}"/>
    <ln artifact="struts-core" version="${struts.version}"/>
    <ln artifact="struts-taglib" version="${struts.version}"/>
    <ln artifact="struts-tiles" version="${struts.version}"/>

    
    <!-- csvfiles -->
    <rpmpackage package="csvfiles"/>
    <ln artifact="sf-csvfiles" version="${smartfrog.version}"/>
    <ln artifact="opencsv" version="${opencsv.version}"/>

    <!-- database -->
    <rpmpackage package="database"/>
    <ln artifact="sf-database" version="${smartfrog.version}"/>
    <ln artifact="commons-dbcp" version="${commons-dbcp.version}"/>
    <ln artifact="commons-pool" version="${commons-pool.version}"/>
    <ln artifact="commons-dbutils" version="${commons-dbutils.version}"/>

    <!-- EC2 -->
    <rpmpackage package="ec2"/>
    <ln artifact="sf-ec2" version="${smartfrog.version}"/>
    <ln artifact="typica" version="${typica.version}"/>
    <ln artifact="org.restlet" version="${restlet.version}"/>
    <ln artifact="org.restlet.ext.fileupload" version="${restlet.version}"/>
    <ln artifact="com.noelios.restlet" version="${restlet.version}"/>
    <ln artifact="com.noelios.restlet.ext.httpclient" version="${restlet.version}"/>
    <ln artifact="com.noelios.restlet.ext.net" version="${restlet.version}"/>
    <ln artifact="commons-fileupload" version="${commons-fileupload.version}"/>

    <!-- groovy -->
    <rpmpackage package="groovy"/>
    <ln artifact="sf-groovy" version="${smartfrog.version}"/>
    <ln artifact="groovy-all-minimal" version="${groovy.version}"/>
    <ln artifact="groovy-engine" version="${groovy-engine.version}"/>
    
    <!-- hadoop -->
    <rpmpackage package="hadoop"/>
    <ln artifact="sf-hadoop" version="${smartfrog.version}"/>
    <ln artifact="hadoop-common" version="${hadoop.version}"/>
    <ln artifact="hadoop-hdfs" version="${hadoop.version}"/>
    <ln artifact="hadoop-mapred" version="${hadoop.version}"/>
    <ln artifact="avro" version="${avro.version}"/>
    <ln artifact="commons-cli" version="${commons-cli.version}"/>
    <ln artifact="jackson-core-asl" version="${jackson-asl.version}"/>
    <ln artifact="jackson-mapper-asl" version="${jackson-asl.version}"/>
    <ln artifact="jets3t" version="${jets3t.version}"/>
    <ln artifact="paranamer" version="${paranamer.version}"/>
    <ln artifact="xmlenc" version="${xmlenc.version}"/>

    <!-- jmx -->
    <rpmpackage package="jmx"/>
    <ln artifact="sf-jmx" version="${smartfrog.version}"/>
    <ln artifact="mx4j" version="${mx4j.version}"/>
    <ln artifact="mx4j-remote" version="${mx4j.version}"/>
    <ln artifact="mx4j-jmx" version="${mx4j.version}"/>
    <ln artifact="mx4j-tools" version="${mx4j.version}"/>

    <!--logging-->
    <rpmpackage package="logging"/>
    <ln artifact="sf-loggingservices" version="${smartfrog.version}"/>
    <ln artifact="commons-logging" version="${commons-logging.version}"/>
    <ln artifact="log4j" version="${log4j.version}"/>
    <ln artifact="slf4j-jcl" version="${slf4j.version}"/>
    <ln artifact="slf4j-api" version="${slf4j.version}"/>

    <!-- networking -->
    <rpmpackage package="networking"/>
    <ln artifact="sf-dns" version="${smartfrog.version}"/>
    <ln artifact="sf-emailer" version="${smartfrog.version}"/>
    <ln artifact="sf-net" version="${smartfrog.version}"/>
    <ln artifact="sf-ssh" version="${smartfrog.version}"/>

    <ln artifact="dnsjava" version="${dnsjava.version}"/>
    <ln artifact="mail" version="${mail.version}"/>
    <ln artifact="activation" version="${activation.version}"/>
    <ln artifact="commons-net" version="${commons-net.version}"/>
    <ln artifact="oro" version="${oro.version}"/>
    <ln artifact="jsch" version="${jsch.version}"/>

    <!-- quartz -->
    <rpmpackage package="quartz"/>
    <ln artifact="sf-quartz" version="${smartfrog.version}"/>
    <ln artifact="quartz" version="${quartz.version}"/>
    <!-- quartz -->
    <rpmpackage package="rpmtools"/>
    <ln artifact="sf-rpmtools" version="${smartfrog.version}"/>

    <!-- scripting -->
    <rpmpackage package="scripting"/>
    <ln artifact="sf-scripting" version="${smartfrog.version}"/>
    <ln artifact="bsh" version="${bsh.version}"/>

    <!-- xunit -->
    <!-- junit -->
    <rpmpackage package="testing"/>
    <ln artifact="sf-xunit" version="${smartfrog.version}"/>
    <ln artifact="sf-junit" version="${smartfrog.version}"/>
    <ln artifact="junit" version="${junit.version}"/>

    <!--velocity-->
    <rpmpackage package="velocity"/>
    <ln artifact="sf-velocity" version="${smartfrog.version}"/>
    <ln artifact="velocity" version="${velocity.version}"/>
    <ln artifact="velocity-dep" version="${velocity.version}"/>
    <ln artifact="commons-collections" version="${commons-collections.version}"/>
    <ln artifact="commons-lang" version="${commons-lang.version}"/>

    <!-- WWW -->
    <rpmpackage package="www"/>
    <ln artifact="sf-www" version="${smartfrog.version}"/>
    <ln artifact="commons-httpclient" version="${commons-httpclient.version}"/>
    <ln artifact="commons-codec" version="${commons-codec.version}"/>

    <!--Jetty-->
    <!--comes in after the www package-->
    <ln artifact="sf-jetty" version="${smartfrog.version}"/>
    <ln artifact="jetty" version="${jetty.version}"/>
    <ln artifact="jetty-util" version="${jetty.version}"/>
    <ln artifact="servlet-api" version="${servletapi.version}"/>
    <ln artifact="commons-el" version="${commons-el.version}"/>
    <ln artifact="jsp-api-2.1" version="${jetty.version}"/>
    <ln artifact="jsp-2.1" version="${jetty.version}"/>
    <ln artifact="core" version="${org.eclipse.jdt.core.version}"/>
 
    <!--  xml-->
    <rpmpackage package="xml"/>
    <ln artifact="sf-xml" version="${smartfrog.version}"/>
    <ln artifact="jdom" version="${jdom.version}"/>
    <ln artifact="xom" version="${xom.version}"/>
    <ln artifact="xml-apis" version="${xml-apis.version}"/>
    <ln artifact="xercesImpl" version="${xerces.version}"/>
    <ln artifact="xalan" version="${xalan.version}"/>

    <!-- xmpp -->
    <rpmpackage package="xmpp"/>
    <ln artifact="sf-xmpp" version="${smartfrog.version}"/>
    <ln artifact="smack" version="${smack.version}"/>

  </target>

  <target name="ready-to-sign-rpm-jars"
      depends="copy-rpm-specs,create-link-dir,init-security">
  </target>

  <!--For the RPMs, we create symbolic links instead of a separate directory-->
  <target name="symlink-signed-lib" depends="ready-to-sign-rpm-jars"
          if="has.rpm.tools"
        >
  <delete dir="${rpm.signed.lib.dir}" />
    <exec executable="ln" failonerror="true">
      <arg value="-sf"/>
      <arg value="${rpm.install.dir}/lib"/>
      <arg value="${rpm.signed.lib.dir}"/>
    </exec>
  </target>

  <!--we've cut symlink-signed-lib from the depends list here-->
  <target name="maybe-sign-rpm-jars" depends="copy-rpm-specs,create-link-dir,init-security"
      xmlns:sec="http://security.smartfrog.org/">
  </target>


  <target name="copy-and-patch-rpm-scripts"
      depends="copy-scripts">
    <expandingcopy todir="${build.rpm.dir}/root/">
      <fileset dir="scripts" includes="etc/**/*"/>
    </expandingcopy>
  </target>

  <target name="prepare-other-root-dirs" depends="create-link-dir,symlink-signed-lib,create-link-dir,copy-and-patch-rpm-scripts,rpm-components">
    <mkdir dir="${build.rpm.dir}/root${rpm.log.dir}"/>
  </target>


  <target name="ready-to-prepare-binary-rpm"
      depends="prepare-other-root-dirs,rpm-javadocs,copy-rpm-specs,init-security">
  </target>


  <target name="prepare-binary-rpm"
      if="has.rpm.tools"
      depends="ready-to-prepare-binary-rpm">
    <exec executable="tar" failonerror="true"
        dir="${build.rpm.dir}/root/">
      <arg value="cvvf"/>
      <arg file="${smartfrog.rpmfiles.tar}"/>
      <arg value="etc"/>
      <arg value="opt"/>
      <arg value="var"/>
      <arg value="usr"/>
    </exec>
    <!-- now we have a sanity check -->
    <loadresource property="homepage">
      <tarentry archive="${smartfrog.rpmfiles.tar}"
          name="etc/sysconfig/smartfrog"/>
    </loadresource>
    <gzip src="${smartfrog.rpmfiles.tar}"
        destfile="${smartfrog.rpmfiles.tar.gz}"/>
  </target>

  <!--copy rpms, but do not create them-->
  <target name="copy-rpms"
      if="has.rpm.tools"
      depends="init-rpm">
    <copy todir="${dist.rpm.dir}">
      <fileset dir="${rpm.noarch}">
        <include name="*.rpm"/>
      </fileset>
    </copy>
    <copy todir="${upload.dir}" flatten="true">
      <fileset dir="${dist.rpm.dir}">
        <include name="*.rpm"/>
      </fileset>
    </copy>
  </target>

  <target name="ready-to-gzip-rpm" depends="build-rpm,copy-rpms">
    <condition property="can.create.signed.rpms">
      <and>
        <isset property="security.enabled"/>
        <isset property="has.rpm.tools"/>
      </and>
    </condition>
    <echo
        level="verbose">can.create.signed.rpms=${can.create.signed.rpms}
    </echo>
  </target>


  <target name="gzip-rpm"
      depends="ready-to-gzip-rpm"
      if="has.rpm.tools"
      description="create a gzip file containing the RPM files">
    <tar destfile="${rpms.tar}">
      <fileset dir="${dist.rpm.dir}">
        <include name="*.rpm"/>
      </fileset>
    </tar>
    <gzip destfile="${rpms.tar.gz}" src="${rpms.tar}"/>
  </target>

  <target name="ready-to-run-private-rpm"
      depends="ready-to-prepare-binary-rpm,prepare-private-rpm" >

  </target>

  <!--this is not currently how we release artifacts, but it is a way we allow
  third parties to issue their own JAR files, containing their own signed JARs-->
  <target name="private-rpm-ant" depends="ready-to-run-private-rpm"
    description="run a private RPM build for third party signing"
      if="has.rpm.tools">
    <property name="private-target" value="default" />
    <ant antfile="${build.rpm.dir}/build.xml"
      target="${private-target}"
      inheritAll="false" inheritrefs="false"/>
  </target>


  <!--This prepares a custom build.xml file ready for signing and RPM
 creation -->
  <target name="prepare-private-rpm" depends="ready-to-prepare-binary-rpm"
      if="has.rpm.tools">
    <copy todir="${build.rpm.dir}" file="src/ant/build.xml" />
    <!--propagate state down through a series of files-->
    <copy file="${rpm.metadata.dir}/rpm.properties" todir="${build.rpm.dir}"/>
    <propertyfile file="${build.rpm.dir}/rpmbuild.properties">
      <entry key="rpm.release.version" value="${rpm.release.version}"/>
      <entry key="rpm-version" value="${rpm.release.version}"/>
      <entry key="smartfrog.version" value="${smartfrog.version}"/>
    </propertyfile>
  </target>

  <target name="package-private-rpm" depends="ready-to-run-private-rpm"
      if="has.rpm.tools">
    <exec executable="tar" failonerror="true"
      dir="${build.rpm.dir}/">
      <arg value="cvvf"/>
      <arg file="${private-rpm-package.tar}"/>
      <arg value="root"/>
      <arg value="rpm"/>
      <arg value="rpmbuild.properties"/>
      <arg value="rpm.properties"/>
      <arg value="build.xml"/>
    </exec>
    <!-- now we have a sanity check -->
    <loadresource property="rpmbuildfile">
      <tarentry archive="${private-rpm-package.tar}"
        name="build.xml"/>
    </loadresource>
    <loadresource property="smartfrog-file">
      <tarentry archive="${private-rpm-package.tar}"
        name="root/etc/sysconfig/smartfrog"/>
    </loadresource>
    <gzip src="${private-rpm-package.tar}"
      destfile="${private-rpm-package.tar.gz}"/>
    <echo>Created ${private-rpm-package.tar.gz} for private RPMs</echo>
  </target>


  <!-- this tests the scripts, on linux only, of course-->
  <target name="test-scripts" depends="test-sh,test-csh">

  </target>

  <target name="test-sh" depends="copy-scripts">
    <exec executable="sh" failonerror="true">
      <arg value="--verbose"/>
      <arg file="${profile.d}/smartfrog.sh"/>
    </exec>
  </target>

  <target name="test-csh" depends="copy-scripts">

    <exec executable="csh" failonerror="true">
      <arg value="-v"/>
      <arg file="${profile.d}/smartfrog.csh"/>
    </exec>
  </target>


  <target name="expand-rpm-debian" depends="rpm,copy-rpms"
      description="expand the rpm on a debian system, but do not install it">
    <newdir name="rpm.expanded.dir" location="${build.rpm.dir}/expanded"/>
    <exec executable="/usr/bin/alien" failonerror="true"
        dir="${rpm.expanded.dir}">
      <arg value="--generate"/>
      <arg value="--scripts"/>
      <arg file="${target.rpm}"/>
    </exec>
    <echo>RPM expanded into ${rpm.expanded.dir}</echo>
  </target>

  <target name="install-rpm-rhat" depends="rpm,copy-rpms"
      description="install the rpm on a RedHat system">
    <echo>installing RPM ${target.rpm}</echo>
    <exec executable="rpm" failonerror="true">
      <arg value="--upgrade"/>
      <arg value="--vv"/>
      <arg file="${target.rpm}"/>
    </exec>
    <echo>installed RPM ${target.rpm}</echo>
  </target>


  <target name="ready-to-package-maven-artifacts"
      depends="init-maven-artifacts"/>

  <target name="init-maven-artifacts" depends="m2-init">
    <property name="maven.zip.filename"
        value="smartfrog-maven-artifacts-${smartfrog.version}.zip"/>
    <property name="maven.zip"
        location="${dist.dir}/${maven.zip.filename}"/>
    <property name="maven.zip.sha1" location="${maven.zip}.sha1"/>
  </target>

  <!--Build up a zip file containing all the maven artifacts-->
  <target name="package-maven-artifacts"
      depends="ready-to-package-maven-artifacts">
    <zip destfile="${maven.zip}" duplicate="fail">
      <zipfileset prefix="org/smartfrog"
          dir="${m2.publish.repository}/org/smartfrog/">
        <!--core and tasks-->
        <include name="smartfrog/${smartfrog.version}/*"/>
        <include name="sfExamples/${smartfrog.version}/*"/>
        <include name="sfServices/${smartfrog.version}/*"/>
        <include name="sf-tasks/${smartfrog.version}/*"/>
        <!-- testharness for 3rd parties to test their code-->
        <include name="sf-testharness/${smartfrog.version}/*"/>

        <!--components-->
        <include name="sf-ant/${smartfrog.version}/*"/>
        <include name="sf-anubis/${smartfrog.version}/*"/>
        <include name="sf-cloudfarmer/${smartfrog.version}/*"/>
        <include name="sf-csvfiles/${smartfrog.version}/*"/>
        <include name="sf-database/${smartfrog.version}/*"/>
        <include name="sf-dns/${smartfrog.version}/*"/>
        <include name="sf-emailer/${smartfrog.version}/*"/>
        <include name="sf-groovy/${smartfrog.version}/*"/>
        <include name="sf-hadoop/${smartfrog.version}/*"/>
        <include name="sf-jmx/${smartfrog.version}/*"/>
        <include name="sf-loggingservices/${smartfrog.version}/*"/>
        <include name="sf-net/${smartfrog.version}/*"/>
        <include name="sf-quartz/${smartfrog.version}/*"/>
        <include name="sf-rpmtools/${smartfrog.version}/*"/>
        <include name="sf-scripting/${smartfrog.version}/*"/>
        <include name="sf-ssh/${smartfrog.version}/*"/>
        <include name="sf-velocity/${smartfrog.version}/*"/>
        <include name="sf-xml/${smartfrog.version}/*"/>
        <include name="sf-xmpp/${smartfrog.version}/*"/>
        <!--testing-->
        <include name="sf-xunit/${smartfrog.version}/*"/>
        <include name="sf-junit/${smartfrog.version}/*"/>
        <!--web bits-->
        <include name="sf-www/${smartfrog.version}/*"/>
        <include name="sf-tomcat/${smartfrog.version}/*"/>
        <include name="sf-jetty/${smartfrog.version}/*"/>
      </zipfileset>

    </zip>
  </target>


  <target name="expand-maven-artifacts" depends="package-maven-artifacts">
    <property name="expanded.maven.dir" location="${build.dir}/m2/repository"/>
    <mkdir dir="${expanded.maven.dir}"/>
    <unzip src="${maven.zip}" dest="${expanded.maven.dir}"/>
    <echo>Maven artifacts expanded into ${expanded.maven.dir}</echo>
  </target>

  <target name="maven-artifacts" depends="expand-maven-artifacts"/>


  <target name="upload-maven-artifacts"
      depends="init-maven-artifacts,upload-init,ssh-test">
    <fail>
      <condition>
        <not>
          <available file="${maven.zip}"/>
        </not>
      </condition>
      No Maven artifact zip file found at ${maven.zip}
    </fail>
    <ssh-remote command="mkdir -p ${ssh.maven.dir}"/>
    <property name="ssh.maven.path"
        value="${ssh.user}@${ssh.server}:${ssh.maven.dir}"/>
    <scp remoteToDir="${ssh.maven.path}"
        passphrase="${ssh.passphrase}"
        keyfile="${ssh.keyfile}"
        trust="${ssh.trust}"
        verbose="${ssh.verbose}">
      <fileset file="${maven.zip}"/>
    </scp>
    <ssh-remote
        command="unzip -o ${ssh.maven.dir}/${maven.zip.filename} -d ${ssh.maven.dir}"/>
    <ssh-remote command="rm ${ssh.maven.dir}/${maven.zip.filename}"/>
    <ssh-remote command="chmod a+r ${ssh.maven.dir}"/>
  </target>

  <!--
    this target calls the kernel's release process to create some release artifacts
    that we can then redistribute. It is here because core/smartfrog's build process is somewhat standalone
  -->

  <target name="release-kernel" depends="init"
      description="delegate to the core/smartfrog/buildRelease.xml">

    <ant dir="${kernel.dir}"
        antfile="buildRelease.xml"
        inheritall="false"
        inheritrefs="false"
        target="release"
        >
      <property name="release.dir" location="${release.dir}"/>
    </ant>
  </target>

  <!-- targets below derived from ch07 examples of AiA -->
  <target name="check-scp">
    <fail>
      SCP support not found; the scp task needs
      1. ant-jsch.jar
      2. jsch.jar from
      http://www.jcraft.com/jsch/
      <condition>
        <not>
          <typefound name="scp"/>
        </not>
      </condition>
    </fail>
  </target>


  <target name="check-ftp">
    <fail>
      FTP not present: get commons-net from
      http://jakarta.apache.org/commons/net/
      <condition>
        <not>
          <typefound name="ftp"/>
        </not>
      </condition>
    </fail>
  </target>


  <target name="load-server-settings" depends="init">
    <fail unless="server">
      Failed.
      Set the "server" property to the name of a server
      whose connection settings are in a property file under
      ${server.dir}.
    </fail>
    <property name="ssh.propfile"
        location="${server.dir}/${server}.properties"/>
    <loadproperties srcfile="${ssh.propfile}"/>
    <property name="ssh.group" value="smartfrog" />
    <property name="ssh.user.and.group" value="${ssh.user},${ssh.group}" />
    <echo>
      SCP target is ${ssh.server}
      User is ${ssh.user}
      Group is ${ssh.group}
      trust=${ssh.trust}
      keyfile=${ssh.keyfile}
    </echo>
    <presetdef name="ssh-remote">
      <sshexec host="${ssh.server}"
          username="${ssh.user.and.group}"
          passphrase="${ssh.passphrase}"
          trust="${ssh.trust}"
          timeout="6000000"
          keyfile="${ssh.keyfile}"
          />
    </presetdef>
  </target>

  <target name="ready-to-upload-rpms"
      depends="copy-rpms">

  </target>


  <!--iniitialise the upload process by copying all the relevant artifacts and creating
  the upload fileset-->
  <target name="upload-init"
      depends="init,init-rpm,check-scp,load-server-settings,locate-core-artifacts">

    <copy todir="${upload.dir}" file="${izpack.jar}"/>
    <copy todir="${upload.dir}" file="${release.dir}/smartfrog.${smartfrog.version}_all.tar.gz"/>
    <copy todir="${upload.dir}" file="${release.dir}/smartfrog.${smartfrog.version}_all.zip"/>
    <copy todir="${upload.dir}" file="${release.dir}/smartfrog.${smartfrog.version}_dist.tar.gz"/>
    <copy todir="${upload.dir}" file="${release.dir}/smartfrog.${smartfrog.version}_dist.zip"/>
    <fileset id="upload.fileset" dir="${upload.dir}">
      <include name="*.jar"/>
      <include name="*.zip"/>
      <include name="*.gz"/>
    </fileset>
  </target>

  <target name="ssh-create-session" depends="load-server-settings"
    description="Create an SSH terminal session at the far end">
    <ssh-remote command="create"/>
  </target>

  <target name="ssh-test" depends="ssh-ls">
    <echo>ssh appears to be working</echo>
  </target>

  <target name="ssh-ls" depends="ssh-create-session">
    <ssh-remote command="ls"/>
  </target>


  <target name="ssh.live" depends="ssh-test">
  </target>

  <target name="scp-upload" depends="upload-init" if="ssh.enabled">

    <ssh-remote command="mkdir -p ${ssh.dir}"/>
    <property name="ssh.path"
        value="${ssh.user.and.group}@${ssh.server}:${ssh.dir}"/>
    <scp remoteToDir="${ssh.path}"
        passphrase="${ssh.passphrase}"
        keyfile="${ssh.keyfile}"
        trust="${ssh.trust}"
        verbose="${ssh.verbose}">
      <fileset refid="upload.fileset"/>
    </scp>
    <ssh-remote failonerror="false" command="chmod a+r ${ssh.dir}/*.jar"/>
    <ssh-remote failonerror="false" command="chmod a+r ${ssh.dir}/*.zip"/>
    <ssh-remote failonerror="false" command="chmod a+r ${ssh.dir}/*.gz"/>
  </target>

  <target name="ftp-upload" depends="upload-init" if="ftp.enabled">
    <echo>FTP target is ${ftp.server}</echo>
    <ftp server="${ftp.server}"
        userid="${ftp.user}"
        password="${ftp.password}"
        action="mkdir"
        remotedir="${ftp.dir}"/>
    <ftp server="${ftp.server}"
        userid="${ftp.user}"
        password="${ftp.password}"
        action="put"
        verbose="true"
        remotedir="${ftp.dir}">
      <fileset refid="upload.fileset"/>
    </ftp>
  </target>


  <target name="sftp-upload" depends="upload-init" if="sftp.enabled">
    <property name="sftp.server" value="frs.sourceforge.net"/>
    <property name="sftp.user" value="${ssh.user}"/>
    <property name="sftp.group" value="smartfrog"/>
    <property name="sftp.project.dir" value="/home/frs/project/s/sm/smartfrog/"/>
    <property name="sftp.branch.dir" value="development/"/>
    <property name="sftp.release.dir" value="smartfrog-${smartfrog.version}"/>
    <property name="sftp.dir" value="${sftp.project.dir}${sftp.branch.dir}${sftp.release.dir}"/>
    <property name="sftp.path"
        value="${sftp.user}@${sftp.server}:${sftp.dir}"/>
    <echo>SFTP target is ${sftp.server}</echo>
    <scp remoteToDir="${sftp.path}"
        sftp="true"
        password="${sftp.password}"
        trust="${ssh.trust}"
        verbose="${sftp.verbose}">
      <fileset refid="upload.fileset"/>
    </scp>

  </target>

  <target name="can-upload"
      depends="load-server-settings,check-scp"/>

  <target name="dist-upload" depends="can-upload,dist,upload"
      description="create the release artifacts and then upload"/>

  <target name="upload" depends="upload-no-rebuild"
      description="upload; set server property to choose the destination"/>

  <target name="upload-no-rebuild" depends="can-upload,sftp-upload,upload-maven-artifacts"
      description="upload the existing artifacts"/>

  <target name="checksums" depends="ready-to-upload-rpms">

  </target>

  <!--
        ====================================================
            RPM uploads
        ====================================================
  -->

  <target name="rpm-upload-init" depends="check-scp,init,ready-to-upload-rpms">
    <fail unless="rpm.server">
      Failed.
      Set the "rpm.server" property to the name of a server
      whose connection settings are in a property file under
      ${server.dir}.
    </fail>
    <property name="rpm.propfile"
        location="${server.dir}/rpm.${rpm.server}.properties"/>
    <loadproperties srcfile="${rpm.propfile}"/>
    <echo>SCP target is ${rpm.server} at ${rpm.ssh.server}</echo>
    <property name="ssh.command.timeout" value="60000"/>
    <property name="ssh.rpm.command.timeout" value="600000"/>
    <presetdef name="rpmssh">
      <sshexec host="${rpm.ssh.server}"
          username="${rpm.ssh.user}"
          passphrase="${rpm.ssh.passphrase}"
          trust="${rpm.ssh.trust}"
          keyfile="${rpm.ssh.keyfile}"
          timeout="${ssh.command.timeout}"
          />
    </presetdef>
    <presetdef name="rootssh">
      <rpmssh
          username="root"
          timeout="${ssh.rpm.command.timeout}"
          />
    </presetdef>
    <presetdef name="pause">
      <sleep milliseconds="5000"/>
    </presetdef>
    <macrodef name="validate-rpm-result">
      <attribute name="result"/>
      <sequential>
        <echo>
          @{result}
        </echo>
        <fail>
          <condition>
            <contains
                string="@{result}"
                substring="does not exist"/>
          </condition>
          The rpm contains files belonging to an unknown user.
        </fail>
      </sequential>
    </macrodef>

    <fileset id="rpm.upload.fileset" dir="${upload.dir}">
      <include name="*.rpm"/>
    </fileset>
    <echo level="verbose">
      files to upload: ${toString:rpm.upload.fileset}
    </echo>
    <!--override this to -vv for extra diagnostics -->
    <property name="rpm.verbosity" value="-v"/>
    <!--this is the full rpm destination-->
    <property name="rpm.full.ssh.dir"
        value="/home/${rpm.ssh.user}/${rpm.ssh.dir}"/>
    <macrodef name="rpm-uninstall">
      <attribute name="rpms" />
      <attribute name="failonerror" default="true" />
      <sequential >
        <rootssh
            command="rpm --erase --nodeps --allmatches ${rpm.verbosity} @{rpms}"
            failonerror="@{failonerror}"/>
      </sequential>
    </macrodef>
    <!--list of rpms-->


    <property name="rpm.base.list"
        value="smartfrog smartfrog-daemon smartfrog-demo smartfrog-javadocs smartfrog-ant smartfrog-logging "/>
    <property name="rpms.components.list"
        value="smartfrog-anubis smartfrog-csvfiles smartfrog-database smartfrog-jmx smartfrog-networking smartfrog-quartz smartfrog-scripting smartfrog-xml smartfrog-xmpp smartfrog-velocity smartfrog-rpmtools smartfrog-groovy"/>
    <property name="rpms.www.list"
        value="smartfrog-www smartfrog-jetty smartfrog-xunit "/>
    <property name="rpms.testing.list"
        value="smartfrog-junit "/>

    <property name="rpms.core.list"
        value="${rpm.base.list} ${rpms.components.list} ${rpms.www.list} ${rpms.testing.list} "/>

    <property name="rpms.cloud.list"
        value="smartfrog-hadoop smartfrog-cloudfarmer smartfrog-ec2"/>
    <property name="rpms.private.list"
        value=" smartfrog-private-security-keys"/>
    
    <property name="rpms.list"
        value="${rpms.core.list} ${rpms.private.list} ${rpms.cloud.list}"/>


    <!--here are all the signed RPMs that are generated-->


    <!-- add any other rpms that  you depend on here. We will uninstall these before upgrading SmartFrog-->
    <property name="rpms.dependent.list" value=""/>
    <echo>
      remote server is ${rpm.ssh.server}
      remote directory is ${rpm.full.ssh.dir}
      rpms to install: 
      ${rpms.list}
    </echo>

  </target>

  <target name="rpm-upload-check-files-present" depends="rpm-upload-init">
    <fail>
      <condition>
        <resourcecount count="0" refid="rpm.upload.fileset"/>
      </condition>
      There are no RPMs to upload in the directory
      ${upload.dir}
    </fail>
  </target>

  <target name="rpm-upload" depends="rpm-upload-check-files-present">
    <rpmssh command="rm -rf ${rpm.full.ssh.dir}/" failonerror="false"/>
    <rpmssh command="mkdir -p ${rpm.full.ssh.dir}"/>
    <property name="rpm.ssh.path"
        value="${rpm.ssh.user}@${rpm.ssh.server}:${rpm.full.ssh.dir}"/>
    <scp remoteToDir="${rpm.ssh.path}"
        passphrase="${rpm.ssh.passphrase}"
        keyfile="${rpm.ssh.keyfile}"
        trust="${rpm.ssh.trust}"
        verbose="${rpm.ssh.verbose}">
      <fileset refid="rpm.upload.fileset"/>
    </scp>
  </target>

  <target name="rpm-remote-install-core" depends="rpm-upload">
    <rootssh
        command="cd ${rpm.full.ssh.dir}; rpm --upgrade --force ${rpm.verbosity} ${target.rpm.shortname}"
        outputProperty="rpm.result.core"/>
    <validate-rpm-result result="${rpm.result.core}"/>
  </target>

  <target name="rpm-remote-install-daemon" depends="rpm-upload">
    <rootssh
        command="cd ${rpm.full.ssh.dir};rpm --upgrade --force ${rpm.verbosity} smartfrog-daemon-*.rpm"
        outputProperty="rpm.result.daemon"/>
    <validate-rpm-result result="${rpm.result.daemon}"/>
  </target>

  <target name="rpm-remote-install-demo" depends="rpm-upload">
    <rootssh
        command="cd ${rpm.full.ssh.dir};rpm --upgrade --force ${rpm.verbosity} smartfrog-demo-*.rpm"
        outputProperty="rpm.result.demo"/>
    <validate-rpm-result result="${rpm.result.demo}"/>
  </target>

  <target name="rpm-remote-install-all" depends="rpm-upload">
    <rootssh
        command="cd ${rpm.full.ssh.dir};rpm --upgrade --force ${rpm.verbosity} smartfrog-*.rpm"
        outputProperty="rpm.result.all"/>
    <validate-rpm-result result="${rpm.result.all}"/>
  </target>


  <target name="rpm-ready-to-remote-install" depends="rpm-remote-uninstall"/>


  <target name="rpm-remote-install" depends="rpm-remote-install-all"
      description="install the RPMs to the remote server">
  </target>

  <target name="rpm-remote-query" depends="rpm-upload-init">
    <rootssh command="rpm -q ${rpms.list}" failonerror="false"/>
  </target>

  <target name="rpm-remote-uninstall-strict" depends="rpm-upload-init">
    <rootssh command="rpm --erase ${rpm.verbosity} ${rpms.list}"/>
  </target>

  <target name="rpm-remote-uninstall" depends="rpm-upload-init"
      description="A forced uninstall of the RPMs, no dependency checking">
    <rpm-uninstall failonerror="false" rpms="${rpms.private.list}" />
    <rpm-uninstall failonerror="false" rpms="${rpms.cloud.list}" />
    <echo> do not worry if there is an error message about no rpms to uninstall next.</echo>
    <rpm-uninstall failonerror="false" rpms="${rpms.dependent.list}" />
    <rpm-uninstall failonerror="false" rpms="${rpms.core.list}" />
  </target>

  <target name="rpm-remote-test-no-uninstall"
          depends="rpm-remote-version,rpm-remote-initd,rpm-queries-test,rpm-remote-uninstall-strict"
          description="install and verify the RPMs to a remote target"/>

  <target name="rpm-remote-test"
      depends="rpm-remote-test-no-uninstall"
      description="install, verify and uninstall the RPMs to a remote target"/>

  <target name="rpm-remote-version"
      depends="rpm-ready-to-remote-install,rpm-remote-install">
    <rpmssh command="sfVersion"
        outputProperty="rpm.test.results"/>
    <echo>${rpm.test.results}</echo>
    <fail>
      <condition>
        <not>
          <contains string="${rpm.test.results}"
              substring="${smartfrog.version}"/>
        </not>
      </condition>
      Did not find "${smartfrog.version}" in "${rpm.test.results}", which implies
      the installed smartfrog is not what we just built and pushed up.
    </fail>
  </target>

  <target name="rpm-remote-initd-status"
      depends="rpm-ready-to-remote-install,rpm-remote-install"
      description="check that initd parses">
    <rootssh command="${remote-smartfrogd} status"/>
  </target>

  <target name="rpm-remote-initd"
      depends="rpm-ready-to-remote-install,rpm-remote-install"
      description="check that initd parses">
    <rootssh command="${remote-smartfrogd} start"/>
    <pause/>
    <rootssh command="${remote-smartfrogd} status"/>
    <pause/>
    <rootssh command="${remote-smartfrogd} start"/>
    <rootssh command="${remote-smartfrogd} status"/>
    <rootssh command="${remote-smartfrogd} stop"/>
    <rootssh command="${remote-smartfrogd} stop"/>
    <rootssh command="${remote-smartfrogd} restart"/>
    <pause/>
    <rootssh command="${remote-smartfrogd} status"/>
    <rootssh command="${remote-smartfrogd} restart"/>
    <pause/>
    <rootssh command="${remote-smartfrogd} status"/>
    <rootssh command="${remote-smartfrogd} stop"/>
  </target>

  <target name="rpm-queries-test" depends="rpm-remote-install"
      description="check that files and directories belong to the RPMs">
    <expandingcopy file="${rpm.metadata.dir}/rpm-queries.txt"
        todir="${build.dir}"/>
    <!--commandResource="${build.dir}/rpm-queries.txt"-->

    <!-- this sets a property to the query string to check the signedlib if the
    security.enabled flag is set.
    Checking this has been disabled while we experiment with not setting the symlink
    up except in custom signed RPMs.
    -->
    <condition property="secureLibs"
        value="rpm -qf ${rpm.install.dir}/signedLib/smartfrog-${smartfrog.version}.jar;
rpm -qf ${rpm.install.dir}/signedLib/sfServices-${smartfrog.version}.jar;
rpm -qf ${rpm.install.dir}/signedLib/sfExamples-${smartfrog.version}.jar;
rpm -qf ${rpm.install.dir}/signedLib/sf-anubis-${smartfrog.version}.jar;
rpm -qf ${rpm.install.dir}/signedLib/sf-loggingservices-${smartfrog.version}.jar;
rpm -qf ${rpm.install.dir}/signedLib/commons-logging-${commons-logging.version}.jar;
rpm -qf ${rpm.install.dir}/signedLib/log4j-${log4j.version}.jar
"
        else="">
      <isset property="security.enabled"/>
    </condition>

    <rootssh
        failonerror="true"
        command="rpm -qf ${rpm.install.dir} ;
rpm -qf ${rpm.install.dir}/bin ;
rpm -qf ${rpm.install.dir}/lib ;
rpm -qf ${rpm.install.dir}/links ;
rpm -qf ${rpm.install.dir}/links/smartfrog.jar;
rpm -qf ${rpm.install.dir}/links/sfServices.jar;
rpm -qf ${rpm.install.dir}/bin/security ;
rpm -qf ${rpm.install.dir}/bin/metadata ;
rpm -qf ${rpm.log.dir} ;
rpm -qf ${rpm.etc.dir} ;
rpm -qf ${rpm.install.dir}/private;
rpm -qf ${rpm.install.dir}/signedLib;
rpm -qf /etc/profile.d/smartfrog.sh;
rpm -qf /etc/profile.d/smartfrog.csh;
rpm -qf ${rpm.install.dir}/docs;
rpm -qf ${rpm.install.dir}/src;
rpm -qf ${rpm.install.dir}/src.zip ;
rpm -qf ${rpm.install.dir}/lib/sf-ant-${smartfrog.version}.jar;
rpm -qf ${rpm.install.dir}/lib/ant-${apache.ant.version}.jar;
rpm -qf ${rpm.install.dir}/lib/ant-launcher-${apache.ant.version}.jar;
rpm -qf ${rpm.install.dir}/links/sf-ant.jar;
rpm -qf ${rpm.install.dir}/links/ant.jar;
rpm -qf ${rpm.install.dir}/lib/sf-csvfiles-${smartfrog.version}.jar;
rpm -qf ${rpm.install.dir}/lib/opencsv-${opencsv.version}.jar;
rpm -qf ${rpm.install.dir}/links/sf-csvfiles.jar;
rpm -qf ${rpm.install.dir}/links/opencsv.jar;"
        outputProperty="rpm.queries.results"/>
    <!--${secureLibs}"-->

    <fail>
      <condition>
        <or>
          <contains string="${rpm.queries.results}"
              substring="is not owned by any package"/>
          <contains string="${rpm.queries.results}"
              substring="No such file or directory"/>
        </or>
      </condition>
      One of the directories/files in the RPM is not declared as being owned by any RPM.
      This file/directory will not be managed correctly, or have the correct permissions
      on a hardened linux.
      ${rpm.queries.results}
    </fail>

    <sf-conditional>
      <rootssh
          failonerror="true"
          command="rpm -qf ${rpm.javadocs.path}/index.html"/>
    </sf-conditional>


    <rootssh
        failonerror="true"
        command="rpm -qf ${rpm.install.dir}/lib/*.jar"
        outputProperty="rpm.qf.lib.results"/>
    <fail>
      <condition>
          <contains string="${rpm.qf.lib.results}"
                    substring="is not owned by any package"/>
      </condition>
      One of the directories/files in the RPM lib dir is not declared as being owned by any RPM.
      ${rpm.qf.lib.results}
    </fail>
  </target>


  <!--  <target name="rpm-remote-daemon" depends="rpm-remote-install-daemon" >
    <rpmssh command="sfVersion"
        outputProperty="rpm.daemon.results"/>
    <echo>${rpm.test.results}</echo>
    <fail>
      <condition>
        <not>
          <contains string="${rpm.test.results}" substring="${smartfrog.version}" />
        </not>
      </condition>
      Did not find "${smartfrog.version}" in "${rpm.test.results}", which implies
      the installed smartfrog is not what we just built and pushed up.
    </fail>
  </target>-->


  <!--
        ====================================================
            Subversion tagging
        ====================================================
  -->
  <target name="svn-init" depends="init">
    <property name="svn.tag" value="release${smartfrog.version}"/>
    <echo>SVN tag="${svn.tag}"</echo>
    <property name="svn.url"
        value="https://smartfrog.svn.sourceforge.net/svnroot/smartfrog/"/>
    <property name="svn.branch.url" value="${svn.url}tags/${svn.tag}"/>
  </target>

  <!--
  Usage: ant svn-tag -Dsvn.tag=3.11.001beta -Dsvn.revision=HEAD
  Issue a command like
    svn copy https://smartfrog.svn.sourceforge.net/svnroot/smartfrog/trunk -r 4328 \
           https://smartfrog.svn.sourceforge.net/svnroot/smartfrog/tags/release-1.0 \
      -m "release3.11.001beta"

  -->

  <target name="svn-revision-check" depends="svn-init">
    <fail unless="svn.revision">
      The property svn.revision must be set to define which revision to use
    </fail>

  </target>

  <target name="svn-tag" depends="svn-init"
      description="Tag a version of the SVN repository; set svn.revision to the specific revision required">
    <property name="release.manager" value="${user.name} "/>
    <property name="svn.message"
        value="release ${svn.tag} (${smartfrog.version}) from revision ${svn.revision} on ${build.date} by ${release.manager}"/>
    <echo>SVN message="${svn.message}"</echo>
    <echo>issuing SVN command</echo>
    <exec failonerror="true"
        executable="svn">
      <arg value="copy"/>
      <arg value="-r"/>
      <arg value="${svn.revision}"/>
      <arg value="${svn.url}/trunk"/>
      <arg value="${svn.branch.url}"/>
      <arg value="-m"/>
      <arg value="${svn.message}"/>
    </exec>
    <echo>Tag URL: ${svn.branch.url}</echo>
  </target>

  <!--
  Usage ant svn-deletetag -Dsvn.tag=3.11.001beta
  svn delete  https://smartfrog.svn.sourceforge.net/svnroot/smartfrog/tags/something \
               -m "Removing unwanted tag."
  -->
  <target name="svn-deletetag" depends="svn-init"
      description="remove an unwanted tag; set svn.tag to the specific tag name">
    <property name="svn.delete.message"
        value="removing revision ${svn.tag} on ${build.date} by ${user.name}"/>
    <echo>issuing SVN command</echo>
    <exec failonerror="true"
        executable="svn">
      <arg value="delete"/>
      <arg value="${svn.branch.url}"/>
      <arg value="-m"/>
      <arg value="${svn.delete.message}"/>
    </exec>
  </target>

  <!--
  Create the release notes for this release
  -->
  <target name="create-release-notes" depends="svn-revision-check"
      description="
      Create the release notes for this release.
      Requires:
      * svn-revision set for the revision number
      * smartfrog.version set for the release version
      "
      >
    <property name="announcements.dir" location="doc/announcements"/>
    <property name="target.announcement"
        location="${announcements.dir}/release_${smartfrog.version}.txt"/>
    <property name="target.announcement.html"
        location="${announcements.dir}/release_${smartfrog.version}.html"/>

    <expandingcopy tofile="${target.announcement}">
      <fileset file="${announcements.dir}/release-template.txt"/>
    </expandingcopy>
    <expandingcopy tofile="${target.announcement.html}">
      <fileset file="${announcements.dir}/release-template.html"/>
    </expandingcopy>
    <echo>
      created announcement files:
      ${target.announcement}
      ${target.announcement.html}
    </echo>
  </target>

  <!--
  Autorun deployment currently uses NFS, so is LAN-local only.
  -->
  <target name="autorun-init" depends="init-rpm" >
    <newdir name="build.autorun.dir" location="${build.dir}/autorun"/>
    <newdir name="build.autorun.script.dir" location="${build.autorun.dir}/scripts"/>
    <!-- dest dir must exist-->
    <property name="autorun.remote.user" value="root" />
    <property name="autorun.dest.subdir" value="slo" />
    <property name="autorun.remote.mountpoint" value="/mnt/sfcluster" />
    <property name="autorun.local.mountpoint" value="${autorun.remote.mountpoint}" />
    <property name="autorun.dest.dir" location="${autorun.local.mountpoint}/${autorun.dest.subdir}" />
    <property name="autorun.remote.dir" value="${autorun.local.mountpoint}/${autorun.dest.subdir}" />
    <property name="autorun.auto.dest.dir" location="${autorun.dest.dir}/auto" />
    <property name="autorun.rpm.dest.dir" location="${autorun.dest.dir}/auto/rpms" />
    <property name="autorun.script.dest.dir" location="${autorun.dest.dir}/auto/scripts" />

    <property name="autorun.remote.dest.dir" value="${autorun.remote.dir}/auto" />
    <property name="autorun.remote.rpm.dir" value="${autorun.remote.dest.dir}/rpms" />
    <property name="autorun.remote.script.dir" value="${autorun.remote.dest.dir}/scripts" />
    <property name="autorun.mount.path" value="/mnt/auto" />
  </target>
  
  <target name="autorun-copy-scripts"
      depends="autorun-init">
    <expandingcopy todir="${build.autorun.script.dir}">
      <fileset dir="scripts" includes="auto/scripts/*"/>
    </expandingcopy>
  </target>
  <target name="autorun-copy" depends="autorun-copy-scripts" />
  
  <target name="autorun-upload-nfs" depends="autorun-copy-scripts, copy-rpms, check-scp"
      description="Copy the (existing) RPM files and the scripts to to the remote install dir">
    <delete dir="${autorun.auto.dest.dir}" />
    <mkdir dir="${autorun.auto.dest.dir}" />
    <copy todir="${autorun.auto.dest.dir}" >
      <fileset dir="${build.autorun.dir}" includes="**/*" />
      <fileset dir="${dist.rpm.dir}" includes="*.rpm" />
    </copy>
  </target>
  
  <target name="autorun-check-properties" depends="autorun-init">
    <fail unless="autorun.remote.server">Not defined: autorun.remote.server</fail>
    <fail unless="autorun.remote.user">Not defined: autorun.remote.user</fail>
    <fail unless="autorun.remote.password">Not defined: autorun.remote.password</fail>
    <fail unless="autorun.mount.volume">Not defined: autorun.mount.volume
    This is the volume name like /dev/something/vol-1</fail>
    <fail unless="autorun.mount.command">Not defined: autorun.mount.command
    This is the platform-specific command to mount a volume as a device (not the unix mount)
    </fail>
    <echo>
      autorun.remote.dest.dir=${autorun.remote.dest.dir}
      autorun.remote.rpm.dir=${autorun.remote.rpm.dir}
      autorun.remote.script.dir=${autorun.remote.script.dir}
      
    </echo>
  </target>
  
  <target name="autorun.macros" depends="autorun-check-properties">
    <presetdef name="autorun.ssh">
      <sshexec host="${autorun.remote.server}"
          username="${autorun.remote.user}"
          password="${autorun.remote.password}"
          trust="${rpm.ssh.trust}"
          timeout="${ssh.command.timeout}"
          />
    </presetdef>
    <presetdef name="autorun.scp">
      <scp 
          username="${autorun.remote.user}"
          password="${autorun.remote.password}"
          trust="${rpm.ssh.trust}"
          verbose="${rpm.ssh.verbose}">
      </scp>
    </presetdef>
  </target>
  
  <target name="autorun-remote-install" depends="autorun-copy"
      description="ssh to the autorun.remote.server and have it prepare the volume">
  </target>

  <target name="autorun-upload-scripts" depends="autorun-ready-to-upload">
    <autorun.ssh command="mkdir -p ${autorun.remote.script.dir}"/>
    <property name="autorun.script.path"
        value="${autorun.remote.user}@${autorun.remote.server}:${autorun.remote.script.dir}/"/>
    <autorun.scp remoteToDir="${autorun.script.path}">
      <fileset dir="${build.autorun.script.dir}/auto/scripts" includes="*"/>
    </autorun.scp>
  </target>

  <target name="autorun-upload-rpm" depends="autorun-ready-to-upload">
    <autorun.ssh command="rm -rf ${autorun.remote.rpm.dir}/" failonerror="false"/>
    <autorun.ssh command="mkdir -p ${autorun.rpm.dest.dir}"/>
    <property name="autorun.rpm.path"
        value="${autorun.remote.user}@${autorun.remote.server}:${autorun.remote.rpm.dir}/"/>
    <autorun.scp remoteToDir="${autorun.rpm.path}">
      <fileset refid="rpm.upload.fileset"/>
    </autorun.scp>
  </target>


  <target name="autorun-ready-to-upload" depends="autorun-check-properties,autorun.macros,rpm-upload-init,autorun-copy"/>
  
  <target name="autorun-upload" depends="autorun-upload-scripts, autorun-upload-rpm"/>
  
  <target name="autorun-install" depends="autorun-upload" >
    <!-- make a volume accessible -->
    <autorun.ssh command="${autorun.mount.command} ${autorun.mount.volume}" />
    <autorun.ssh command="mount" />
    <autorun.ssh command="mount ${autorun.mount.volume} ${autorun.mount.path}" />
    <autorun.ssh command="mount" />
    <autorun.ssh command="rm -rf ${autorun.mount.path}/rpms/*.rpm" />
    <autorun.ssh command="rm -rf ${autorun.mount.path}/scripts/*.sh" />
    <autorun.ssh command="cp -r ${autorun.remote.dest.dir}/* ${autorun.mount.path}" />
    <autorun.ssh command="chmod a+rx ${autorun.mount.path}/scripts/*.sh" />
    <autorun.ssh command="ls ${autorun.mount.path}/rpms" />
    <autorun.ssh command="ls -l ${autorun.mount.path}/scripts" />
    <autorun.ssh command="cat ${autorun.mount.path}/scripts/install.sh" />
    <autorun.ssh command="umount ${autorun.mount.path}" />
  </target>

  <target name="autorun-umount" depends="autorun-ready-to-upload" 
      description="Unmount the volume">
    <!-- make a volume accessible -->
    <autorun.ssh command="mount" />
    <autorun.ssh command="umount ${autorun.mount.path}" />
    <autorun.ssh command="mount" />
  </target>

</project>