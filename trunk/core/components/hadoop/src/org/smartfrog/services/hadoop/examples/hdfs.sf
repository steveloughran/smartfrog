/* (C) Copyright 2008 Hewlett-Packard Development Company, LP

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

For more information: www.smartfrog.org

*/
/*
#include "/org/smartfrog/services/assertions/components.sf"
#include "/org/smartfrog/services/filesystem/components.sf"
#include "/org/smartfrog/services/hadoop/components/components.sf"
#include "/org/smartfrog/services/hadoop/components/options.sf"
*/


LocalHadoopCompound extends Compound {
  //ordered startup/shutdown of child components
  //sfSyncTerminate true;
  fs.default.name  FS.DEFAULT.NAME;
  nameNodeURL      NAME_NODE_URL;
  dataNodeURL      DATA_NODE_URL ;

  logDir extends TempDir {

  }

  dataDir extends TempDir {

  }

  nameDir extends TempDir {

 }

}

LocalNameNodeCompound extends LocalHadoopCompound {
  description "A name node";

  cluster LAZY namenode;

  namenode extends LightweightNameNode {
    fs.default.name PARENT:fs.default.name;
    dataDir LAZY PARENT:dataDir;
    dataDirectories [dataDir];
    nameDirectory LAZY PARENT:nameDir;
    nameDirectories [nameDirectory];
    logDir LAZY PARENT:logDir;
    dfs.namenode.startup IF (TEST_MODE) THEN ACTION_FORMAT ELSE ACTION_REGULAR FI;
    dfs.http.address nameNodeURL;
    dfs.permissions false;
    minWorkerCount 0;
  }
}

LocalDataNodeCompound extends LocalNameNodeCompound {
  description "A data node bound to a temporary directory";

  localDataDir extends TempDir {

  }


  datanode extends  LightweightDataNode {
    fs.default.name PARENT:fs.default.name;
    dataDirectories [LAZY localDataDir];
    logDir LAZY PARENT:logDir;
    dfs.datanode.address dataNodeURL  ;
  }




}

FilesystemWithActions extends LocalDataNodeCompound {


  clusterActions extends WaitForServiceLive {
    service LAZY PARENT:datanode;
    //sfShouldTerminate false;

    then extends Compound {
      //sfShouldTerminate false;
    }

  }


}



TwoDataNodeCluster extends LocalDataNodeCompound {
  localDataDir2 extends TempDir {

  }

  datanode2 extends datanode {
    dataDirectories [LAZY localDataDir2];
    dfs.datanode.https.address any_port;
  }
}

/**
 * A complete filesystem
 */
LocalFileSystemCompound extends FilesystemWithActions {


}


LocalJobTrackerCompound extends LocalFileSystemCompound {
  description "A cluster with a job tracker";



  jobTracker extends LightweightJobTracker {
    fs.default.name PARENT:ATTRIB fs.default.name;
    dataDir LAZY PARENT:ATTRIB dataDir;
    dataDirectories [dataDir];
    nameDir LAZY PARENT:ATTRIB nameDir;
    nameDirectories [nameDir];
    logDir LAZY PARENT:ATTRIB logDir;
  }
}





LocalTaskTrackerCompound extends LocalJobTrackerCompound {
  description "A cluster with a task tracker";

  taskTracker extends LightweightTaskTracker {
    fs.default.name PARENT:ATTRIB fs.default.name;
    mapred.job.tracker LAZY ATTRIB jobTracker:mapred.job.tracker;
  }
}


LocalClusterCompound extends LocalTaskTrackerCompound {

  description "a full cluster";


}

WaitForHadoopLive extends FailingWaitFor {
  interval CLUSTER_POLL_INTERVAL;
  timeout CLUSTER_STARTUP_TIMEOUT ;
}

/**
 * wait for the FS to come up, but not the job tracker
 */
WaitForFilesystemLive extends WaitForHadoopLive  {
  service TBD;
  jobTrackerLive false;
  message ("WaitForFilesystemLive failed ClusterStatusCondition test " ++ LAZY condition:serviceDescription);
  condition extends ClusterStatusCondition {
    mapred.job.tracker PARENT:service:mapred.job.tracker;
  }
}

/**
 * wait for the FS to come up, and the job tracker
 */
WaitForJobTrackerLive extends WaitForFilesystemLive {
  cluster service;
  message ("WaitForFilesystem or JobTracker Live failed ClusterStatusCondition test"  ++ LAZY condition:serviceDescription);
  jobTrackerLive true;
}


WaitForServiceLive extends WaitForHadoopLive  {
  service TBD;
  serviceName service:name;
  message ("hadoop service " ++ serviceName ++ " not live - state is " ++ LAZY condition:serviceDescription);
  condition extends IsHadoopServiceLive {
    service LAZY PARENT:service;
  }
  else extends Sequence {
    ping extends PingTarget {
      target LAZY PARENT:ATTRIB service;
      sfShouldTerminate true;
    }
    exit extends Terminator {
      description PARENT:ATTRIB message;
      selftype Terminator:ABNORMAL;
    }
  }
}

WaitForWorkersLive extends WaitForHadoopLive  {
  service TBD;
  message ("WaitForWorkersLive not enough workers for this service " ++ LAZY condition:serviceDescription);
  minCount 1;
  condition extends IsWorkerCountGood {
    service LAZY PARENT:service;
    minCount PARENT:minCount;
  }
}

WaitForPortFree extends FailingWaitFor {
  interval CLUSTER_POLL_INTERVAL;
  timeout CLUSTER_SHUTDOWN_TIMEOUT;
  port NameNodeIpcPort;
  address (CheckPortCondition:LOCALHOST  ++ ":" ++ port);
  condition extends Not {
    condition extends CheckPortCondition {
      address PARENT:PARENT:address;
      cluster NULL;
    }
  }
}

AssertLocalPortClosed extends CheckPortCondition {
  sfShouldTerminate true;
  port TBD;
  checkPortOpen false;
  address (CheckPortCondition:LOCALHOST  ++ ":" ++ port);
}

AssertNameNodeIPCClosed extends AssertLocalPortClosed {
  port NameNodeIpcPort;
}

AssertNameNodeHttpClosed extends AssertLocalPortClosed {
  port NameNodeHttpPort;
}

WaitForNameNodeLive extends WaitForServiceLive {
  serviceName "namenode";
}

WaitForDataNodeLive extends WaitForServiceLive {
  serviceName "datanode";
}



/**
Test sequence that checks that when a namenode is shut down, it goes away
*/
NamenodeShutdownSequence extends Sequence {
  namenode TBD;

  waitForNameNode extends WaitForServiceLive {
    serviceName "namenode";
    service LAZY PARENT:namenode;
  }


  //detach and terminate
  terminateNameNode extends Terminator {
    kill LAZY PARENT:namenode;
    detachFirst true;
  }

  //now assert that it is dead
  assertIPCClosed extends AssertNameNodeIPCClosed;
  assertHttpClosed extends AssertNameNodeHttpClosed;
}

FileSystemLiveSequence extends Sequence {

    namenode TBD;
    datanode TBD;
    datanodeCount 1;
    //the cluster for all the tests
    cluster namenode;

    waitForNameNode extends WaitForNameNodeLive {
      service LAZY PARENT:namenode;
    }

    waitForDataNode extends WaitForDataNodeLive {
      service LAZY PARENT:datanode;
    }


}


/**
 * A sequence of operations on a cluster */
FileSystemTestSequence extends FileSystemLiveSequence {



    rootDirExists extends DfsPathExistsWorkflow {
      cluster LAZY PARENT:cluster;
      path "/";
    }

    touch extends DfsCreateFile {
      cluster LAZY PARENT:cluster;
      path "/test-filename";
      text "this is a very small file for Hadoop";
    }

    assertFileExists extends DfsPathExistsWorkflow {
      cluster LAZY PARENT:cluster;
      path touch:path;
    }

  }

  FileCreation extends Compound  {
    cluster TBD;
    dest TBD;

    sfShouldTerminate true;

    sourceFile extends InlineTupleSource {
      data [
        ["one",43],
        ["two", "43"],
        ["one",12]
      ]

    }

    UploadHadoopCsvFile extends TuplesToHadoop {
      cluster LAZY PARENT:cluster;
      source LAZY sourceFile;
      dest testFile;

    }
  }



LocalClusterStatus extends ClusterStatus {
  jobTracker TBD;

  fs.default.name jobTracker:fs.default.name;
  mapred.job.tracker jobTracker;
  hadoop.job.ugi jobTracker:hadoop.job.ugi;
  sfShouldTerminate true;
  supportedFileSystem true;
}



