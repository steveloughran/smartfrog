<project name="rpm" default="rpm">

  <description>
    This is a build file that can be used to create RPMs.


    It uses common.xml and is intended to be imported and used
    in a specific target directory

    - root.dir needs to point to the root of the smartfrog OSS build tree,
      the directory with common.xml in it, and a subdirectory called release

    - It only works on systems with the RPM tools. No RPM-tools, no build.

    - It requires the directory metadata/rpm to exist

    - a file, metadata/rpm/rpm.properties can set custom options that override those
      in core/release/metadata/rpm/rpm.properties

    - you must have a file metadata/rpm/rpm.specs containing the RPM .spec file describing
      the module. It will be copied with property expansion taking place before RPM
      runs aganst it. All properties in the rpm.properties files will be set, and ${smartfrog.version}
      will point to the current smartfrog version.

    - It requires rpm.module.name to be set to the name of the module to build.

    - It requires Ivy to set up the build; you must have a configuration called
      package-${rpm.module.name} in the ivy.xml file, which contains all artifacts
      to be included in the RPM. Do not include libraries published by other RPMs;
      depend on the RPMs instead.

    -The artifact can be published with ivy, if that is what you want. This is left as an exercise
     for the reader.


  </description>

  <!--we are a component -->
  <property name="is.component" value="true"/>


  <!-- override point -->
  <property file="build.properties"/>


  <property name="root.dir" location="../.."/>


  <property name="project.name" value="sf-${ant.project.name}"/>
  <property name="artifact.name" value="${project.name}"/>
  <property name="trace.enabled" value="true"/>
  <property name="ivy.artifact.retrieve.pattern"
      value="[conf]/[artifact]-[revision].[ext]"/>

  <import file="${root.dir}/common.xml" />



  <target name="check-rpm" depends="init">
    <condition property="has.rpm.tools">
      <and>
        <os family="unix"/>
        <available file="rpmbuild" filepath="${env.PATH}"/>
        <not>
          <isset property="rpm.disabled"/>
        </not>
      </and>
    </condition>
    <echo level="verbose">
      has.rpm.tools=${has.rpm.tools}
    </echo>
  </target>

  <target name="require-rpm" depends="check-rpm" unless="has.rpm.tools">
    <fail>
      Step away from the computer now.

      There is no RPM support on this system. If it is a windows box,
      stop trying to build RPMs. If it is a unix/linux system, you
      must have rpmbuild on the path.
    </fail>

  </target>


  <target name="init-rpm" depends="check-rpm,ivy-properties">

    <property name="rpm.metadata.dir" location="metadata/rpm"/>
    <property name="release.dir" location="${root.dir}/release" />
    <property name="release.rpm.metadata.dir" location="${release.dir}/metadata/rpm"/>
    <!-- artifact specific options-->
    <loadproperties srcFile="${rpm.metadata.dir}/rpm.properties"/>

    <!--global options-->
    <loadproperties srcFile="${release.rpm.metadata.dir}/rpm.properties"/>

    <fail unless="rpm.module.name" >
      You must set the property rpm.module.name to the specific name
      of the RPM module that is created. This can be done on the command line
      or in
      ${rpm.metadata.dir}/rpm.properties
    </fail>


    <newdir name="build.rpm.dir" location="${build.dir}/rpm"/>

    <newdir name="rpm.root.dir" location="${build.rpm.dir}/root/"/>

    <newdir name="build.rpm.metadata.dir"
        location="${build.rpm.dir}/metadata"/>
    <newdir name="rpm.image.dir"
        location="${build.rpm.dir}/rpm"/>
    <newdir name="rpm.SOURCES"
        location="${rpm.image.dir}/SOURCES"/>
    <newdir name="rpm.SRPMS"
        location="${rpm.image.dir}/SRPMS"/>
    <newdir name="rpm.SPECS"
        location="${rpm.image.dir}/SPECS"/>
    <newdir name="rpm.BUILD"
        location="${rpm.image.dir}/BUILD"/>
    <newdir name="rpm.RPMS"
        location="${rpm.image.dir}/RPMS"/>
    <newdir name="rpm.noarch"
        location="${rpm.RPMS}/noarch"/>
    <property name="rpmfiles.tar"
        location="${rpm.SOURCES}/smartfrog-${rpm.module.name}-${smartfrog.version}.tar"/>
    <property name="rpmfiles.tar.gz"
        location="${rpmfiles.tar}.gz"/>
    <property name="rpm.suffix"
        value="${smartfrog.version}-${rpm.release.version}.noarch.rpm"/>
    <property name="target.rpm.shortname"
        value="smartfrog-${rpm.module.name}-${rpm.suffix}"/>
    <property name="target.rpm"
        location="${dist.rpm.dir}/${target.rpm.shortname}"/>

    <macrodef name="rpmpackage">
      <attribute name="package"/>
      <sequential>
        <copy todir="${rpm.lib.dir}">
          <fileset file="${ivy.lib.dir}/package-@{package}/*.jar"/>
        </copy>
      </sequential>
    </macrodef>
  </target>

  <target name="copy-rpm-specs" depends="init-rpm">
    <expandingcopy todir="${rpm.SPECS}">
      <fileset dir="${rpm.metadata.dir}" includes="**/*.spec"/>
    </expandingcopy>
  </target>

  <!--
  this is a a wierd target as it patches the macros file rpmmacros with the
  location of the output. With ant-contrib's try/finally tasks we could
  copy and restore this -provided only one build per user was live.
  As it is, unless you set the rpm.skip.macros property, your
  ~/.rpmmacros file gets trashed by Ant.

  Notes
   * the specfile attr is the name of the spec file under SPECS; it is not a full path to the file
   * - is not allowed in the version number
  -->
  <target name="rpmmacros" unless="rpm.skip.macros" depends="init-rpm">
    <echo file="${user.home}/.rpmmacros">
      #GENERATED by rpmmacros task in ${basedir}
      %_topdir ${build.rpm.dir}
    </echo>
  </target>


  <target name="create-file-layout" depends="init-rpm">
    <newdir name="core.install.dir"
        location="${rpm.root.dir}/${rpm.install.dir}"/>
    <newdir name="rpm.bin.dir"
        location="${core.install.dir}/bin"/>
    <newdir name="rpm.lib.dir"
        location="${core.install.dir}/lib"/>
    <newdir name="rpm.links.dir"
        location="${core.install.dir}/links"/>
  </target>


  <!--target to create all components-->
  <target name="rpm-components" depends="create-file-layout">
    <rpmpackage package="${rpm.module.name}"/>
  </target>


  <target name="prepare-rpm" depends="copy-rpm-specs,rpm-components">
    <sf-tar destfile="${rpmfiles.tar}">
      <fileset dir="${build.rpm.dir}/root/" includes="**/*"/>
    </sf-tar>
    <gzip src="${rpmfiles.tar}" destfile="${rpmfiles.tar.gz}"/>
  </target>

  <!-- everything to be done to RPM-->
  <target name="ready-to-rpm" depends="prepare-rpm"/>



  <target name="build-rpm" depends="ready-to-rpm"
      description="create an RPM file of the target library">
    <rpm
        specFile="rpm.spec"
        topDir="${rpm.image.dir}"
        cleanBuildDir="true"
        failOnError="true"/>
    <copy todir="${dist.rpm.dir}">
      <fileset dir="${rpm.noarch}" includes="*.rpm"/>
    </copy>
  </target>

  <!--the entry point: build the rpm-->
  <target name="rpm" depends="build-rpm"
      description="Create the RPMs"/>



  <target name="expand-rpm-debian" depends="rpm"
      description="expand the rpm on a debian system, but do not install it">
    <newdir name="rpm.expanded.dir" location="${build.rpm.dir}/expanded"/>
    <exec executable="/usr/bin/alien" failonerror="true"
        dir="${rpm.expanded.dir}">
      <arg value="--generate"/>
      <arg value="--scripts"/>
      <arg file="${target.rpm}"/>
    </exec>
    <echo>RPM expanded into ${rpm.expanded.dir}</echo>
  </target>

  <target name="install-rpm-rhat" depends="rpm"
      description="install the rpm on a RedHat system">
    <echo>installing RPM ${target.rpm}</echo>
    <exec executable="rpm" failonerror="true">
      <arg value="--upgrade"/>
      <arg value="--vv"/>
      <arg file="${target.rpm}"/>
    </exec>
    <echo>installed RPM ${target.rpm}</echo>
  </target>


</project>