<?xml version="1.0"?>
<project name="common" basedir="."
     xmlns:ivy="antlib:org.apache.ivy.ant"
    >
  <!--
  /** (C) Copyright Hewlett-Packard Development Company, LP

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

  For more information: www.smartfrog.org

  */
  -->
<description>
  This is a build file
  for importing and overriding in subsidiary build files. 

  When ant imports stuff into a project, the value of ".", the project
  directory is that of the importing project, not the imported. But it sets
  a property ant.file.PROJECTNAME to that of the directory of the imported 
  project, where PROJECTNAME is not the filename, but the name of the project
  in the XML declaration.
      
</description>

  <fail>
    <condition>
      <not>
        <available
          classname="org.apache.tools.ant.types.resources.FileResourceIterator"/>
      </not>
    </condition>
    This version of Ant is not supported.
    Please upgrade to Ant1.7 or later and build this project again
  </fail>

  
  
  <!-- ========================================================== -->
  <!-- this is the simple definitions part of the common init -->
  <!-- IT must contain -->
  <!-- NO side effects -->
  <!-- NO requirement for smartfrog jar or similar to exist -->
  <!-- ========================================================== -->


  <target  name="init-java-versions" >
    <!-- work out our java version by introspection -->
    <condition property="java1.5+" >
      <available classname="java.lang.Readable"/>
    </condition>
    <condition property="java1.6+" >
      <available classname="java.net.CookieManager"/>
    </condition>
  </target>

  <target name="init-common-simpledefinitions" depends="init-java-versions">
     <!-- load in the local override -->
    <property file="build.properties"/>
    
    <!-- this is where we work out the base directory    -->
    <!-- only here when running this task raw, to test targets inside -->
    <property name="ant.file.common" location="${ant.file}" />
    <!-- this will be set by the runtime during importation --> 
    <!-- it is how we infer the base directory of the system -->
    <dirname property="antfile.dir" file="${ant.file.common}"/>
    <property name="core.dir" location="${antfile.dir}"/>
    <!--if unset, we work it out here too-->
    <property name="root.dir" location="${core.dir}"/>
    
    <!-- This is to decide the directory structure for the components, and default is false -->
    <property name="is.component" value="true"  />

    <!-- the common.properties file lets you provide a single declaration of
    overrides (like the compiler settings) that apply across
    all projects that use this common file-->
    <property file="${core.dir}/common.properties"/>
    
    <!-- this is an extra set of properties you can use outside SVN trees -->
    <property file="${user.home}/.ant/smartfrog.properties"/>

    <!-- now read in environment settings -->
    <property environment="env" />
    <!-- read these after the env settings -->
    <property file="${core.dir}/build.properties"/>

    <property name="smartfrog.home" location="${core.dir}/smartfrog"/>
    <property name="smartfrog.dist.dir" location="${smartfrog.home}/dist" />
    <property name="smartfrog.dist.lib.dir" location="${smartfrog.dist.dir}/lib"/>
    <property name="smartfrog.components.dir" location="${core.dir}/components"/>
    
    <!-- Compile options for Smartfrog Release -->
    <property name="javac.debug.mode" value="true"/> 
    <property name="javac.deprecation.mode" value="true"/> 
    <property name="javac.debug.level" value="lines,vars,source" />
    <property name="javac.java.version" value="1.5" />
    <property name="javac.include.ant" value="false" />
    <property name="javac.max.memory" value="192m" />

    <!--emma coverage directory-->
    <property name="emma.coverage.dir" location="${core.dir}/build/coverage/emma" />

    <property name="smartfrog.daemon.port" value="3800" />
    <!--use the forking compiler with tuned memory use and profiling diagnostics-->
    <property name="rmic.compiler" value="forking"/>
    <property name="rmic.max.memory" value="512m" />
    <property name="rmic.forking.commandline.extras" value="" />
    <property name="rmic.forking.commandline" 
      value="-J-Xmx${rmic.max.memory} ${rmic.forking.commandline.extras}"/>
    
    <property name="extras.dir"
      location="${core.dir}/extras"/>
    <property name="maven.lib.dir"
      location="${core.dir}/lib"/>
<!--     <property name="maven.url"
      value="http://ibiblio.org/maven2/"/> -->
      
      
      <!-- common directories are relative to the build file loaded-->
    <property name="src.dir" location="src"/>
    <property name="bin.dir" location="bin"/>
    <property name="doc.dir" location="doc"/>
    <property name="lib.dir" location="lib" />
    <property name="test.src.dir" location="test" />
    
    
    <!--generated stuff --> 
    <property name="build.dir" location="build"/>
    <property name="build.classes.dir" location="${build.dir}/classes"/>
    <property name="build.test.dir" location="${build.dir}/test"/>
    <property name="test.dir" location="${build.dir}/test"/>
    <property name="test.classes.dir" location="${build.test.dir}/classes"/>
    <property name="test.data.dir" location="${build.test.dir}/data"/>
    <property name="test.reports.dir" location="${build.test.dir}/reports"/>
    <property name="test.work.dir" location="${build.test.dir}/work" />
    <property name="dist.dir" location="dist"/>
    <property name="dist.lib.dir" location="${dist.dir}/lib"/>
    <property name="dist.doc.dir" location="${dist.dir}/docs"/>
    <property name="dist.jdocs.dir" location="${dist.doc.dir}/jdocs"/>
    <property name="dist.bin.dir" location="${dist.dir}/bin"/>
    <property name="dist.src.dir" location="${dist.dir}/src"/>

    <echo level="verbose">build.classes.dir=${build.classes.dir}
      test.classes.dir=${test.classes.dir}
      dist.dir=${dist.dir}
    </echo>

    <!-- name of a file for runtime properties 
      This is optional and allows users to define extra 
      properties for the smartfrog daemons and other runtimes-->
    <property name="runtime.properties"
      location="${core.dir}/runtime.properties"/>
    <echo level="verbose">Looking at ${runtime.properties} 
      for optional SmartFrog runtime properties</echo>
    <property file="${runtime.properties}" prefix="runtime"/>      
      <!-- turn on the tests. If you dont want this, set one (or both) to false)  in the unit tests-->
    <property name="system.tests" value="false" />
    <property name="unit.tests" value="false" />

    <condition property="system.tests.enabled">
      <istrue value="${system.tests}"/>
    </condition>

    <condition property="unit.tests.enabled">
      <istrue value="${unit.tests}"/>
    </condition>
    

    <!-- build the name of our JAR file from the name of the project.
      override any of this stuff for alternate naming -->
    <property name="jar.prefix" value="sf-" />
    <!-- this is the name of the outer project, not common.xml's name -->
    <property name="project.name" value="${jar.prefix}${ant.project.name}" />

        <!-- information about the ant tasks -->
    <property name="smartfrog.tasks.prefix" value="${jar.prefix}tasks"/>



    <!--this is the version used in artifact dependences inside ivy.xml files-->
    <property name="smartfrog.artifact.version" value="latest.integration" />

    <echo level="verbose">
      sf.build.version=${sf.build.version}
      smartfrog.version=${smartfrog.version}
      smartfrog.artifact.version=${smartfrog.artifact.version}
    </echo>
    
    <tstamp>
      <format property="year" pattern="yyyy"/>
      <format property="build.date" pattern="yyyy-MM-dd HH:mm" />
    </tstamp>
    <property name="Name.Framework" value="SmartFrog"/>
    <property name="Name.System" value="${ant.project.name}"/>
    <property name="Name.Company"
        value="(C) Copyright 1998-${year} Hewlett-Packard Development Company, LP"/>

    <!--copy all proxy settings from the running JVM-->
    <propertyset id="proxy.settings">
      <propertyref prefix="http."/>
      <propertyref prefix="https."/>
      <propertyref prefix="socks."/>
    </propertyset>

  </target>

  <target name="print-proxy-settings" depends="init-common-simpledefinitions">
    <echo>Proxy:
      http:  ${http.proxyHost}:${http.proxyPort}
      https: ${https.proxyHost}:${https.proxyPort}
    </echo>
  </target>

  

<!--
  This is a bit of a legacy; in a pure ivy build we should not need it.
  Instead we'd work out our version from whichever copy of smartfrog we found
  It will go away in the post 3.11 release.
-->
 <target name="bind-to-smartfrog" depends="init-common-simpledefinitions">

    <fileset id="smartfrog.core.fileset"
      dir="${smartfrog.dist.lib.dir}">
      <include name="smartfrog*.jar"/>
      <!-- we DO NOT want smarfrog tasks -->
      <exclude name="${smartfrog.tasks.prefix}*.jar"/>
      <include name="sfExamples*.jar"/>
      <include name="sfServices*.jar"/>
    </fileset>

    <fileset id="smartfrog.lib.fileset"
      dir="${smartfrog.dist.lib.dir}">
      <include name="**/*.jar"/>
      <!-- we DO NOT want smartfrog tasks -->
      <exclude name="${smartfrog.tasks.prefix}*.jar"/>
    </fileset>


    <!-- set up the path of common files in the dist/lib directory -->
    <path id="smartfrog.classpath">
      <fileset refid="smartfrog.lib.fileset" />
    </path>
    <path id="smartfrog.core.classpath">
      <fileset refid="smartfrog.core.fileset" />
    </path>


    <!-- name the resource -->
    <property name="smartfrog.version.property.resource"
      value="org/smartfrog/smartfrog-version.properties"
      />

   <!-- load in our version -->
   <!--<property resource="${smartfrog.version.property.resource}"/>-->
   <property resource="${smartfrog.version.property.resource}"
       classpathref="smartfrog.classpath"/>

    <!-- check for its presence; break the build if missing -->
    <fail unless="sf.build.version">

SmartFrog distribution not found for ${ant.project.name}.
Please create the SmartFrog distribution first.
Alternatively, make sure that this project is configured to locate the distribution
correctly.

smartfrog.classpath=
 ${toString:smartfrog.classpath}

build.sysclasspath=${build.sysclasspath}

java.class.path=
  ${java.class.path}
    </fail>

    <property name="Version" value="${sf.build.version}" />
    <property name="smartfrog.version" value="${sf.build.version}" />
  </target>

  
  <!-- diagnostics: print out the SF versions -->
  <target name="print-sf-version-settings" depends="init">
    <echo>
      sf.build.version=${sf.build.version}
      smartfrog.version=${smartfrog.version}
      smartfrog.artifact.version=${smartfrog.artifact.version}
    </echo>
  </target>
  
  <target name="init-common" depends="bind-to-smartfrog">
    <!-- this is an override point; components call this -component -->
    <property name="jarfile.suffix" value=""/>
    <property name="jarfile.extension" value="jar"/>
    <property name="artifact.name" value="${project.name}" />
    <property name="jarfile.stub" value="${artifact.name}${jarfile.suffix}-${smartfrog.version}" />
    <property name="jarfile.name" value="${jarfile.stub}.${jarfile.extension}"/>

    <property name="target.jar"
      location="${dist.lib.dir}/${jarfile.name}"/>

<!--     name JAR files that tests go into. this is for signing all
    test code (inc deployment descriptors) for deployment onto secure
    boxes
 -->
    <property name="test.jar.name" value="${artifact.name}-test-${smartfrog.version}.jar"/>
    <property name="test.jar"
        location="${dist.lib.dir}/${test.jar.name}" />

   <!--name of javadocs zip file-->
   <property name="javadocs.zip.name" value="${artifact.name}-javadocs-${smartfrog.version}.zip"/>
   <property name="javadocs.zip"
     location="${dist.lib.dir}/${javadocs.zip.name}" />

   <!--info about the documentation zip-->
   <property name="documentation.zip.name"
     value="${artifact.name}-documentation-${smartfrog.version}.zip"/>
   <property name="documentation.zip"
     location="${dist.lib.dir}/${documentation.zip.name}" />


    <!-- standard location for distributed stuff; used when locating
      other things -->
    <property name="dist.lib.dir.relative" value="/dist/lib" />
    <property name="smartfrog.tasks.name" value="${smartfrog.tasks.prefix}-${Version}.jar"/>

    <property name="smartfrog.tasks.lib.dir"
      location="${extras.dir}/ant/${dist.lib.dir.relative}"/>
    <property name="smartfrog.tasks.jar"
      location="${smartfrog.tasks.lib.dir}/${smartfrog.tasks.name}"/>


      <!-- location of junit jar; override it if it is somewhere else-->
    <condition property="junit.jar" value="${ant.home}/lib/junit.jar">
      <available file="${ant.home}/lib/junit.jar" />
    </condition>

    <condition property="junit.jar" value="${ant.home}/lib/junit-3.8.1.jar">
      <available file="${ant.home}/lib/junit-3.8.1.jar" />
    </condition>

    <condition property="junit.jar" value="${ant.home}/lib/junit-3.8.2.jar">
      <available file="${ant.home}/lib/junit-3.8.2.jar"/>
    </condition>

    <condition property="junit.jar" value="${user.home}/.ant/lib/junit-3.8.1.jar">
      <available file="${user.home}/.ant/lib/junit-3.8.1.jar" />
    </condition>
    <condition property="junit.jar" value="${user.home}/.ant/lib/junit-3.8.2.jar">
      <available file="${user.home}/.ant/lib/junit-3.8.2.jar"/>
    </condition>

    <echo level="verbose">system.tests.enabled=${system.tests.enabled}</echo>
    <echo level="verbose">unit.tests.enabled=${unit.tests.enabled}</echo>

    <!--override with other security managers. Options
     smartfrog
     dummy
     sun
     full.classname.
    -->
   <property name="security.manager" value="none" />
    
   <!--preset to copy with ant property expansion (and always overwrite)-->
   <presetdef name="expandingcopy">
     <copy overwrite="true">
       <filterchain>
         <expandproperties/>
       </filterchain>
     </copy>
   </presetdef>

   <!-- a macro to define a property to a new directory, and create the directory-->
   <macrodef name="newdir">
     <attribute name="name"/>
     <attribute name="location"/>
     <sequential>
       <property name="@{name}" location="@{location}" />
       <mkdir dir="@{location}" />
     </sequential>
   </macrodef>

    <!-- define a new javac task with new default options -->
    <presetdef name="sf-javac">
       <javac debug="${javac.debug.mode}"
            fork="true"
            nowarn="true"
            deprecation="${javac.deprecation.mode}"
            source="${javac.java.version}"
            target="${javac.java.version}"
            includeAntRuntime="${javac.include.ant}"
            memoryMaximumSize="${javac.max.memory}"
            includes="**/*.java"
            >	   
       </javac>
    </presetdef>

    <!-- an extension of the previous javac, this with ant classpath included -->
    <presetdef name="sf-javac-with-ant">
       <sf-javac
          includeAntRuntime="true" />
    </presetdef>


    <!-- a new version of the java task that always forks, does not include
    the ant runtime by default, and fails on any error -->
    <presetdef name="sf-java">
      <java
          includeantruntime="false"
          fork="true"
          failonerror="true"
          >
        <jvmarg value="-Demma.coverage.out.file=${emma.coverage.dir}/coverage.emma"/>
        <jvmarg value="-Demma.coverage.out.merge=true"/>
      </java>
    </presetdef>

  <!--
  JAR files are uncompressed, with duplicate classes preserved, meaning
  whatever was there first wins.
  -->
    <presetdef name="sf-jar">
      <jar
        compress="true"
        duplicate="preserve"
        >
       </jar>
    </presetdef>

   <!--
   Tar files are gnu formatted for long files
   -->
   <presetdef name="sf-tar">
     <tar
         longfile="gnu"
         >
     </tar>
   </presetdef>

    <!-- junit wrapper;
      enables forking, turns assertions on in the code,
      and enables XML output.
      Timeout is set to 10 minutes, so we dont ever hang.
      User is still required to
        -specify failure properties
        -provide test or batch test patterns
        -set up the classpath. Dont forget to
        include a reference to smartfrog.classpath to get the core stuff
      -->
    <!-- set to withOutAndErr for more details-->
    <property name="junit.printsummary" value="off" />
    <property name="junit.showoutput" value="true" />
    <!-- set to brief for brief, plain for more -->
    <property name="junit.printformatter" value="plain" />
    <property name="junit.timeout" value="6000000"/>
    <property name="junit.memory" value="512m"/>
    <presetdef name="sf-junit">
      <junit printsummary="${junit.printsummary}"
        fork="true"
        forkmode="once"
        maxmemory="${junit.memory}"
        includeantruntime="true"
        showoutput="true"
        timeout="${junit.timeout}"
        >
        <jvmarg value="-ea"/>
        <jvmarg value="-esa"/>
	    	<jvmarg value="-Demma.coverage.out.file=${emma.coverage.dir}/coverage.emma" />
        <jvmarg value="-Demma.coverage.out.merge=true" />

        <!--copy all proxy settings from the running JVM-->
        <syspropertyset refid="proxy.settings"/>

        <!-- #Tests take system property parameters -->
        <!-- #Formatters for capture and display -->
        <formatter type="xml"/>
        <formatter type="${junit.printformatter}" usefile="false"/>
      </junit>
    </presetdef>

    <!-- testing for a server being present; set a property to set -->

    <presetdef name="sf-daemonfound">
      <condition >
        <socket port="${smartfrog.daemon.port}" server="localhost" />
      </condition>
    </presetdef>

    <!-- wait for 10 seconds for a daemon. Set maxwait to a different
    value for more or less time, timeoutproperty to the name of a property
    to set on failure -->
    <presetdef name="sf-waitfordaemon">
        <waitfor maxwait="10" maxwaitunit="second">
            <socket server="localhost" port="${smartfrog.daemon.port}"/>
        </waitfor>
    </presetdef>

    <!-- reporting wrapper -->
   <macrodef name="sf-junitreport">
     <attribute name="data"/>
     <attribute name="reports"/>
     <sequential>
       <junitreport todir="@{data}">
         <fileset dir="@{data}">
           <include name="TEST-*.xml"/>
         </fileset>
         <report format="frames" todir="@{reports}"/>
       </junitreport>
     </sequential>
   </macrodef>

    <macrodef name="sf-test-report">
      <attribute name="data"/>
      <attribute name="reports"/>
      <attribute name="failed"/>
      <sequential>
        <sf-junitreport data="@{data}" reports="@{reports}" />
        <fail if="@{failed}">Tests failed see:
		@{reports}</fail>
      </sequential>
    </macrodef>

    <!--
    Copy useful files from the source to dest directories. Use this for adding
    extra stuff to the bin directory. By default it pulls in
    **/*.xml,**/*.dtd,**/*.xsd,**/*.sf,**/*.properties;
    override the pattern property to set more
     -->
   <property name="copy.useful.files.pattern"
       value="**/*.ini,**/*.xml,**/*.dtd,**/*.xsd,**/*.sf,**/*.sfcd,**/*.wsdl,**/*.properties,**/*.wsdd,**/*.cdl,**/*.css,**/*.xsl,**/*.png,**/*.jpg,**/*.gif,**/*.policy,**/*.vm,**/*.js,**/*.groovy,**/*.py,**/*.policy"/>
   <macrodef name="copy-useful-files">
     <attribute name="src"/>
     <attribute name="dest"/>
     <attribute name="failonerror" default="false"/>
     <attribute name="pattern"
         default="${copy.useful.files.pattern}"/>
     <sequential>
       <echo level="verbose">copying @{pattern} from @{src} to @{dest}</echo>
       <copy todir="@{dest}" failonerror="@{failonerror}">
         <fileset dir="@{src}"
             includes="@{pattern}"/>
       </copy>
     </sequential>
   </macrodef>

    <!-- rmic configuration -->
    <presetdef name="sf-rmic">
      <rmic
        compiler="${rmic.compiler}"
        verify="true"
        stubversion="1.2" >
        <compilerarg line="${rmic.forking.commandline}" compiler="forking" /> 
      </rmic>
    </presetdef>
  </target>

  <!--set up javadoc-->
  <target name="init-javadoc" depends="init,init-common">

    <property name="javadoc.access" value="protected"/>
    <property name="javadoc.author" value="false"/>
    <property name="javadoc.version" value="true"/>
    <property name="javadoc.use" value="true"/>
    <property name="javadoc.windowtitle" value="${Name.System}"/>
    <property name="javadoc.packages" value="org.smartfrog.*, com.hp.*"/>
    <property name="javadoc.package.name" value="SmartFrog Packages"/>
    <property name="javadoc.package.title" value="SmartFrog Packages"/>
    <property name="javadoc.package.title" value="SmartFrog Packages"/>
    <property name="javadoc.header" value="${Name.System} ${smartfrog.version}"/>
    <property name="javadoc.footer" value="${Name.System} ${smartfrog.version}"/>
    <!--packagenames="${javadoc.packagenames}"-->
    <presetdef name="sf-javadoc" >
      <javadoc
          author="${javadoc.author}"
          version="${javadoc.version}"
          use="${javadoc.use}"
          windowtitle="${javadoc.windowtitle}"
          header="${javadoc.header}"
          footer="${javadoc.footer}"
          doctitle="${Name.System}"
          bottom="${Name.Company}"
          source="${javac.java.version}"
          verbose="false"
          >
      </javadoc>
    </presetdef>

    <!-- turn off javadocs-->
    <condition property="javadoc.disabled">
      <resourcecount when="equal" count="0" >
        <fileset dir="${src.dir}" includes="**/*.java" />
      </resourcecount>
    </condition>
  </target>

  <target name="jdocs" depends="javadoc" description="Generates the API documentation"/>

  <!-- =================================================================== -->
  <!--   Javadocs. uses the compile classpath to set up the javadoc task   -->
  <!-- =================================================================== -->

  <target name="ready-to-javadoc"
          depends="generateversion,declare-classpaths,init-javadoc"
      />

  <target name="javadoc"
          depends="ready-to-javadoc"
          unless="javadoc.disabled"
          >
    <!--  Java Docs for all  -->
    <echo>
    Creating Java Docs for ${javadoc.header} into
    [${dist.jdocs.dir}]
    To skip this stage, set javadoc.disabled=true
    </echo>
    <echo level="verbose">
      language level=${javac.java.version}
      javadoc.packages=${javadoc.packages}
      javadoc.package.title=${javadoc.package.title}
    </echo>
    <fail unless="dist.jdocs.dir">
      We are not properly initialized, as dist.jdocs.dir is undefined.
    </fail>
    <mkdir dir="${dist.jdocs.dir}"/>
    <sf-javadoc
        packagenames="${javadoc.packages}"
        sourcepath="${src.dir}"
        destdir="${dist.jdocs.dir}"
        classpathref="compile.classpath"
        >
      <!--<group title="${javadoc.package.title}" packages="${javadoc.packages}"/>-->
    </sf-javadoc>
  </target>

  <!--Package up the javadocs into their own zip file-->
  <target name="ready-to-package-javadocs" depends="javadoc">
  </target>

  <target name="package-javadocs" depends="ready-to-package-javadocs"
      description="package up all the javadocs">
    <property name="javadocs.zipentry.prefix" value="" />
    <echo >building javadocs into  package "${javadocs.zipentry.prefix}"</echo>
    <zip destfile="${javadocs.zip}" whenempty="create">
      <zipfileset dir="${dist.jdocs.dir}" includes="**/*.*"
          prefix="${javadocs.zipentry.prefix}"/>
    </zip>
  </target>

  <!-- ========================================================== -->
  <!--  set up the documentation-->
  <!-- ========================================================== -->

  <target name="init-documents" depends="init">

  </target>

  <target name="ready-to-package-documents" depends="init-documents">

  </target>

  <target name="package-documents" depends="ready-to-package-documents">
    <zip destfile="${documentation.zip}"
         whenempty="create" duplicate="preserve">
      <!--fileset is set up to work if there are no artifacts-->
      <zipfileset dir="." >
        <include name="doc/**/*.html" />
        <include name="doc/**/*.pdf" />
        <include name="doc/**/*.sx?" />
        <include name="doc/**/*.txt" />
        <include name="doc/**/*.od?" />
      </zipfileset>
    </zip>
  </target>


  <!-- ========================================================== -->
  <!--
    This target is used to set up the standard output for builds and tests and things
   -->
  <!-- ========================================================== -->
  <target name="init-standard-output-dirs" depends="init-common">


  <!--logic to have conditional directory structure for components -->
    <condition property="is.component.enabled">
      <istrue value="${is.component}"/>
    </condition>

    <condition property="is.component.not.enabled">
      <isfalse value="${is.component}"/>
    </condition>

    <mkdir dir="${build.dir}" />
    <mkdir dir="${build.classes.dir}" />


    <mkdir dir="${test.dir}" />
    <mkdir dir="${test.classes.dir}" />
    <mkdir dir="${test.data.dir}" />
    <mkdir dir="${test.reports.dir}" />
    <mkdir dir="${test.work.dir}" />

    <mkdir dir="${dist.dir}"/>
    <mkdir dir="${dist.lib.dir}"/>
    <mkdir dir="${dist.doc.dir}"/>
    <mkdir dir="${dist.bin.dir}"/>
    <mkdir dir="${dist.src.dir}"/>
    <fail unless="dist.jdocs.dir">
      We are not properly initialized, as dist.jdocs.dir is undefined.
    </fail>
    <mkdir dir="${dist.jdocs.dir}"/>
    <mkdir dir="${emma.coverage.dir}" />
  </target>


  <!--  assert that junit exists and fail if it is not there-->
  <target name="assert-junit" depends="init" >
    <fail unless="junit.found">
      <condition>
        <not>
          <available file="${junit.jar}"/>
        </not>
      </condition>
     Not found: ${junit.jar}
    </fail>
  </target>

  <!-- ========================================================== -->
  <!-- this set of classpath targets is done to allow override of -->
  <!-- any stage of the process, with all the dependent classpaths -->
  <!-- being set up right, automatically -->
    <!-- define the common compile classpath, which includes
        smartfrog and our lib dir -->
  <!-- ========================================================== -->

  <!--set up the original redist classpath-->
  <target name="declare-redist.classpath" depends="init" unless="ivy.enabled">
    <path id="redist.classpath">
      <fileset dir=".">
        <include name="lib/**/*.jar"/>
      </fileset>
    </path>
    <echo level="verbose">redist.classpath=${toString:redist.classpath}</echo>
  </target>


  <target name="declare-base.compile.classpath" depends="init"  unless="ivy.enabled">
    <path id="base.compile.classpath">
      <path refid="smartfrog.classpath"/>
    </path>
  </target>

  <target name="declare-compile.classpath"
      depends="declare-base.compile.classpath,declare-redist.classpath"
      unless="ivy.enabled">
    <path id="compile.classpath">
      <path refid="base.compile.classpath"/>
      <path refid="redist.classpath"/>
    </path>
    <echo level="verbose">compile.classpath=${toString:compile.classpath}</echo>
  </target>

  <target name="declare-exec.classpath" depends="declare-compile.classpath" unless="ivy.enabled">
    <path id="exec.classpath">
      <path refid="compile.classpath"/>
      <pathelement location="${build.classes.dir}"/>
    </path>
    <echo level="verbose">exec.classpath=${toString:exec.classpath}</echo>
  </target>

  <target name="declare-tests.compile.classpath"
      depends="declare-exec.classpath,use-smartfrog-testharness" unless="ivy.enabled">
    <path id="tests.compile.classpath">
      <path refid="exec.classpath"/>
      <pathelement location="${junit.jar}"/>
      <pathelement location="${testharness.jar}"/>
    </path>
    <echo level="verbose">tests.compile.classpath=${toString:tests.compile.classpath}</echo>
  </target>

  <target name="declare-tests.run.classpath" depends="declare-tests.compile.classpath"
      unless="ivy.enabled">
    <path id="tests.run.classpath">
      <path refid="tests.compile.classpath"/>
      <pathelement location="${test.classes.dir}"/>
    </path>
    <echo level="verbose">tests.run.classpath=${toString:tests.run.classpath}</echo>
  </target>

  <target name="declare-run.classpath" depends="declare-tests.run.classpath"
      unless="ivy.enabled">
    <path id="run.classpath">
      <path refid="tests.run.classpath"/>
    </path>
  </target>

  <target name="declare-run.classpath-no-tests" depends="declare-exec.classpath"
      unless="ivy.enabled">
    <path id="run.classpath">
      <path refid="exec.classpath"/>
    </path>
  </target>


  <!-- This target explicitly lists all dependencies so that if anyone starts overriding
    declarations, it doesnt matter if they omit dependencies. After this target, all classpaths
    are defined-->
  <target name="declare-classpaths"
    depends=
     "ivy-classpaths,ivy.build.classpath,
     declare-base.compile.classpath,declare-compile.classpath,
     declare-exec.classpath,declare-tests.compile.classpath,
     declare-tests.run.classpath,
     declare-run.classpath-no-tests,declare-run.classpath"/>

  <target name="ivy.build.classpath" depends="maybe-ivy-resolve" if="ivy.enabled">
    <ivy:cachepath pathid="build.classpath" conf="build" />
    <echo level="verbose">build.classpath=${toString:build.classpath}</echo>
  </target>

  <target name="ivy.compile.classpath" depends="maybe-ivy-resolve" if="ivy.enabled">
    <ivy:cachepath pathid="compile.classpath" conf="compile" />
    <echo level="verbose">compile.classpath=${toString:compile.classpath}</echo>
  </target>

  <target name="ivy.run.classpath" depends="maybe-ivy-resolve"  if="ivy.enabled">
    <ivy:cachepath pathid="run.classpath" conf="daemon" />
    <echo level="verbose">run.classpath=${toString:run.classpath}</echo>
  </target>

  <target name="ivy.exec.classpath" depends="ivy.compile.classpath"  if="ivy.enabled">
    <ivy:cachepath pathid="ivy.test.classpath" conf="test" />
    <path id="exec.classpath">
      <pathelement location="${target.jar}"/>
      <path refid="ivy.test.classpath"/>
    </path>
    <echo level="verbose">exec.classpath=${toString:exec.classpath}</echo>
  </target>

  <target name="ivy.tests.compile.classpath" depends="ivy.exec.classpath"  if="ivy.enabled">
    <path id="tests.compile.classpath">
      <path refid="exec.classpath"/>
    </path>
    <echo level="verbose">tests.compile.classpath=${tests.compile.classpath}</echo>
  </target>

  <target name="ivy.tests.run.classpath" depends="ivy.tests.compile.classpath"  if="ivy.enabled">
    <path id="tests.run.classpath">
      <pathelement location="${test.jar}"/>
      <path refid="tests.compile.classpath"/>
    </path>
    <echo level="verbose">tests.run.classpath=${toString:tests.run.classpath}</echo>
  </target>

  <target name="ivy.redist.classpath" depends="maybe-ivy-resolve" if="ivy.enabled">
    <ivy:cachepath pathid="redist.classpath" conf="redist"/>
    <echo level="verbose">redist.classpath=${toString:redist.classpath}</echo>
  </target>

  <target name="ivy-classpaths"
      depends="ivy.compile.classpath,ivy.exec.classpath,ivy.run.classpath,ivy.tests.run.classpath,ivy.redist.classpath"/>


  <!-- ========================================================== -->
  <!-- cleanup target -->
  <!-- This MUST work even if clean has already been run; test -->
  <!-- changes with ant clean clean -->
  <!-- ========================================================== -->
  <target name="clean" description="clean up build and dist"
      depends="init-common-simpledefinitions">
    <delete dir="${build.dir}" />
    <delete dir="${dist.dir}"  />
    <delete file="version.properties"/>
  </target>

  <!-- ========================================================== -->
  <!-- probe for the smartfrog binaries existing in the dist dir. -->
  <!-- and exit if they are not -->
  <!-- ========================================================== -->

  <target name="assert-smartfrog"  depends="init-common,declare-classpaths"
    description="verify smartfrog is present, fail if not">
    <fail >
      <condition>
        <not>
          <available
              classname="org.smartfrog.SFSystem"
              classpathref="smartfrog.classpath"
              />
        </not>
      </condition>
      Smartfrog entry point not found in
      ${toString:smartfrog.classpath}
    </fail>
  </target>

  <!-- ========================================================== -->
  <!-- left in for backwards naming compatibility -->
  <!-- ========================================================== -->

  <target name="verify-smartfrog"  depends="assert-smartfrog" />

  <!--
  this is the pre-ivy way of setting up the ant tasks...from
  ivy you are expected to use ivy itself to find sf-tasks.jar
  -->
  <target name="use-smartfrog-tasks-classic" depends="init-common"
      unless="ivy.enabled"
      description="declare the classpath and imports for the smartfrog tasks">
    <path id="smartfrog.tasks.classpath">
      <path refid="smartfrog.core.classpath"/>
      <pathelement location="${smartfrog.tasks.jar}"/>
    </path>
  </target>

  <target name="use-smartfrog-tasks-ivy" depends="ivy.build.classpath"
      if="ivy.enabled"
      description="declare the classpath and imports for the smartfrog tasks">
    <path id="smartfrog.tasks.classpath">
      <path refid="build.classpath"/>
    </path>
  </target>


  <!--
    SFOS-167 shows how Ant holds on to task definitions for a long time, longer than we can
    sustain on a windows client build. To reduce Permanent Generation heap space, we are
    not loading the tasks if they are already present
  -->
  <target name="probe-for-smartfrog-tasks" >
    <condition property="sf.tasks.loaded">
      <typefound name="sf-startdaemon"/>
    </condition>
  </target>
  
  <!-- ========================================================== -->
  <!-- probe for tasks and use them if they are found; fail if not -->
  <!-- ========================================================== -->
  <target name="use-smartfrog-tasks"
      depends="use-smartfrog-tasks-classic,use-smartfrog-tasks-ivy,probe-for-smartfrog-tasks"
      unless="sf.tasks.loaded"
      description="declare the classpath and imports for the smartfrog tasks">
    <available
      classname="org.smartfrog.tools.ant.Parse"
      classpathref="smartfrog.tasks.classpath"
      property="sfTasks.present"/>
    <echo level="verbose">
Loading tasks from
${toString:smartfrog.tasks.classpath}
    </echo>
    <fail unless="sfTasks.present">
Smartfrog tasks not found in the classpath. Are the dependencies in ivy.xml right?
smartfrog.tasks.classpath=
"${toString:smartfrog.tasks.classpath}"
    </fail>
    <typedef
      resource="org/smartfrog/tools/ant/tasks.properties"
      classpathref="smartfrog.tasks.classpath"
      />
  </target>

  <!-- ========================================================== -->
  <!-- declare presets and macrodefs to enhance the tasks better
    for our needs -->
  <!-- ========================================================== -->
  <target name="declare-extended-smartfrog-tasks"
      depends="init,use-smartfrog-tasks,declare-classpaths">
    <presetdef name="sf-startdaemon-debug">
      <sf-startdaemon classpathref="run.classpath"
        logStackTraces="true" spawn="true"
        securityManager="${security.manager}"
        dir="${build.test.dir}"
          >
          <!-- assertions are enabled -->
        <assertions enableSystemAssertions="true">
          <enable/>
        </assertions>
        <!--copy all proxy settings from the running JVM-->
        <syspropertyset refid="proxy.settings"/>
          <!-- load in a property file if it is present -->
        <propertyfile file="${runtime.properties}" optional="true"/>
      </sf-startdaemon>
    </presetdef>

    <presetdef name="sf-gui-debug">
      <sf-gui classpathref="tests.run.classpath"
        logStackTraces="true" spawn="true">
          <!-- assertions are enabled -->
        <assertions enableSystemAssertions="true">
          <enable/>
        </assertions>
          <!-- load in a property file if it is present -->
        <propertyfile file="${runtime.properties}" optional="true"/>
      </sf-gui>
    </presetdef>

    <presetdef name="sf-console-debug">
      <sf-management-console classpathref="tests.run.classpath"
        logStackTraces="true" >
          <!-- assertions are enabled -->
        <assertions enableSystemAssertions="true">
          <enable/>
        </assertions>
          <!-- load in a property file if it is present -->
        <propertyfile file="${runtime.properties}" optional="true"/>
      </sf-management-console>
    </presetdef>

  </target>

  <!-- ========================================================== -->
  <!-- location of testharness; create a relevant path -->
  <!-- ========================================================== -->

  <target name="use-smartfrog-testharness" depends="init-common" >
        <!-- information about the test harness -->
      <!-- needs to be in sync w/ testharness/build.xml -->
      <!-- TODO :use maven lib to sync -->
    <property name="testharness.dir"
      location="${core.dir}/testharness" />
    <property name="testharness.jar.name"
      value="sf-testharness-${Version}.jar" />
    <property name="testharness.jar"
        location="${testharness.dir}/${dist.lib.dir.relative}/${testharness.jar.name}" />
    <available file="${testharness.jar}"
      property="testharness.present" />
  </target>

  <!-- ========================================================== -->
  <!-- verify that the testharness is present-->
  <!-- ========================================================== -->
  <target name="assert-smartfrog-testharness" depends="use-smartfrog-testharness" >
    <fail unless="testharness.present">
      Smartfrog testharness not found at
      ${testharness.jar}
    </fail>
  </target>

  <!-- ========================================================== -->
  <!--  look for a local daemon. Sets the property  local.daemon.running if
    one is listening on port 3800-->
  <!-- ========================================================== -->
  <target name="probe-local-daemon" depends="init-common">
    <sf-daemonfound property="local.daemon.running" />
  </target>

  <!-- ========================================================== -->
  <!-- conditionally start the daemon if one was not found already-->
  <!-- ========================================================== -->
  <target name="start-daemon-if-needed"
    depends="declare-extended-smartfrog-tasks,probe-local-daemon"
    unless="local.daemon.running">
      <sf-startdaemon-debug  />
  </target>

  <!-- ========================================================== -->
  <!-- start the daemon in the foreground                         -->
  <!-- ========================================================== -->
  <target name="start-daemon-fg"
    description="start a daemon in the foreground"
    depends="declare-extended-smartfrog-tasks"
    >
      <sf-startdaemon-debug  spawn="false" timeout="-1"/>
  </target>

  <!-- ========================================================== -->
  <!-- conditionally start the GUI if one was not found already-->
  <!-- ========================================================== -->
  <target name="start-gui"
    depends="declare-extended-smartfrog-tasks" >
      <sf-gui-debug  />
  </target>


  <!-- ========================================================== -->
  <!-- Start the console -->
  <!-- ========================================================== -->
  <target name="start-console"
    description="start a console"
    depends="declare-extended-smartfrog-tasks" >
      <sf-console-debug  timeout="-1"/>
  </target>

  <!-- ========================================================== -->
  <!-- conditionally start the daemon if one was not found already-->
  <!-- and do not complain if it could not start (or execution timed out) -->
  <!-- ========================================================== -->
  <target name="start-daemon-if-needed-no-failonerror"
    depends="declare-extended-smartfrog-tasks,probe-local-daemon"
    unless="local.daemon.running">
      <sf-startdaemon-debug failonerror="false"/>
  </target>


  <!-- ========================================================== -->
  <!-- this is the counterpoint to start-daemon-if-needed
    if the probe did not find a daemon, then we shut down any daemon
    that we created.-->
  <!-- ========================================================== -->
  <target name="stop-daemon-if-started"
    depends="use-smartfrog-tasks"
    unless="local.daemon.running" >
    <sf-stopdaemon failonerror="false" />
  </target>

  <!-- ========================================================== -->
  <!-- public startup operation -->
  <!-- ========================================================== -->
  <target name="startup"
    depends="start-daemon-if-needed"
    description="start a local daemon">
  </target>

  
  <!-- ========================================================== -->
  <!-- public startup operation; uses the name that netbeans expects -->
  <!-- ========================================================== -->
  <target name="run"
    depends="start-daemon-if-needed"
    description="start a local daemon">
  </target>

  
  <!-- ========================================================== -->
  <!-- always shutdown a local daemon. keep going if one is not running -->
  <!-- ========================================================== -->
  <target name="shutdown"
    depends="use-smartfrog-tasks"
    description="shut down a local smartfrog daemon">
    <sf-stopdaemon timeout="60000" failonerror="false" />
  </target>


  <!-- ========================================================== -->
  <!-- this is an override point -->
  <!-- ========================================================== -->
  <target name="init" depends="init-standard-output-dirs"/>


  <!-- ========================================================== -->
  <!-- this is here to set up the depends graph properly for
       overriden verify-prerequisites targets -->
  <!-- ========================================================== -->

  <target name="pre-verify-prerequisites" depends="init,declare-classpaths">
  </target>

  <!-- ========================================================== -->
  <!-- this is an override point -->
  <!-- set the verified.ok property if everything needed is present -->
  <!-- Do Not Fail. This test is used to control conditional builds -->
  <!-- NB, set property verify.fail.message to something meaningful
       for better diagnostic messages on failure (see assert-prerequisites)
       -->
  <!-- ========================================================== -->
  <target name="verify-prerequisites" depends="pre-verify-prerequisites">
    <property name="verified.ok" value="true"/>
  </target>

  <!-- ========================================================== -->
  <!-- entry point for the components/build.xml delegation;
       probe for needed libraries, and skip the operation if they
       are missing -->
  <!-- ========================================================== -->

  <target name="maybe-dist" depends="verify-prerequisites" if="verified.ok">
    <antcall target="dist" />
  </target>

  <!-- ========================================================== -->
  <!-- entry point for the components/build.xml delegation;
       default implementation runs batch-test if the
       prerequisites are met -->
  <!-- ========================================================== -->
  <target name="maybe-test" depends="verify-prerequisites" if="verified.ok">
    <antcall target="batch-test" />
  </target>

  <!-- ========================================================== -->
  <!-- entry point for the components/build.xml delegation;
       probe for needed libraries, and skip the operation if they
       are missing -->
  <!-- ========================================================== -->
  <target name="maybe-install" depends="verify-prerequisites" if="verified.ok">
    <antcall target="install" />
  </target>

  <!-- ========================================================== -->
  <!-- assert the prerequisites were found.
    Use this before you compile for a more meaningful failure message
    preset the property verify.fail.message for better diagnostics
    -->
  <!-- ========================================================== -->
  <target name="assert-prerequisites" depends="verify-prerequisites"
    unless="verified.ok">
    <property name="verify.fail.message"
      value="The prerequisite classes for this project were not found"/>
    <fail>${verify.fail.message}</fail>
  </target>


  <!-- ========================================================== -->
  <!-- this is an override point -->
  <!-- it does nothing but declare all the dependencies for compilation -->
  <!-- anything that overrides compile can declare a dependency on this -->
  <!-- target to get its dependencies right -->
  <!-- ========================================================== -->
  <target name="pre-compile"
      depends="init,declare-classpaths,assert-smartfrog,assert-prerequisites">
  </target>

  <!-- ========================================================== -->
  <!-- this is an override point -->
  <!-- compile everything, copy useful files over-->
  <!-- ========================================================== -->
  <target name="compile" depends="pre-compile">
	    <!-- to get the classpath in a printable form -->
	  <pathconvert pathsep="${line.separator}|   |-- "  
	               property="echo.compile.classpath" 
	               refid="compile.classpath">
	  </pathconvert>
      <echo message=" --------------------------------------------------------"/>
	    <echo message=" Project: ${ant.project.name}"/>
	    <echo message=" Ant file: ${ant.file}"/>
		<echo message=" IvySettings.xml: ${ivysettings.xml}"/>		
		<echo message=" core.dir: ${core.dir}"/>		
		<echo message=" root.dir: ${root.dir}"/>		
        <echo message=" Java: ${java.version} ${java.vendor} / Javac: ${javac.java.version}"/>
        <echo message=" Compile Class Path= ${line.separator}|   |-- ${echo.compile.classpath}"/>
	    <echo message=" --------------------------------------------------------"/>
      <depend srcdir="${src.dir}"
          destdir="${build.classes.dir}"
          cache="${build.dir}/depends"
          closure="yes"/>
      <sf-javac
          classpathref="compile.classpath"
          srcdir="${src.dir}"
          destdir="${build.classes.dir}"
          />
      <copy-useful-files src="${src.dir}" dest="${build.classes.dir}"/>
  </target>

  <target name="ready-to-rmi" depends="compile" />

  <!-- ========================================================== -->
  <!-- this is an override point -->
  <!-- RMI compile by looking for all remote classes in the
       compiled project-->
  <!-- ========================================================== -->
  
    <!-- =================================================================== -->
  <!-- RMI compile by looking for all remote classes in the
       compiled project-->
  <!-- =================================================================== -->
    
  <target name="rmi" depends="ready-to-rmi" description="create the RMI classes">
      <!-- to get the classpath in a printable form -->
	  <pathconvert pathsep="${line.separator}|   |-- "  
	               property="echo.compile.classpath" 
	               refid="compile.classpath">
	  </pathconvert> 
	 <echo> ---------------------------------------
	    RMIC for project: ${ant.project.name}"
        base="${build.classes.dir}"
        verify="true"
        compiler="${rmic.compiler}"
        compilerarg line="${rmic.forking.commandline}"
        compiler="forking"
        Compile Class Path= ${line.separator}|   |-- ${echo.compile.classpath}
 ---------------------------------------
      </echo> 
      <sf-rmic
          base="${build.classes.dir}"
          verify="true"
          compiler="${rmic.compiler}"
          includes="**/*.class">
        <classpath refid="compile.classpath"/>
      </sf-rmic>
  </target>

  <!-- another name for rmi -->
  <target name="compile-RMI" depends="rmi" />

  <!-- ========================================================== -->
  <!-- this is an override point -->
  <!-- all things that have to be in place before tests are compiled -->
  <!-- ========================================================== -->
  <target name="ready-to-compile-tests"
    depends="package,assert-smartfrog-testharness,declare-classpaths,test-for-test-sources"
    />

  <!--stops tests being compiled if there are no tests-->
  <target name="test-for-test-sources" depends="init">
    <available file="${test.src.dir}"
      type="dir"
      property="test.dir.found"/>
  </target>

  <!-- ========================================================== -->
  <!-- this is an override point -->
  <!-- compile everything, copy useful files over-->
  <!-- ========================================================== -->
  <target name="compile-tests"
      depends="ready-to-compile-tests"
      if="test.dir.found">
      <depend
          srcdir="${test.src.dir}"
          destdir="${test.classes.dir}"
          cache="${build.test.dir}/depends"
          closure="yes"/>
      <sf-javac
          srcdir="${test.src.dir}"
          destdir="${test.classes.dir}"
          classpathref="tests.compile.classpath"
          />
      <copy-useful-files src="${test.src.dir}" dest="${test.classes.dir}"/>
  </target>


  <target name="ready-to-rmi-tests"  depends="compile-tests"/>

  <!-- ========================================================== -->
  <!-- this is an override point -->
  <!-- RMI compile by looking for all remote classes in the
       compiled project-->
  <!-- ========================================================== -->
  <target name="rmi-tests" depends="ready-to-rmi-tests"
      description="create the RMI classes"
      if="test.dir.found">
	    <!-- to get the classpath in a printable form -->
	  <pathconvert pathsep="${line.separator}|   |-- "  
	               property="echo.test.compile.classpath" 
	               refid="tests.compile.classpath">
	  </pathconvert>
	 <echo> ---------------------------------------
	    RMIC TESTS for project: ${ant.project.name}"
        base="${test.classes.dir}"
        verify="true"
        compiler="${rmic.compiler}"
        compilerarg line="${rmic.forking.commandline}"
        compiler="forking"
        Compile Class Path= ${line.separator}|   |-- ${echo.test.compile.classpath}		
 ---------------------------------------
      </echo> 	  
    <sf-rmic
        base="${test.classes.dir}"
        verify="true"
        compiler="${rmic.compiler}"
        includes="**/*.class">
      <classpath refid="tests.compile.classpath"/>
    </sf-rmic>
  </target>



  <target name="ready-to-jar" depends="rmi"/>

  <!--
  component only logic to create a versioned jar name.
  this is simpler now we read it from the source file
  -->
  <target name="generateversion" depends="generate-versioned-jar"/>

  <target name="generate-versioned-jar" if="is.component.enabled" depends="ready-to-jar">
    <property name="jar.name"
              value="${artifact.name}${jarfile.suffix}-${smartfrog.version}.${jarfile.extension}"/>
    <property name="target.jar"
        location="${dist.lib.dir}/${jar.name}"/>
    <sf-jar destfile="${target.jar}"
        basedir="${build.classes.dir}"
        includes="**/*"/>
    <echo level="verbose">created package ${target.jar}</echo>

    <!-- save everything to a file -->
    <!-- keep this in sync w/ common.xml's declaration -->
    <property name="sf.version.file" location="${dist.dir}/version.properties"/>
    <propertyfile
        file="${sf.version.file}"
        comment="This is machine generated. Do Not Edit!">
      <entry key="sf.build.date" type="date" value="now"/>
      <entry  key="sf.build.version" value = "${sf.build.version}"/>
      <entry key="sf.majorRelease" value="${sf.majorRelease}"/>
      <entry key="sf.minorRelease" value="${sf.minorRelease}"/>
      <entry key="sf.build" value="${sf.build}"/>
      <entry key="sf.status" value="${sf.status}"/>
    </propertyfile>
    <echo level="verbose">version=${sf.build.version}</echo>
    <!--property name="Version" value="${sfversion}"/-->

  </target>

  <!--
    bypass all the self-referential stuff here.
  -->
  <target name="createjar" depends="generate-versioned-jar" if="is.component.not.enabled">
    <sf-jar destfile="${target.jar}"
             basedir="${build.classes.dir}"
             includes="**/*"/>
     <echo level="verbose">created package ${target.jar}</echo>
  </target>

  <!-- ========================================================== -->
  <!-- this is an override point -->
  <!-- create the JAR ${target.jar}-->
  <!-- ========================================================== -->
  <target name="package" depends="createjar"
    description="create the JAR files">
   </target>

  <target name="packaged" depends="package"
      description="create the JAR files">
  </target>

  <!--unzip the the target JAR-->
  <target name="unzip-target" depends="packaged">
    <property name="target.exploded" location="${build.dir}/exploded" />
    <unzip src="${target.jar}" dest="${target.exploded}"/>
  </target>


  <target name="ready-to-package-tests" depends="rmi-tests" />
  
  <!-- ========================================================== -->
  <!-- this is an override point -->
  <!-- create the test jar ${test.jar}-->
  <!-- ========================================================== -->
  <target name="package-tests" depends="ready-to-package-tests"
      description="create the JAR file for the tests">
    <!-- the JAR is created, even when empty, as it may be used downstream as an empty artifact-->
      <sf-jar destfile="${test.jar}"
        basedir="${test.classes.dir}"
        whenmanifestonly="create"
        includes="**/*"/>
      <echo level="verbose">created package ${test.jar}</echo>
  </target>

  <!-- ========================================================== -->
  <!-- this is an override point -->
  <!-- everything for distribution -->
  <!-- ========================================================== -->
  <target name="dist" depends="packaged"
    description="create a distribution">
  </target>

  <target name="all" description="build, test and publish the code"
      depends="test,published,dist">
  </target>

  <!-- =================================================================== -->
  <!-- a clean distribution                                               -->
  <!-- =================================================================== -->
  <target name="fromclean" depends="clean,dist"
      description="create a clean distribution"/>


  <!-- ========================================================== -->
  <!-- this is an override point -->
  <!-- copy all dependencies -->
  <!-- ========================================================== -->
  <target name="install-dependencies" depends="package,declare-classpaths">
    <mkdir dir="${smartfrog.dist.lib.dir}"/>
    <!--pull in all runtime dependencies-->
    <copypath destdir="${smartfrog.dist.lib.dir}"
      pathref="redist.classpath">
      <flattenmapper/>
    </copypath>
  </target>

  <!-- ========================================================== -->
  <!-- this is an override point -->
  <!-- install the jar, if we know where to put it -->
  <!-- ========================================================== -->
  <target name="install" depends="package,install-dependencies"
      if="smartfrog.dist.lib.dir"
      description="copy the jar file to the SmartFrog distribution directory">
    <copy file="${target.jar}" todir="${smartfrog.dist.lib.dir}"/>
  </target>

  <!-- ========================================================== -->
  <!-- this is an override point -->
  <!-- generate test reports and break on failure-->
  <!-- ========================================================== -->

  <target name="reports" depends="init"
    description="generate the test reports" >
    <sf-test-report data="${test.data.dir}"
      reports="${test.reports.dir}"
      failed="test.failed"/>
    <echo>reports in ${test.reports.dir}</echo>
  </target>

  <!-- ========================================================== -->
  <!-- this is an override point -->
  <!-- generate test reports; ignore failure results-->
  <!-- ========================================================== -->

  <target name="reports-no-failure" depends="init"
    description="generate the test reports" >
    <sf-test-report data="${test.data.dir}"
      reports="${test.reports.dir}"
      failed="a.property.that.had.better.never.be.set"/>
    <echo>reports in ${test.reports.dir}</echo>
  </target>

  <!-- ========================================================== -->
  <!-- set up any properties for deployment -->
  <!-- ========================================================== -->
  <target name="init-deploy-properties" depends="init">
    <property name="deploy.host" value="localhost"/>
    <property name="deploy.timeout" value="30000"/>
    <property name="application.name" value="${project.name}"/>
  </target>

  <!-- ========================================================== -->
  <!-- set the property codebase - this can be overridden-->
  <!-- ========================================================== -->
  <target name="init-codebase" depends="declare-classpaths,init-deploy-properties,package-tests"
      description="set up the codebase property">
    <makeurl property="codebase" validate="false">
      <path refid="tests.run.classpath"/>
    </makeurl>
    <echo level="verbose">
      deploying to ${deploy.host}
      codebase=${codebase}</echo>
  </target>


  <!-- ========================================================== -->
  <!-- get the build into the state where the application is ready-->
  <!-- ========================================================== -->

  <target name="ready-to-deploy" depends="init-codebase,init-deploy-properties,ready-to-test,define-deploy-preset">

  </target>

  <target name="define-deploy-preset" depends="ready-to-test,init-codebase,init-deploy-properties">
    <presetdef name="deploy" >
      <sf-deploy classpathref="tests.run.classpath"
          logStackTraces="true"
          host="${deploy.host}"
          timeout="${deploy.timeout}"
          >
        <codebase url="${codebase}"/>
        <syspropertyset>
          <propertyref prefix="test."/>
        </syspropertyset>
      </sf-deploy>
    </presetdef>
  </target>

  <target name="ready-to-undeploy" depends="init-deploy-properties,init-codebase">

  </target>

  <!-- ========================================================== -->
  <!-- deploy; requires a host -->
  <!-- ========================================================== -->

  <target name="deploy" depends="ready-to-deploy"
      description="deploy">
    <echo level="verbose">tests.run.classpath=${toString:tests.run.classpath}</echo>
    <deploy>
      <application name="${application.name}">
        sfCodeBase PROPERTY org.smartfrog.codebase;
        #include "/${deploy.sf}"
      </application>
    </deploy>
  </target>

  <!-- ========================================================== -->
  <!-- undeploy the application-->
  <!-- ========================================================== -->
  <target name="undeploy" depends="ready-to-undeploy"
      description="undeploy the application">
    <sf-undeploy classpathref="run.classpath"
        logStackTraces="true"
        host="${deploy.host}"
        failonerror="false"
        timeout="30000"
        application="${application.name}"/>
  </target>


  <!--
  This target defines the task
  <sf-system-test> which is a functional tests runner ready to
  run smartfrog, just add tests and go.
  The classpath of the daemon is set to tests.run.classpath;
  -->
  <target name="declare-system-test-tasks" depends="declare-extended-smartfrog-tasks,init-codebase" >
    <property name="daemon.jvmargs"  value=""/>
    <presetdef name="sf-system-test">
      <sf-functionaltest testTimeout="600" shutdownTime="10">
        <application>
          <condition property="daemon.already.live">
            <socket server="localhost" port="${smartfrog.daemon.port}" />
          </condition>
          <sf-conditional unless="daemon.already.live">
          <sf-startdaemon-debug failonerror="false"
              spawn="false"
              classpathref="tests.run.classpath">
            <jvmarg line="${daemon.jvmargs}" />
            <!--all properties beginning with test. or run.-->
            <syspropertyset>
              <propertyref prefix="test."/>
              <propertyref prefix="run."/>
            </syspropertyset>
          </sf-startdaemon-debug>
          </sf-conditional>
        </application>
        <probe>
          <socket port="${smartfrog.daemon.port}" server="localhost"/>
        </probe>
        <teardown>
          <parallel>
            <sf-stopdaemon failonerror="false"/>
            <sf-conditional unless="tests.skip.reports">
              <sf-junitreport data="${test.data.dir}"
                  reports="${test.reports.dir}"
                  />
            </sf-conditional>
          </parallel>
        </teardown>
      </sf-functionaltest>
    </presetdef>
    <presetdef name="sf-system-test-junit">
      <sf-junit
          errorProperty="system.test.failed"
          failureProperty="system.test.failed"
          includeAntRuntime="true"
          >
        <classpath refid="tests.run.classpath" />
        <sysproperty key="test.classes.dir"
            value="${test.classes.dir}"/>
        <!--all properties beginning with test and runtime, and the codebase-->
        <syspropertyset>
          <propertyref prefix="test."/>
        </syspropertyset>
        <sysproperty key="org.smartfrog.codebase" value="${codebase}"/>
        <syspropertyset>
          <propertyref prefix="runtime."/>
        </syspropertyset>
      </sf-junit>
    </presetdef>

    <!-- define the system test post processor-->
    <presetdef name="sf-system-test-validate">
      <fail if="system.test.failed" unless="tests.skip.failing">
System Tests for ${ant.project.name} failed - see
${test.reports.dir}/index.html
      </fail>
    </presetdef>

    <!--default pattern for system tests-->
    <property name="sf-system-test-class-pattern"
      value="org/smartfrog/**/test/**/*Test.class" />

    <presetdef name="sf-system-test-batch-run">
      <sf-system-test>
        <test>
          <sf-system-test-junit>
            <batchtest todir="${test.data.dir}" if="testcase">
              <fileset dir="${test.classes.dir}" includes="**/${testcase}.class"/>
            </batchtest>
            <batchtest todir="${test.data.dir}" unless="testcase">
              <fileset dir="${test.classes.dir}">
                <include name="${sf-system-test-class-pattern}"/>
              </fileset>
            </batchtest>
          </sf-system-test-junit>
          <sf-system-test-validate/>
        </test>
      </sf-system-test>
    </presetdef>


  </target>

  <target name="ready-to-test" depends="init,package,dist,package-tests,declare-system-test-tasks">

  </target>

  <!-- ========================================================== -->
  <!-- this is an override point -->
  <!-- system tests : anything that is tested on a live daemon
       not to be run on public machines for
       security reasons, unless security is active-->
  <!-- ========================================================== -->
  <target name="system-tests" if="system.tests.enabled"
          depends="ready-to-test"
    description="run the system tests">
    <sf-system-test-batch-run />
  </target>

  <!-- ========================================================== -->
  <!-- this is an override point -->
  <!-- unit tests : anything which does not need deployment to run-->
  <!-- ========================================================== -->
  <target name="unit-tests" depends="ready-to-test"
      if="unit.tests.enabled"
    description="run the unit tests">
  </target>

  <!-- ========================================================== -->
  <!-- run tests, both unit and system  -->
  <!-- ========================================================== -->
  <target name="run-tests"
    depends="unit-tests,system-tests" />


  <!-- ========================================================== -->
  <!-- public entry point does all tests and the reports -->
  <!-- ========================================================== -->
  <target name="test"
    depends="run-tests,reports"
    description="compile and run all the tests"
    />

  <!-- ========================================================== -->
  <!-- public entry point does all tests and the reports -->
  <!-- ========================================================== -->
  <target name="batch-test"
    depends="run-tests,reports-no-failure"
    description="compile and run all the tests; do not break on test failure"
    />

  <!-- ========================================================== -->
  <!-- this is the gump entry point; it does packaging and tests -->
  <!-- ========================================================== -->
  <target name="gump"
    depends="test,dist,published"
    description="target for gump builds"
    />

  <!-- ========================================================== -->
  <!-- shortcut for testing -->
  <!-- creates a distribution but without any javadocs (for speed),
       and cleans up the local cache to guarantee takeup
  -->
  <!-- ========================================================== -->
  <target name="smartfrog-dist"
    depends="-smartfrog-dist,ivy-purge-cache"
    >
    <ant dir="${smartfrog.home}" target="published" inheritall="false">
      <property name="javadoc.disabled" value="true" />
    </ant>

  </target>

  <target name="-smartfrog-dist"
      depends="init-common"
      >
    <ant dir="${smartfrog.home}" target="published" inheritall="false">
      <property name="javadoc.disabled" value="true" />
    </ant>

  </target>

  <!-- ========================================================== -->
  <!-- rebuild smartfrog, then run the tests
       this target is useful if you are changing smartfrog core
       as well as a component-->
  <!-- ========================================================== -->
  <target name="buildtest"
    depends="smartfrog-dist,test"
    description="compile the smartfrog distribution,
      compile and run all the tests, generate reports on failure"
    />

  <target name="buildtest-noreports"
    depends="smartfrog-dist,run-tests"
    description="compile the smartfrog distribution,
    compile and run all the tests, without any report stage"
    >
    <fail if="test.failed">Test failure</fail>
  </target>

  <!-- ========================================================== -->
  <!-- print meaningful diagnostics -->
  <!-- ========================================================== -->
 <target name="diagnostics" depends="init"
    description="build file diagnostics">
    <diagnostics/>
  </target>

 <target name="diag2" depends="init,verify-prerequisites">
    <echo>
      ant.version ${ant.version}
      build file ${ant.project.name}
      base dir ${basedir}
      core dir ${core.dir}
      junit.jar ${junit.jar}
      verified.ok=${verified.ok}

    </echo>
  </target>

   <!-- ========================================================== -->
  <!-- this is an override point -->
  <!-- default target -->
  <!-- ========================================================== -->
  <target name="default" depends="published"
    description="default target creates a distribution" />


 <!-- ========================================================== -->
  <!-- entry point for the components/buildRelease.xml delegation;
       probe for needed libraries, and skip the operation if they
       are missing -->
  <!-- ========================================================== -->

  <target name="maybe-buildrelease">
    <antcall target="release"/>
  </target>


  <!-- ========================================================== -->
  <!-- Security corner -->
  <!-- ========================================================== -->

  <target name="assert-secure"
    description="halt the build if security is not turned on" unless="security.enabled">
    <fail>
      This is not a secure build. To make a secure build
      1. set security.enabled=true
      2. Create a CA and point the property security.ca.dir at the location.
         Currently this property is ${security.ca.dir}
    </fail>
  </target>

  <target name="init-security" depends="init,declare-extended-smartfrog-tasks"
      xmlns:sec="http://security.smartfrog.org/">
    <!--this is a flag that turns security on or off. by default it is off-->
    <!--this should be overridden with the real value-->
    <property name="security.ca.password" value="pleasechange2" />
    <property name="security.self.key" value="self" />

    <!--this needs to be set up with the CA that I want-->
    <property name="security.ca.dir" location="${smartfrog.home}/private/ca" />
    <property name="security.code.keystore" location="${security.ca.dir}/codesigner.st"/>

    <property name="security.keystore.type" value="JCEKS"/>

    <fail>
      <condition>
        <and>
          <isset property="${security.enabled}"/>
          <not>
            <available file="${security.code.keystore}" />
          </not>
        </and>
      </condition>
The file in the property security.code.keystore:
  ${security.code.keystore}
Does not exist.

Check that it and the directory in security.ca.dir:
  ${security.ca.dir}
Exist.
    </fail>

    <property name="security.uri" value="http://security.smartfrog.org/" />

    <!--the settins for our jar signings-->
    <presetdef name="signjar2" uri="${security.uri}">
        <signjar
            preservelastmodified="true"
            alias="${security.self.key}"
            keystore="${security.code.keystore}"
            storetype="${security.keystore.type}"
            storepass="${security.ca.password}"
            lazy="true"/>
    </presetdef>
    <!-- sign a jar when security.enabled is set and true -->
    <macrodef name="maybe-sign-jar" uri="${security.uri}">
      <attribute name="jar"/>
      <sequential>
        <sf-conditional if="security.enabled">
          <sec:signjar2 jar="@{jar}"/>
        </sf-conditional>
      </sequential>
    </macrodef>
  </target>

  <target name="sign-dependent-jars" depends="init-security"
    description="sign all jars that we depend upon"
      xmlns:sec="http://security.smartfrog.org/">
    <!-- TODO -->
  </target>

  
  <target name="sign-target-jar"
    description="sign our target jar if security.sign.target.jar is true and security.sign.target.jar" 
      depends="package,init-security"
      if="security.sign.target.jar"
      xmlns:sec="http://security.smartfrog.org/">
      <sec:signjar2 jar="${target.jar}" />
  </target>

  <target name="checksum-target-jar"
    description="checksum our target jar" depends="sign-target-jar">
    <checksum file="${target.jar}" algorithm="md5"/>
    <checksum file="${target.jar}" algorithm="sha1"/>
  </target>

  <!-- ========================================================== -->
  <!-- init all the maven2 support   -->
  <!-- ========================================================== -->
  <target name="m2-init" depends="init,declare-extended-smartfrog-tasks,load-versions">
    <!-- Maven2 stuff
      All components build into the org.smartfrog group, unless otherwise stated, but
      are their own artifacts.
      -->

    <property name="m2.repository" location="${user.home}/.m2/repository"/>
    <!-- and by default, they publish somewhere other than the local repository-->
    <property name="m2.publish.repository" location="${core.dir}/build/m2/repository"/>
    <mkdir dir="${m2.publish.repository}" />
    <!-- make the root path of an artifact -->
    <macrodef name="m2-makepath">
      <attribute name="property"/>
      <attribute name="groupIDpath"/>
      <attribute name="artifactID" default="@{groupIDpath}"/>
      <attribute name="version"/>
      <sequential>
        <property name="@{property}"
            location="${m2.publish.repository}/@{groupIDpath}/@{artifactID}/@{version}"/>
      </sequential>
    </macrodef>

    <property name="m2.groupID" value="org.smartfrog"/>
    <property name="m2.groupID.path" value="org/smartfrog"/>
    <m2-makepath property="m2.subdir"
        groupIDpath="${m2.groupID.path}"
        artifactID="${artifact.name}"
        version="${Version}"/>
    <!--     <property name="m2.subdir"
         location="${m2.repository}/${m2.groupID.path}/${artifact.name}/${Version}" />
    -->
    <!-- pom setup -->
    <property name="target.pom"
        location="${dist.lib.dir}/${jarfile.stub}.pom"/>
    <property name="target.pom.md5"
        location="${target.pom}.md5"/>
    <property name="target.jar.md5"
        location="${target.jar}.md5"/>
    <property name="project.pom" location="project-template.pom"/>
    <available property="project.haspom" file="${project.pom}"/>
    <property name="m2.tasks.uri"
        value="antlib:org.apache.maven.artifact.ant"/>
    <available property="m2.tasks.available"
        resource="org/apache/maven/artifact/ant/antlib.xml"/>

    <property name="m2.ibiblio.repository"
        value="http://ibiblio.org/maven2"/>

    <property name="m1.local.repository"
        location="${user.home}/.maven/repository"/>
    <!--if there is no m1 repository, create it-->
    <mkdir dir="${m1.local.repository}"/>
    <sf-tourl file="${m1.local.repository}"
        property="m1.local.repository.url"/>

    <!--a string that is copied into the pom comments-->
    <property name="pom.comments"
      value="
      Created ${build.date} by ${user.name}.
      This metadata file is published under an Apache license. 
      " />
  </target>


   <!-- look for local then remote definitions of library versions -->
  <target name="load-versions" depends="common.init">
    <property file="libraries.properties"/>
    <property
        name="libraries.properties"
        location="${smartfrog.components.dir}/libraries.properties"/>
    <property file="${libraries.properties}"/>
  </target>

  <!-- ========================================================== -->
  <!-- POM creation/copy, depending on whether it exists or not   -->
  <!-- ========================================================== -->

   <target name="m2-copy-pom" depends="m2-init" if="project.haspom" >
     <copy file="${project.pom}" tofile="${target.pom}" >
      <!-- we expand ant properties here.  -->
       <filterchain>
        <expandproperties/>
       </filterchain>
     </copy>
   </target>


   <!-- inline creation of a very minimal (zero dependency) pom -->
  <target name="m2-make-pom" depends="m2-init" unless="project.haspom">
    <echo message="Creating Pom ${target.pom}" level="verbose"/>
    <echo file="${target.pom}"><![CDATA[<project
    xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-0_0.xsd
    >
    <!--
     ${pom.comments}
     -->
  <modelVersion>4.0.0</modelVersion>
  <groupId>${m2.groupID}</groupId>
  <artifactId>${artifact.name}</artifactId>
  <packaging>jar</packaging>
  <version>${Version}</version>
</project>
]]></echo>

   </target>

   <target name="m2-pom" depends="m2-copy-pom,m2-make-pom" >
     <checksum file="${target.pom}" algorithm="md5"/>
   </target>

  <!-- ========================================================== -->
  <!-- this is not  normally for overriding -->
  <!-- install the jar, to the local maven2 repository -->
  <!-- This is used when we release artifacts-->
  <!-- ========================================================== -->
  <target name="m2-install" depends="checksum-target-jar,m2-pom"
      description="copy the JAR file to the local maven repository">

    <mkdir dir="${m2.subdir}"/>
    <copy file="${target.jar}" todir="${m2.subdir}"/>
    <!-- copy a pom -->
    <copy file="${target.pom}" todir="${m2.subdir}" failonerror="false"/>
    <!--copy the checksums-->
    <copy file="${target.pom.md5}" todir="${m2.subdir}" failonerror="false"/>
    <copy file="${target.jar.md5}" todir="${m2.subdir}" failonerror="false"/>

  </target>


  <target name="ivy-properties" depends="init-common-simpledefinitions,load-versions" >
    <property name="ivy.version" value="2.0.0" />
    <property name="ivy.dir" location="${build.dir}/ivy" />
    <property name="ivy.lib.dir" location="${ivy.dir}/lib" />
    <property name="ivy.user.dir" location="${user.home}/.ivy" />
    <property name="ivy.local.dir" location="${ivy.user.dir}/local" />
    <property name="ivy.cache.dir" location="${ivy.user.dir}/cache" />

    <!--Ivy 2 uses some separate directories, that also need cleanup-->
    <property name="ivy2.user.dir" location="${user.home}/.ivy2" />
    <property name="ivy2.local.dir" location="${ivy2.user.dir}/local" />
    <property name="ivy2.cache.dir" location="${ivy2.user.dir}/cache" />


    <!--here to ensure that any operations on the caches have somewhere to
    work from-->
    <mkdir dir="${ivy.cache.dir}" />
    <mkdir dir="${ivy.local.dir}" />
    <mkdir dir="${ivy2.cache.dir}" />
    <mkdir dir="${ivy2.local.dir}" />

    <property name="ivy.package.name" value="org.smartfrog" />
    <property name="ivy.resource" value="fr/jayasoft/ivy/ant/antlib.xml" />
    <property name="ivy.reports.dir" location="${ivy.dir}/reports"/>
    <property name="ivy.jar"
        location="${core.dir}/antbuild/ivy/lib/ivy-${ivy.version}.jar"/>
 <!--    <property name="ivy.ibiblio.root"
        value="http://www.ibiblio.org/maven2/"/> -->
    <available property="ivy.jar.found" file="${ivy.jar}" />
    <available property="ivy.resource.found" resource="${ivy.resource}" />
    <condition property="ivy.found" >
      <or >
        <isset property="ivy.jar.found"/>
        <isset property="ivy.resource.found"/>
      </or>
    </condition>
    <mkdir dir="${ivy.reports.dir}" />
    <mkdir dir="${ivy.lib.dir}" />


    <property name="ivy.cache.smartfrog.dir"
        location="${ivy2.cache.dir}/${ivy.package.name}" />
    <property name="ivy.project.name" value="sf-${ant.project.name}" />
    <property name="ivy.cache.project.dir"
        location="${ivy.cache.smartfrog.dir}/${ivy.project.name}" />

    <mkdir dir="${ivy.cache.smartfrog.dir}" />
    <mkdir dir="${ivy.cache.project.dir}" />

    <property name="ivysettings.xml" location="${core.dir}/antbuild/ivy/ivysettings.xml" />

    <!--first check for ivy being loaded-->
    <condition property="ivy.tasks.loaded">
      <typefound name="retrieve" uri="antlib:org.apache.ivy.ant"/>
    </condition>

  </target>

  <target name="maybe-declare-ivy" if="ivy.enabled"
      unless="ivy.tasks.loaded"
      depends="ivy-properties">
    <typedef uri="antlib:org.apache.ivy.ant" onerror="fail"
        loaderRef="ivyLoader">
      <classpath>
        <pathelement location="${ivy.jar}"/>
      </classpath>
    </typedef>
  </target>

  <!--
    second check for ivy being loaded; this will kick in
    after maybe-declare-ivy.
  -->
  <target name="probe-for-ivy-tasks" depends="maybe-declare-ivy">
    <condition property="ivy.tasks.loaded2" >
      <typefound name="retrieve" uri="antlib:org.apache.ivy.ant"/>
    </condition>
  </target>

  <target name="declare-ivy" unless="ivy.tasks.loaded2"
          depends="probe-for-ivy-tasks"
          >
    <typedef uri="antlib:org.apache.ivy.ant" onerror="fail" loaderRef="ivyLoader">
      <classpath>
        <pathelement location="${ivy.jar}"/>
      </classpath>
    </typedef>
    <!-- sometimes that doesn't seem to fail when ivy is missing, 
     so let's explicitly test that Ivy is there, just in case -->
    <fail>
    <condition>
      <not>
       <typefound name="settings" uri="antlib:org.apache.ivy.ant"/>
      </not>
    </condition>
    No Ivy found in ${ivy.jar}
    </fail>
  </target>

  <target name="maybe-ivy-init"
          depends="declare-ivy"
          if="ivy.enabled" >
    <ivy:configure file="${ivysettings.xml}" override="false"/>
  </target>

  <target name="maybe-ivy-resolve" depends="maybe-ivy-init"
          if="ivy.enabled" >
    <ivy:resolve />
  </target>

  <target name="ivy-probe-repository"
      description="check that the repository is reachable"
      depends="ivy-properties">
    <property name="ivy.probe.path"
        value="${ivy.ibiblio.root}org/apache/ant/"/>
    <echo>Probing ${ivy.probe.path}</echo>
    <condition property="ivy.repository.reachable">
      <or>
<!--
        <isreachable url="${ivy.ibiblio.root}" timeout="10"/>
-->
        <http url="${ivy.probe.path}" />
      </or>
    </condition>
  </target>

  <target name="ivy-require-repository" depends="ivy-probe-repository"
      unless="ivy.repository.reachable">
    <fail>
      Unable to reach ${ivy.ibiblio.root}
    </fail>
  </target>


  <target name="ivy-purge-cache" depends="ivy-properties"
      description="purge all smartfrog artifacts from the cache">
    <delete dir="${ivy2.cache.dir}/${ivy.package.name}" defaultexcludes="false" includeEmptyDirs="true" includes="**/*"/>
    <delete includeEmptyDirs="true">
      <fileset dir="${ivy2.cache.dir}" includes="resolved-${ivy.package.name}-*" defaultexcludes="false" />
    </delete>
  </target>

  <!--remove all project-seecific libraries from the cache-->
  <target name="ivy-purge-project" depends="ivy-properties"
      description="purge all smartfrog artifacts from the ~/.ivy2 directories">
    <delete includeEmptyDirs="true">
      <fileset dir="${ivy.cache.project.dir}" defaultexcludes="false"  includes="**/*"/>
      <fileset dir="${ivy2.cache.dir}" includes="resolved-${ivy.package.name}-${ivy.project.name}" />
    </delete>
    <delete dir="${ivy2.local.dir}/${ivy.package.name}/${ivy.project.name}" />
  </target>

  <!--This is a trick. by running the same stuff
  as "maybe-ivy-init" with the opposite condition we, guarantee
  that the target code runs once, but only once-->

  <target name="ivy-init"
          depends="maybe-ivy-init"
      unless="ivy.enabled">
    <ivy:configure file="${ivysettings.xml}" override="false"/>
  </target>

  <target name="ivy-resolve" depends="maybe-ivy-resolve,ivy-init"
          unless="ivy.enabled">
    <ivy:resolve />
  </target>

  <target name="ivy-retrieve" depends="ivy-resolve" 
    description="retrieve all dependent artifacts through Ivy">
    <property name="ivy.artifact.retrieve.pattern"
        value="[conf]/[artifact]-[revision].[ext]" />
    <property name="ivy.retrieve.path"
        value="${ivy.lib.dir}/${ivy.artifact.retrieve.pattern}" />
    <ivy:retrieve pattern="${ivy.retrieve.path}" sync="true" />
  </target>

  <target name="ivy-report" depends="ivy-resolve" >
    <ivy:report todir="${ivy.reports.dir}"/>
    <echo> published Ivy report to
${ivy.reports.dir}
    </echo>
  </target>

  <!--publish master artifacts-->
  <target name="ivy-publish" depends="ready-to-publish"
      xmlns:ivy="antlib:org.apache.ivy.ant">
    <ivy:publish resolver="local" pubrevision="${Version}"
        overwrite="true"
          conf="master"
        artifactspattern="${dist.lib.dir}/[artifact]-[revision].[ext]" />
  </target>

  <target name="ivy-warn-no-ivy" depends="ivy-properties" unless="ivy.found">
    <echo level="error">
      No Ivy file found:
      ${ivy.jar}
      Artifacts created in this build will not be published.
    </echo>
  </target>

  <target name="ivy-require-ivy" depends="ivy-properties" unless="ivy.found">
    <fail>
      No Ivy file found:
      ${ivy.jar}
      Either ivy.version is inconsistent with the artifacts in ${ivy.lib.dir}, or that directory
      and/or the file inside it is missing
    </fail>
  </target>

  <!--jars,-->
  <target name="ready-to-publish" depends="checksum-target-jar,ivy-report"/>

  <target name="ready-to-publish-all"
          depends="ready-to-publish,package-javadocs,package-documents"/>

  <!--publish everything, rather than just artifacts in the master config-->
  <target name="ivy-publish-all" depends="ready-to-publish-all"
          xmlns:ivy="antlib:org.apache.ivy.ant">
    <ivy:publish resolver="local" pubrevision="${Version}"
       overwrite="true"
       haltonmissing="false"
       artifactspattern="${dist.lib.dir}/[artifact]-[revision].[ext]" />
  </target>

  <target name="published" depends="ivy-publish-all,m2-install"
      description="Publish artifacts to the local repositories"
      />

  <target name="installed" depends="published,install"
    description="Place the system in a state in which the components are installed for reuse" />

  <target name="published-distribution" depends="dist,published"
      description="create a distribution and publish all artifacts with Ivy"/>


  <!-- ======================================================  -->
  <!-- Here's some conversion of SXW into .PDF by OOo itself   -->
  <!-- see http://www.oooforum.org/forum/viewtopic.phtml?t=3772 -->
  <!-- ======================================================  -->

  <target name="init-ooo">
    <property name="ooffice.exe" value="ooffice" />

    <presetdef name="ooo">
      <exec executable="${ooffice.exe}" failonerror="true">
      </exec>
    </presetdef>

    <macrodef name="pdf">
      <attribute name="file" />
      <sequential>
        <ooo>
          <arg value="macro:///SmartFrog.Utils.ConvertWordToPDF(@{file})" />
        </ooo>
      </sequential>
    </macrodef>

    <macrodef name="bulkpdf">
      <attribute name="dir" />
      <sequential>
        <ooo>
          <!--<arg value="-invisible" />-->
          <arg value="macro:///SmartFrog.Utils.BulkConvert(@{dir})" />
        </ooo>
      </sequential>
    </macrodef>
  </target>

  <target name="pdf-doc-folder" depends="init, init-ooo"
      description="Generate PDFs from all .SXW files in the documentation folder">
    <bulkpdf dir="${doc.dir}" />
  </target>


  <!-- CLOVER -->
  <target name="init-clover" depends="init">
    <property name="clover.dir" location="${core.dir}/clover"/>
    <property name="clover.jar" location="${clover.dir}/clover.jar"/>
    <path id="clover.classpath">
      <fileset file="${clover.jar}"/>
    </path>
    <available property="clover.present"
        file="${clover.jar}"/>
    <!--check to see if clover is already installed in this process-->
    <condition property="clover.installed">
      <typefound name="clover-setup"/>
    </condition>
  </target>

  <!--If we have clover, and it is not already installed, then install it-->
  <target name="define-clover" depends="init-clover"
      if="clover.present" unless="clover.installed">
    <taskdef resource="cloverlib.xml" classpathref="clover.classpath"/>
    <condition property="clover.installed">
      <typefound name="clover-setup"/>
    </condition>
  </target>

  <target name="with.clover" depends="define-clover">
    <clover-setup/>
  </target>

  <target name="-check.clover" depends="define-clover">
  </target>

  <target name="guard.noclover" depends="-check.clover" unless="clover.installed">
    <fail message="The target you are attempting to run requires Clover, which doesn't appear to be installed"/>
  </target>

  <target name="clover.report" depends="with.clover">

    <!-- generate a historypoint for the current coverage -->
    <clover-historypoint historyDir="clover_hist"/>

    <!-- generate a report with both current and historical data -->

    <clover-html-report outdir="clover_html" historyDir="clover_hist"/>
  </target>

  <target name="clover.summary" depends="with.clover">
    <clover-pdf-report outfile="coverage.pdf"/>
  </target>


  <!-- ========================================================== -->
  <!-- public entry point does all tests and the reports -->
  <!-- ========================================================== -->
  <target name="test.with.clover"
      depends="with.clover,run-tests,clover.report,clover.summary,reports"
      description="compile and run all the tests with clover reports included"
      />


  <!-- CLOVER  End-->

  <!-- Ivy quick and dirty test -->

  <target name="ivy-test" depends="ivy-resolve" if="ivy.found" description="Try to retrieve dependencies from ivy.xml placed in local dir">
    <ivy:retrieve />
  </target>
  <!-- Ivy quick and dirty test End-->
  
</project>


