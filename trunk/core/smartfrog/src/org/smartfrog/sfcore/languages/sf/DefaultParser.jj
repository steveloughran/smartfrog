options {
  DEBUG_TOKEN_MANAGER = false;
  STATIC=false;
  JAVA_UNICODE_ESCAPE = true;
  FORCE_LA_CHECK=true;
}

PARSER_BEGIN(DefaultParser)
package org.smartfrog.sfcore.languages.sf;

import org.smartfrog.sfcore.languages.sf.sfcomponentdescription.SFComponentDescriptionImpl;
import org.smartfrog.sfcore.languages.sf.sfcomponentdescription.SFComponentDescription;
import org.smartfrog.sfcore.reference.ReferencePart;
import org.smartfrog.sfcore.reference.HostReferencePart;
import org.smartfrog.sfcore.reference.PropertyReferencePart;
import org.smartfrog.sfcore.reference.IPropertyReferencePart;
import org.smartfrog.sfcore.reference.HereReferencePart;
import org.smartfrog.sfcore.reference.RootReferencePart;
import org.smartfrog.sfcore.reference.AttribReferencePart;
import org.smartfrog.sfcore.reference.ThisReferencePart;
import org.smartfrog.sfcore.reference.Reference;
import org.smartfrog.sfcore.common.SFNull;
import org.smartfrog.sfcore.common.SFBinaryArray;
import java.io.InputStream;
import java.util.Vector;
import java.util.Enumeration;




public class DefaultParser {
  protected IncludeHandler includeHandler;
  static int nextId = 0;

  static final String appendOp = "org.smartfrog.sfcore.languages.sf.functions.Append";
  static final String concatOp = "org.smartfrog.sfcore.languages.sf.functions.Concatenate";
  static final String sumOp = "org.smartfrog.sfcore.languages.sf.functions.Sum";
  static final String timesOp = "org.smartfrog.sfcore.languages.sf.functions.Product";

  static final String andOp = "org.smartfrog.sfcore.languages.sf.functions.Conjunction";
  static final String orOp = "org.smartfrog.sfcore.languages.sf.functions.Disjunction";

  static final String eqOp = "org.smartfrog.sfcore.languages.sf.functions.EQ";
  static final String neOp = "org.smartfrog.sfcore.languages.sf.functions.NE";
  static final String geOp = "org.smartfrog.sfcore.languages.sf.functions.GEs";
  static final String leOp = "org.smartfrog.sfcore.languages.sf.functions.LE";
  static final String gtOp = "org.smartfrog.sfcore.languages.sf.functions.GT";
  static final String ltOp = "org.smartfrog.sfcore.languages.sf.functions.LT";

  static final String minusOp = "org.smartfrog.sfcore.languages.sf.functions.Minus";
  static final String divOp = "org.smartfrog.sfcore.languages.sf.functions.Divide";

  static final String notOp = "org.smartfrog.sfcore.languages.sf.functions.Not";
  static final String ifThenElseOp = "org.smartfrog.sfcore.languages.sf.functions.IfThenElse";



  public DefaultParser(InputStream is, IncludeHandler handler) {
    this(is);
    this.includeHandler = handler;
  }


  private String fixEscapes(String s) {
    int index = 0;
    int length = s.length();
    StringBuffer fixed = new StringBuffer(length);

    while (index < length) {
      if (s.charAt(index) == '\\') {
        index++;
        switch (s.charAt(index)) {
          case 'n':
            fixed.append('\n'); break;
          case 't':
            fixed.append('\t'); break;
          case 'b':
            fixed.append('\b'); break;
          case 'r':
            fixed.append('\r'); break;
          case 'f':
            fixed.append('\f'); break;
          case '0': case '1': case '2': case '3':
          case '4': case '5': case '6': case '7':
            int i = ((s.charAt(index) - '0') * 64) +
                    ((s.charAt(index+1) - '0') * 8) +
                    ((s.charAt(index+2) - '0'));
            index = index + 2;
            fixed.append((char) i);
            break;
          default:
            fixed.append(s.charAt(index));
        }
      } else {
        fixed.append(s.charAt(index));
      }
      index++;
    }
    return fixed.toString();
  }

  private String eliminateWhitespace(String s) {
    int index = 0;
    int length = s.length();
    StringBuffer fixed = new StringBuffer();

    while (index < length) {
        switch (s.charAt(index)) {
          case '\n':
          case '\t':
          case ' ':
            break;
          default:
            fixed.append(s.charAt(index));
        }
        index++;
    }
    return fixed.toString();
  }


  protected Vector parseInclude(String fName) throws ParseException {
    try {
      return includeHandler.parseInclude(fName);
    } catch (TokenMgrError tex) {
      throw new TokenMgrError("In include file " + fName + " : " +
                              tex.getMessage(),
                              tex.errorCode);
    } catch (Exception ex) {
      throw new ParseException("Parsing include file " + fName + " : " +
                               ex.getMessage());
    }
  }

}

PARSER_END(DefaultParser)


/* WHITE SPACE */

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* COMMENTS */

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
| <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
| "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <( ~[ "\n" , "\r" ] )* > : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

TOKEN : /* reserved words */
{
   <SEMICOLON: ";">
 | <COMMA: ",">
 | <LBRACE: "{">
 | <RBRACE: "}">
 | <LBRACKET: "[">
 | <RBRACKET: "]">
 | <VECTORSTART: "[|">
 | <VECTOREND: "|]" >
 | <REFPARTSEP: ":">
 | <NULL: "NULL">
 | <UNIQUE: "--">
 | <EXTENDS: "extends">
 | <LAZY: "LAZY">
 | <DATA: "DATA">
 | <ROOT: "ROOT">
 | <ATTRIB: "ATTRIB">
 | <HERE: "HERE">
 | <THIS: "THIS">
 | <PROPERTY: "PROPERTY">
 | <IPROPERTY: "IPROPERTY">
 | <PARENT: "PARENT">
 | <HOST: "HOST">
 | <PROCESS: "PROCESS">
 | <INCLUDE: "#include">
 | <TRUE: "true">
 | <FALSE: "false">

 | <OPSTART: "(">
 | <OPEND: ")">

 | <SUM: "+">
 | <MINUS: "-">
 | <TIMES: "*">
 | <DIV: "/">
 | <CONCAT: "++">
 | <APPEND: "<>">

 | <EQ: "==">
 | <NE: "!=">
 | <GE: ">=">
 | <LE: "<=">
 | <GT: ">">
 | <LT: "<">

 | <AND: "&&">
 | <OR: "||">
 | <NOT: "!">

 | <IF: "IF">
 | <THEN: "THEN">
 | <ELSE: "ELSE">
 | <FI: "FI">
}

TOKEN :
{
  < WORD: <LETTER> (<LETTER>|<DIGIT>|<SPECIAL>)* >
| < #SPECIAL: [".", "_", "-", "+", "@", "#", "~", "$", "%", "^", "&"] >
| < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}


TOKEN : /* Literals */
{
      <STRING:
      ("\"" (
          (~["\"","\\","\n","\r"])
          | ("\\"
              ( ["n","t","b","r","f","\\","'","\""]
              | ["0"-"3"] ["0"-"7"] ["0"-"7"]
              )
            )
        )* "\"")
      >
    | <MULTILINESTRING: ("##" (
          (~["#","\\"])
          | ("\\"
              ( ["n","t","b","r","f","\\","'","#"]
              | ["0"-"3"] ["0"-"7"] ["0"-"7"]
              )
            )
        )* "#")
      >
    | <INTEGER: (("-")? ["0"-"9"] (["0"-"9"])*)
        | "0" >
    | <#FLOAT_BASE:
        ("-")?
        (
          (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?
        | "." (["0"-"9"])+ (<EXPONENT>)?
        | (["0"-"9"])+ <EXPONENT>
        | (["0"-"9"])+ (<EXPONENT>)?
        )
      >
    | < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
    | <DOUBLE:
        <FLOAT_BASE> (["d", "D"])?
      >
    | <LONG:
        <INTEGER> (["l", "L"])?
      >
    | <FLOAT:
        <FLOAT_BASE> ["f", "F"]
      >
    | <BINARRAY:
          ("#HEX#")
          (["0"-"9", "a"-"f", "A"-"F", " ", "\n", "\t"])*
          ("#")
       >
}


/*
 * Entry point to the grammar for component parser
 */

void Attributes(SFComponentDescription descr) :
{
}
{
  AttributesNoEOF(descr) <EOF>
}

/*
 * Entry point for default include handler
 */

Vector AttributeList() :
{
    Vector res;
}
{
    res = AttributeListNoEOF() <EOF>
    { return res; }
}

/*
 * Entry point for Reference parser
 */

Reference Reference() :
{
  Reference res;
}
{
    res = ReferenceNoEOF() <EOF>
    { return res; }
}

/*
 * Entry point for any value parser (e.g. for parsing values in Management Console)
 */
 Object AnyValue() :
{
  Object res;
}
{
     (res=Component() | res=SimpleValue()) <EOF>
     { return res; }
}


 /*
  * Entry point for basic value parser (e.g. for parsing properties)
  */
 Object PrimitiveValue() :
{
  Object res;
}
{
    res = Primitive() <EOF>
    { return res; }
}

/*
 * Main body of grammar
 */
void AttributesNoEOF(SFComponentDescription descr) :
{
  Vector attrs;
}
{
  attrs = AttributeListNoEOF()
  {
    for (Enumeration e = attrs.elements(); e.hasMoreElements(); ) {
      Object[] attribute = (Object[])e.nextElement();
      descr.sfContext().put(attribute[0], attribute[1]);
      if (attribute[1] instanceof SFComponentDescription)
        ((SFComponentDescription)attribute[1]).setParent(descr);
    }
  }
}


Vector AttributeListNoEOF() :
{
    Vector res = new Vector(10, 5);
    Object[] c;
    String fName;
}
{
    ( c = Attribute() {res.addElement(c);}
    | ( <INCLUDE> fName = String()
         { Vector tmp = parseInclude(fName);
           for(Enumeration e = tmp.elements(); e.hasMoreElements(); )
             res.addElement(e.nextElement());
       } )
    | <SEMICOLON>
    )*
    { return res; }
}

Object[] Attribute() :
{
  Object[] attribute = new Object[2];
  Reference name = new Reference();
}
{
  (Name(name) attribute[1]=Value()
   { if (name.size() == 1)
        attribute[0] = ((HereReferencePart)name.firstElement()).getValue();
     else
        attribute[0] = name;
     if (attribute[1] == null) attribute[1] = SFNull.get();
     return attribute;
   })
}


void Name(Reference res) :
{
  res.setEager(true);
  Token t;
}
{
     (<UNIQUE>
       {
           res.addElement(ReferencePart.here("unique" + nextId++));
       }
     )
    |
     (
       (t=<WORD> {res.addElement(ReferencePart.here(t.image));})
       [(<REFPARTSEP> Name(res))]
     )
}






Object Value() :
{
  Object res=null;
}
{
    (
    res=Component()
    | res=SimpleValue() <SEMICOLON>
    | <SEMICOLON>
    ) { return res; }
}






Object SimpleValue() :
{
  Object res=null;
}
{
    (
    res=ReferenceNoEOF()
    | res=Basic()
    | res = Operator()
    | res = IfThenElse()
    ) { return res; }
}


Object Operator() :
{
    Object res;
    int arity = 0; //0=nary, 1=unary, 2=binary

    Object a = null;
    Object b = null;
    Vector v = new Vector();
    String operator = "";
}
{
    <OPSTART>
    ((<NOT> {operator = notOp; arity = 1;} a = SimpleValue() )
     |
     (a = SimpleValue() {v.add(a);}) [
     (
      ((<APPEND> {operator = appendOp; arity=0;}) (b = SimpleValue() {v.add(b);}) (<APPEND> (b = SimpleValue() {v.add(b);}))*)
         |((<CONCAT> {operator = concatOp; arity=0;}) (b = SimpleValue() {v.add(b);}) (<CONCAT> (b = SimpleValue() {v.add(b);}))*)
         |((<SUM> {operator = sumOp; arity=0;}) (b = SimpleValue() {v.add(b);}) (<SUM> (b = SimpleValue() {v.add(b);}))*)
         |((<TIMES> {operator = timesOp; arity=0;}) (b = SimpleValue() {v.add(b);}) (<TIMES> (b = SimpleValue() {v.add(b);}))*)
         |((<AND> {operator = andOp; arity=0;}) (b = SimpleValue() {v.add(b);}) (<AND> (b = SimpleValue() {v.add(b);}))*)
         |((<OR> {operator = orOp; arity=0;}) (b = SimpleValue() {v.add(b);}) (<OR> (b = SimpleValue() {v.add(b);}))*)

     |((<EQ> {operator = eqOp; arity=2;}) (b = SimpleValue()))
     |((<NE> {operator = neOp; arity=2;}) (b = SimpleValue()))
     |((<GE> {operator = geOp; arity=2;}) (b = SimpleValue()))
     |((<LE> {operator = leOp; arity=2;}) (b = SimpleValue()))
     |((<GT> {operator = gtOp; arity=2;}) (b = SimpleValue()))
     |((<LT> {operator = ltOp; arity=2;}) (b = SimpleValue()))
         |((<MINUS> {operator = minusOp; arity=2;}) (b = SimpleValue()))
         |((<DIV> {operator = divOp; arity=2;}) (b = SimpleValue()))
     )
      ]
    )
    <OPEND>
    {
    if (operator.equals("")) {
        res = a;
    } else {
        res = SFParser.componentFactory("default");
        if (arity==0) {
        for (Enumeration e = v.elements(); e.hasMoreElements(); ) {
            Object attribute = e.nextElement();
            Reference name = new Reference(ReferencePart.here("unique" + nextId++));
            ((SFComponentDescription)res).sfContext().put(name, attribute);
            if (attribute instanceof SFComponentDescription)
            ((SFComponentDescription)attribute).setParent((SFComponentDescription)res);
        }
        } else if (arity == 2) {
        ((SFComponentDescription)res).sfContext().put("left", a);
        if (a instanceof SFComponentDescription)
            ((SFComponentDescription)a).setParent((SFComponentDescription)res);
        ((SFComponentDescription)res).sfContext().put("right", b);
        if (b instanceof SFComponentDescription)
            ((SFComponentDescription)b).setParent((SFComponentDescription)res);
        } else { // (arity == 1)
        ((SFComponentDescription)res).sfContext().put("data", a);
        if (a instanceof SFComponentDescription)
            ((SFComponentDescription)a).setParent((SFComponentDescription)res);
        }
        ((SFComponentDescription)res).sfContext().put("phase.function", operator);
    }
    return res;
    }
}


Object IfThenElse() :
{
    Object i,t,e;
}
{
    <IF> i = SimpleValue() <THEN> t = SimpleValue() <ELSE> e = SimpleValue() <FI>
    {
    SFComponentDescription ifte = SFParser.componentFactory("default");
    if (i instanceof SFComponentDescription)
        ((SFComponentDescription)i).setParent((SFComponentDescription)ifte);

    if (t instanceof SFComponentDescription)
        ((SFComponentDescription)t).setParent((SFComponentDescription)ifte);

    if (e instanceof SFComponentDescription)
        ((SFComponentDescription)e).setParent((SFComponentDescription)ifte);

    ifte.sfContext().put("phase.function", ifThenElseOp);
    ifte.sfContext().put("if", i);
    ifte.sfContext().put("then", t);
    ifte.sfContext().put("else", e);
    return ifte;
    }
}

//
// Note that the Component() term may include a different node type builder.
// This is used as follows:
//
//   foo extends:someClass etc...
//
// Where the default is "default". This is used by the
// component factory to map to a class to represent that node. This is
// SFComponentDescriptionImpl in the default factory.
// This is not documented anywhere (deliberately) and maybe should
// be removed... (IT has been useful in some special uses of the language
// outside of SmartFrog).
//
SFComponentDescription Component() :
{
  SFComponentDescription component;
  String componentClass="default";
  Token id;
}
{
  <EXTENDS> [ <REFPARTSEP> id=<WORD> { componentClass = id.image; } ] component=ComponentType(componentClass)
   { return component; }
}

SFComponentDescription ComponentType(String componentClass) :
{
  SFComponentDescription component =
      SFParser.componentFactory(componentClass);
}
{
  (EagerComponent(component)|LazyComponent(component)|DataComponent(component))
    { return component; }
}

void EagerComponent(SFComponentDescription comp) :
{
}
{
  BaseComponent(comp) { comp.setEager(true); }
}

void LazyComponent(SFComponentDescription comp) :
{
}
{
  <LAZY> BaseComponent(comp) { comp.setEager(false); }
}

void DataComponent(SFComponentDescription comp) :
{
}
{
  <DATA> BaseComponent(comp) { comp.setEager(false); }
}


void BaseComponent(SFComponentDescription comp) :
{
  Reference prototype = new Reference();
  prototype.setEager(true);
}
{
  [ <NULL> | BaseReference(prototype) ]
  (<SEMICOLON>| (<LBRACE> AttributesNoEOF(comp) <RBRACE>) )
  {
      /*
    if (protoType.size() > 0 &&
        (protoType.firstElement() instanceof HereReferencePart)) {
    HereReferencePart firstPart = (HereReferencePart)
        protoType.firstElement();
    protoType.setElementAt(firstPart.asAttribReferencePart(), 0);
    }
      */
    comp.setType(prototype.size() == 0 ? null : prototype);
  }
}


Reference ReferenceNoEOF() :
{
  Reference res = new Reference();
  res.setEager(true);
}
{
  [<LAZY> { res.setEager(false);}] BaseReference(res) { return res; }
}

void BaseReference(Reference ref) :
{
}
{
  ReferencePart(ref) (<REFPARTSEP> ReferencePart(ref))*
}

void ReferencePart(Reference ref) :
{
  Token id;
}
{
    (<ROOT> { ref.addElement(ReferencePart.root()); })
  | (<PARENT> { ref.addElement(ReferencePart.parent()); })
  | (<ATTRIB> id=<WORD> { ref.addElement(ReferencePart.attrib(id.image)); })
  | (<HERE> id=<WORD> { ref.addElement(ReferencePart.here(id.image)); })
  | (<THIS> { ref.addElement(ReferencePart.thisref()); })
  | (<PROPERTY> id=<WORD> { ref.addElement(ReferencePart.property(id.image));})
  | (<IPROPERTY> id=<WORD> { ref.addElement(ReferencePart.iproperty(id.image));})
  | (<HOST> (
       (id=<WORD> { ref.addElement(ReferencePart.host(id.image));})
      |(id=<STRING> { ref.addElement(ReferencePart.host(id.image.substring(1, id.image.length() - 1)));})
     ))
  | (<PROCESS> { ref.addElement(ReferencePart.process());})
  | (id=<WORD> { if (ref.size() == 0) // id in first position - treat as an attrib, not a here
             ref.addElement(ReferencePart.attrib(id.image));
                 else
             ref.addElement(ReferencePart.here(id.image));
                })
}


Object Basic() :
{
  Object res, tmp;
  Token id;
}
{
  (
     (res=Primitive())
   | (<LBRACKET> { res = new Vector(); }
          [tmp=SimpleValue() { ((Vector)res).addElement(tmp); }
          (<COMMA> tmp=SimpleValue() { ((Vector)res).addElement(tmp); })*]
      <RBRACKET> {
      SFComponentDescription component =
          SFParser.componentFactory("default");
      for (Enumeration e = ((Vector)res).elements(); e.hasMoreElements(); ) {
          Object attribute = e.nextElement();
          Reference name = new Reference(ReferencePart.here("unique" + nextId++));
          component.sfContext().put(name, attribute);
          if (attribute instanceof SFComponentDescription)
          ((SFComponentDescription)attribute).setParent(component);
      }
      component.sfContext().put("phase.function", "org.smartfrog.sfcore.languages.sf.functions.Vector");
      res = component;
      })
    ) { return res; }
}

Object Primitive() :
{
  Object res, tmp;
  Token id;
}
{
  (
   (<NULL> {res = SFNull.get();})
   | (res=String())
   | (res=Number())
   | (res=Boolean())
   | (res=BinArray())
   | (<VECTORSTART> { res = new Vector(); }
          [tmp=Primitive() { ((Vector)res).addElement(tmp); }
          (<COMMA> tmp=Primitive() { ((Vector)res).addElement(tmp); })*]
      <VECTOREND>)
  ) { return res; }
}



Number Number() :
{
    Token res;
    Number num;
}
{
  (
    res=<DOUBLE >
    {
      if (res.image.toUpperCase().charAt(res.image.length() - 1) == 'D')
        num =  Double.valueOf(res.image.substring(0, res.image.length() - 1));
      else
        num =  Double.valueOf(res.image.substring(0, res.image.length()));
    }
  | res=<FLOAT>
    {
      num = Float.valueOf(res.image.substring(0, res.image.length() - 1));
    }
  | res=<INTEGER>
    {
      num = Integer.valueOf(res.image);
    }
  | res=<LONG>
    {
      num = Long.valueOf(res.image.substring(0, res.image.length() - 1));
    }
  ) { return num; }
}

String String() :
{
    Token res;
    String s;
}
{
  (  ( res=<STRING> { s = fixEscapes(res.image.substring(1, res.image.length() - 1)); })
   | ( res=<MULTILINESTRING> { s = fixEscapes(res.image.substring(2, res.image.length() - 1)); })
  ) {
      return s;
    }
}

Boolean Boolean() :
{
    Token res;
    Boolean b;
}
{
  (  res = <TRUE> { b = Boolean.TRUE; }
   | res = <FALSE> { b = Boolean.FALSE; }
  ) { return b; }
}

SFBinaryArray BinArray() :
{
    Token res;
    String s;
}
{
  (  ( res=<BINARRAY> { s = eliminateWhitespace(res.image.substring(5, res.image.length() - 1)); })
  ) {
      System.out.println("processing binary array");

      try {
          SFBinaryArray ba = new SFBinaryArray(s, res.beginLine, res.beginColumn);
          return ba;
      } catch (Exception e) {
          throw new ParseException("error constructing binary data:" + e.toString());
      }
    }
}


