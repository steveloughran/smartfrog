options {
  DEBUG_TOKEN_MANAGER = false;
  STATIC=false;
  JAVA_UNICODE_ESCAPE = true;
  FORCE_LA_CHECK=true;
}

PARSER_BEGIN(DefaultParser)
package org.smartfrog.sfcore.languages.sf;

import org.smartfrog.sfcore.languages.sf.sfcomponentdescription.SFComponentDescriptionImpl;
import org.smartfrog.sfcore.languages.sf.sfcomponentdescription.SFComponentDescription;
import org.smartfrog.sfcore.reference.ReferencePart;
import org.smartfrog.sfcore.reference.HostReferencePart;
import org.smartfrog.sfcore.reference.PropertyReferencePart;
import org.smartfrog.sfcore.reference.IPropertyReferencePart;
import org.smartfrog.sfcore.reference.HereReferencePart;
import org.smartfrog.sfcore.reference.RootReferencePart;
import org.smartfrog.sfcore.reference.AttribReferencePart;
import org.smartfrog.sfcore.reference.ThisReferencePart;
import org.smartfrog.sfcore.reference.Reference;
import org.smartfrog.sfcore.common.SFNull;
import java.io.InputStream;
import java.util.Vector;
import java.util.Enumeration;

public class DefaultParser {
  protected IncludeHandler includeHandler;
  static int nextId = 0;

  public DefaultParser(InputStream is, IncludeHandler handler) {
    this(is);
    this.includeHandler = handler;
  }

  private String fixEscapes(String s) {
    int index = 0;
    int length = s.length();
    StringBuffer fixed = new StringBuffer(length);

    while (index < length) {
      if (s.charAt(index) == '\\') {
        index++;
        switch (s.charAt(index)) {
          case 'n':
            fixed.append('\n'); break;
          case 't':
            fixed.append('\t'); break;
          case 'b':
            fixed.append('\b'); break;
          case 'r':
            fixed.append('\r'); break;
          case 'f':
            fixed.append('\f'); break;
          case '0': case '1': case '2': case '3':
          case '4': case '5': case '6': case '7':
            int i = ((s.charAt(index) - '0') * 64) +
                    ((s.charAt(index+1) - '0') * 8) +
                    ((s.charAt(index+2) - '0'));
            index = index + 2;
            fixed.append((char) i);
            break;
          default:
            fixed.append(s.charAt(index));
        }
      } else {
        fixed.append(s.charAt(index));
      }
      index++;
    }
    return fixed.toString();
  }

  protected Vector parseInclude(String fName) throws ParseException {
    try {
      return includeHandler.parseInclude(fName);
    } catch (TokenMgrError tex) {
      throw new TokenMgrError("In include file " + fName + " : " +
                              tex.getMessage(),
                              tex.errorCode);
    } catch (Exception ex) {
      throw new ParseException("Parsing include file " + fName + " : " +
                               ex.getMessage());
    }
  }

}

PARSER_END(DefaultParser)


/* WHITE SPACE */

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* COMMENTS */

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
| <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
| "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

TOKEN : /* reserved words */
{
   <SEMICOLON: ";">
 | <COMMA: ",">
 | <LBRACE: "{">
 | <RBRACE: "}">
 | <LBRACKET: "[">
 | <RBRACKET: "]">
 | <REFPARTSEP: ":">
 | <NULLPROTO: "NULL">
 | <UNIQUE: "--">
 | <EXTENDS: "extends">
 | <LAZY: "LAZY">
 | <ROOT: "ROOT">
 | <ATTRIB: "ATTRIB">
 | <THIS: "THIS">
 | <PROPERTY: "PROPERTY">
 | <IPROPERTY: "IPROPERTY">
 | <PARENT: "PARENT">
 | <HOST: "HOST">
 | <PROCESS: "PROCESS">
 | <INCLUDE: "#include">
 | <TRUE: "true">
 | <FALSE: "false">
}

TOKEN :
{
  < WORD: <LETTER> (<LETTER>|<DIGIT>|<SPECIAL>)* >
| < #SPECIAL: [".", "_", "-"] >
| < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}


TOKEN : /* Literals */
{
      <STRING:
      ("\"" (
          (~["\"","\\","\n","\r"])
          | ("\\"
              ( ["n","t","b","r","f","\\","'","\""]
              | ["0"-"3"] ["0"-"7"] ["0"-"7"]
              )
            )
        )* "\"")
      >
    | <MULTILINESTRING: ("##" (
          (~["#","\\"])
          | ("\\"
              ( ["n","t","b","r","f","\\","'","#"]
              | ["0"-"3"] ["0"-"7"] ["0"-"7"]
              )
            )
        )* "#")
      >
    | <INTEGER: (("-")? ["0"-"9"] (["0"-"9"])*)
        | "0" >
    | <#FLOAT_BASE:
        ("-")?
        (
          (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?
        | "." (["0"-"9"])+ (<EXPONENT>)?
        | (["0"-"9"])+ <EXPONENT>
        | (["0"-"9"])+ (<EXPONENT>)?
        )
      >
    | < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
    | <DOUBLE:
        <FLOAT_BASE> (["d", "D"])?
      >
    | <LONG:
        <INTEGER> (["l", "L"])?
      >
    | <FLOAT:
        <FLOAT_BASE> ["f", "F"]
      >
}


/*
 * Entry point to the grammar for component parser
 */

void Attributes(SFComponentDescription descr) :
{
}
{
  AttributesNoEOF(descr) <EOF>
}

/*
 * Entry point for default include handler
 */

Vector AttributeList() :
{
    Vector res;
}
{
    res = AttributeListNoEOF() <EOF>
	{ return res; }
}

/*
 * Entry point for Reference parser
 */

Reference Reference() :
{
  Reference res;
}
{
    res = ReferenceNoEOF() <EOF>
	{ return res; }
}

/*
 * Main body of grammar
 */
void AttributesNoEOF(SFComponentDescription descr) :
{
  Vector attrs;
}
{
  attrs = AttributeListNoEOF()
  {
    for (Enumeration e = attrs.elements(); e.hasMoreElements(); ) {
      Object[] attribute = (Object[])e.nextElement();
      descr.getContext().put(attribute[0], attribute[1]);
      if (attribute[1] instanceof SFComponentDescription)
        ((SFComponentDescription)attribute[1]).setParent(descr);
    }
  }
}


Vector AttributeListNoEOF() :
{
    Vector res = new Vector(10, 5);
    Object[] c;
    String fName;
}
{
    ( c = Attribute() {res.addElement(c);}
    | ( <INCLUDE> fName = String()
         { Vector tmp = parseInclude(fName);
           for(Enumeration e = tmp.elements(); e.hasMoreElements(); )
             res.addElement(e.nextElement());
       } )
    | <SEMICOLON>
    )*
    { return res; }
}

Object[] Attribute() :
{
  Object[] attribute = new Object[2];
  Reference name = new Reference();
}
{
  (Name(name) attribute[1]=Value()
   { if (name.size() == 1)
      attribute[0] = ((HereReferencePart)name.firstElement()).value;
     else
      attribute[0] = name;
     //if (attribute[1] == null) attribute[1] = ((HereReferencePart)name.lastElement()).value;
     if (attribute[1] == null) attribute[1] = SFNull.get();
     return attribute;
   })
}


void Name(Reference res) :
{
  res.setEager(true);
  Token t;
}
{
    <UNIQUE>
    {
        res.addElement(ReferencePart.here("unique" + nextId++));
    }
    |	(IdReferencePart(res) [(<REFPARTSEP> Name(res))])
}


Object Value() :
{
  Object res=null;
}
{
    (
    res=Component()
    | res=ReferenceNoEOF() <SEMICOLON>
    | res=Basic() <SEMICOLON>
    | <SEMICOLON>
    ) { return res; }
}

SFComponentDescription Component() :
{
  SFComponentDescription component;
  String componentClass="default";
  Token id;
}
{
  <EXTENDS> [ <REFPARTSEP> id=<WORD> { componentClass = id.image; } ] component=ComponentType(componentClass)
   { return component; }
}

SFComponentDescription ComponentType(String componentClass) :
{
  SFComponentDescription component =
      SFParser.componentFactory(componentClass);
}
{
  ( EagerComponent(component) | LazyComponent(component) )
    { return component; }
}

void EagerComponent(SFComponentDescription comp) :
{
}
{
  BaseComponent(comp) { comp.setEager(true); }
}

void LazyComponent(SFComponentDescription comp) :
{
}
{
  <LAZY> BaseComponent(comp) { comp.setEager(false); }
}


void BaseComponent(SFComponentDescription comp) :
{
  Reference protoType = new Reference();
  protoType.setEager(true);
}
{
  [ <NULLPROTO> | BaseReference(protoType) ]
  (<SEMICOLON>| (<LBRACE> AttributesNoEOF(comp) <RBRACE>) )
  {
    if (protoType.size() > 0 &&
        (protoType.firstElement() instanceof HereReferencePart)) {
      HereReferencePart firstPart = (HereReferencePart)
        protoType.firstElement();
      protoType.setElementAt(firstPart.asAttribReferencePart(), 0);
    }
    comp.setType(protoType.size() == 0 ? null : protoType);
  }
}


Reference ReferenceNoEOF() :
{
  Reference res = new Reference();
  res.setEager(true);
}
{
  [<LAZY> { res.setEager(false);}] BaseReference(res) { return res; }
}

void BaseReference(Reference ref) :
{
}
{
  ReferencePart(ref) (<REFPARTSEP> ReferencePart(ref))*
}

void ReferencePart(Reference ref) :
{
  Token id;
}
{
    (<ROOT> { ref.addElement(ReferencePart.root()); })
  | (<PARENT> { ref.addElement(ReferencePart.parent()); })
  | (<ATTRIB> id=<WORD> { ref.addElement(ReferencePart.attrib(id.image)); })
  | (<THIS> { ref.addElement(ReferencePart.thisref()); })
  | (<PROPERTY> id=<WORD> { ref.addElement(ReferencePart.property(id.image));})
  | (<IPROPERTY> id=<WORD> { ref.addElement(ReferencePart.iproperty(id.image));})
  | (<HOST> (
       (id=<WORD> { ref.addElement(ReferencePart.host(id.image));})
      |(id=<STRING> { ref.addElement(ReferencePart.host(id.image.substring(1, id.image.length() - 1)));})
     ))
  | (<PROCESS> { ref.addElement(ReferencePart.process());})
  | IdReferencePart(ref)
}

void IdReferencePart(Reference ref) :
{
  Token id;
}
{
  (id=<WORD> { ref.addElement(ReferencePart.here(id.image)); })
}

Object Basic() :
{
  Object res, tmp;
  Token id;
}
{
  (
     (res=String())
   | (res=Number())
   | (res=Boolean())
   | (<LBRACKET> { res = new Vector(); }
          [tmp=Basic() { ((Vector)res).addElement(tmp); }
          (<COMMA> tmp=Basic() { ((Vector)res).addElement(tmp); })*]
      <RBRACKET>)
    ) { return res; }
}

Number Number() :
{
    Token res;
    Number num;
}
{
  (
    res=<DOUBLE >
    {
      if (res.image.toUpperCase().charAt(res.image.length() - 1) == 'D')
        num =  Double.valueOf(res.image.substring(0, res.image.length() - 1));
      else
        num =  Double.valueOf(res.image.substring(0, res.image.length()));
    }
  | res=<FLOAT>
    {
      num = Float.valueOf(res.image.substring(0, res.image.length() - 1));
    }
  | res=<INTEGER>
    {
      num = Integer.valueOf(res.image);
    }
  | res=<LONG>
    {
      num = Long.valueOf(res.image.substring(0, res.image.length() - 1));
    }
  ) { return num; }
}

String String() :
{
    Token res;
    String s;
}
{
  (  ( res=<STRING> { s = fixEscapes(res.image.substring(1, res.image.length() - 1)); })
   | ( res=<MULTILINESTRING> { s = fixEscapes(res.image.substring(2, res.image.length() - 1)); })
  ) {
     /* if (s.equals("true") | s.equals("false"))
        System.out.println("Using strings to represent boolean-valued attributes is deprecated - use true or false");
     */
      return s;
    }
}

Boolean Boolean() :
{
    Token res;
    Boolean b;
}
{
  (  res = <TRUE> { b = Boolean.TRUE; }
   | res = <FALSE> { b = Boolean.FALSE; }
  ) { return b; }
}
