<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>SmartFrog Reference Manual</title>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="breadtrail">
<script src="skin/breadcrumbs.js" language="JavaScript" type="text/javascript"></script>
</div>
<div class="header">
<div class="grouplogo">
<a href="http://www.SmartFrog.org/"><img class="logoImage" alt="SmartFrog" src="images/group.png" title="SmartFrog"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.SmartFrog.org"><img class="logoImage" alt="" src="images/frog.gif"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="index.html">Home</a>
</li>
<li>
<a class="base-not-selected" href="sfcore.html">SmartFrog Core</a>
</li>
<li>
<a class="base-not-selected" href="comp.html">Components</a>
</li>
<li>
<a class="base-not-selected" href="anttasks.html">Ant Tasks</a>
</li>
<li>
<a class="base-not-selected" href="extras.html">Extras</a>
</li>
<li>
<a class="base-not-selected" href="examples.html">Examples</a>
</li>
<li>
<a class="base-not-selected" href="jdocs_index.html">Java Docs</a>
</li>
<li>
<a class="base-not-selected" href="Copyright.html">Copyright</a>
</li>
<li>
<a class="base-not-selected" href="lpgl.html">License Terms</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="content">
<h1>SmartFrog Reference Manual</h1>
<div class="abstract"></div>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Part+1%3A+An+Introduction+to+SmartFrog">Part 1: An Introduction to SmartFrog </a>
<ul class="minitoc">
<li>
<a href="#Introduction">Introduction </a>
</li>
<li>
<a href="#Aims+Of+The+SmartFrog+Framework+-+Basic">Aims Of The SmartFrog Framework - Basic</a>
<ul class="minitoc">
<li>
<a href="#Configuration">Configuration</a>
</li>
<li>
<a href="#The+SmartFrog+Framework">The SmartFrog Framework</a>
</li>
<li>
<a href="#Notation">Notation</a>
</li>
<li>
<a href="#Components">Components</a>
</li>
<li>
<a href="#Environment">Environment</a>
</li>
<li>
<a href="#Final+Comments">Final Comments</a>
</li>
</ul>
</li>
<li>
<a href="#The+Anatomy+of+SmartFrog">The Anatomy of SmartFrog</a>
</li>
<li>
<a href="#Building+Systems+with+SmartFrog">Building Systems with SmartFrog</a>
</li>
</ul>
</li>
<li>
<a href="#Part+2%3A+The+SmartFrog+Notation+and+Core+Data+Model">Part 2: The SmartFrog Notation and Core Data Model</a>
<ul class="minitoc">
<li>
<a href="#Introduction-N10168">Introduction</a>
</li>
<li>
<a href="#The+Primary+SmartFrog+Notation">The Primary SmartFrog Notation</a>
<ul class="minitoc">
<li>
<a href="#Background">Background</a>
</li>
<li>
<a href="#Attributes">Attributes</a>
</li>
<li>
<a href="#Include+Files">Include Files</a>
</li>
<li>
<a href="#sfConfig">sfConfig</a>
</li>
</ul>
</li>
<li>
<a href="#Resolution+%E2%80%93+Semantics+For+The+SmartFrog+Notation">Resolution &ndash; Semantics For The SmartFrog Notation </a>
<ul class="minitoc">
<li>
<a href="#Type+Resolution">Type Resolution</a>
</li>
<li>
<a href="#Placement+Resolution">Placement Resolution</a>
</li>
<li>
<a href="#Link+Resolution">Link Resolution</a>
</li>
<li>
<a href="#The+Difference+Between+Types+and+Links">The Difference Between Types and Links</a>
</li>
</ul>
</li>
<li>
<a href="#Template+Parameterization+Pattern">Template Parameterization Pattern</a>
</li>
<li>
<a href="#Functions+and+operators">Functions and operators</a>
</li>
<li>
<a href="#Predicates%2C+Assertions+and+Schemas">Predicates, Assertions and Schemas</a>
</li>
<li>
<a href="#Mapping+to+the+Core+Data+Model">Mapping to the Core Data Model</a>
</li>
<li>
<a href="#Primary+Language+Processing">Primary Language Processing</a>
<ul class="minitoc">
<li>
<a href="#Functions">Functions </a>
</li>
<li>
<a href="#Predicates">Predicates </a>
</li>
</ul>
</li>
<li>
<a href="#Programming+with+the+Parser">Programming with the Parser</a>
<ul class="minitoc">
<li>
<a href="#Background-N10DBB">Background</a>
</li>
<li>
<a href="#Summary+of+Language+Processing">Summary of Language Processing</a>
</li>
<li>
<a href="#The+Parser">The Parser</a>
</li>
</ul>
</li>
<li>
<a href="#The+Common+Data+Model">The Common Data Model</a>
<ul class="minitoc">
<li>
<a href="#Basic+Values">Basic Values</a>
</li>
<li>
<a href="#Reference">Reference</a>
</li>
<li>
<a href="#ComponentDescription">ComponentDescription</a>
</li>
</ul>
</li>
<li>
<a href="#The+SmartFrog+Grammar+Rules">The SmartFrog Grammar Rules</a>
</li>
<li>
<a href="#The+SmartFrog+Lexical+Rules">The SmartFrog Lexical Rules</a>
</li>
<li>
<a href="#Predefined+SmartFrog+Functions">Predefined SmartFrog Functions</a>
<ul class="minitoc">
<li>
<a href="#Unary+Operators">Unary Operators</a>
</li>
<li>
<a href="#Binary+Operators">Binary Operators</a>
</li>
<li>
<a href="#Nary+Operators">Nary Operators</a>
</li>
<li>
<a href="#Other+Functions">Other Functions</a>
</li>
</ul>
</li>
<li>
<a href="#Schemas">Schemas</a>
</li>
<li>
<a href="#Comparing+the+SmartFrog+Notation+with+XML">Comparing the SmartFrog Notation with XML</a>
</li>
</ul>
</li>
<li>
<a href="#Part+3%3A+The+SmartFrog+Component+Model">Part 3: The SmartFrog Component Model</a>
<ul class="minitoc">
<li>
<a href="#Introduction-N11A14">Introduction</a>
<ul class="minitoc">
<li>
<a href="#Components-N11A19">Components</a>
</li>
<li>
<a href="#Defining+Components+in+the+Language">Defining Components in the Language</a>
</li>
</ul>
</li>
<li>
<a href="#The+SmartFrog+Component+Model">The SmartFrog Component Model</a>
<ul class="minitoc">
<li>
<a href="#Applications+As+Component+Collections">Applications As Component Collections</a>
</li>
<li>
<a href="#Applications+and+Component+Descriptions">Applications and Component Descriptions</a>
</li>
<li>
<a href="#Representing+Components+With+Attributes">Representing Components With Attributes</a>
</li>
<li>
<a href="#Lifecycles">Lifecycles</a>
</li>
<li>
<a href="#The+SmartFrog+API">The SmartFrog API</a>
</li>
</ul>
</li>
<li>
<a href="#Primitives">Primitives</a>
<ul class="minitoc">
<li>
<a href="#Template+Methods">Template Methods</a>
</li>
<li>
<a href="#Utility+Methods">Utility Methods</a>
</li>
</ul>
</li>
<li>
<a href="#Compounds">Compounds</a>
<ul class="minitoc">
<li>
<a href="#Compound+Component+Descriptions">Compound Component Descriptions</a>
</li>
<li>
<a href="#The+Compound+Interface">The Compound Interface</a>
</li>
<li>
<a href="#CompoundImpl">CompoundImpl</a>
</li>
</ul>
</li>
<li>
<a href="#Component+Template">Component Template</a>
</li>
<li>
<a href="#Well-Known+Attributes">Well-Known Attributes</a>
</li>
</ul>
</li>
<li>
<a href="#Part+4%3A+The+SmartFrog+Runtime">Part 4: The SmartFrog Runtime</a>
<ul class="minitoc">
<li>
<a href="#Deployment+In+Detail">Deployment In Detail</a>
<ul class="minitoc">
<li>
<a href="#Selecting+Deployers">Selecting Deployers</a>
</li>
<li>
<a href="#Termination">Termination </a>
</li>
</ul>
</li>
<li>
<a href="#Attributes%2C+LAZY+Links+and+RMI+Object+References">Attributes, LAZY Links and RMI Object References</a>
<ul class="minitoc">
<li>
<a href="#Accessing+Attributes+At+Runtime">Accessing Attributes At Runtime </a>
</li>
<li>
<a href="#LAZY+links+And+RMI">LAZY links And RMI </a>
</li>
<li>
<a href="#The+Moving+ROOT">The Moving ROOT</a>
</li>
<li>
<a href="#Modifying+Attributes+Values">Modifying Attributes Values</a>
</li>
<li>
<a href="#Trapping+Accesses+And+Reference+Adaptors">Trapping Accesses And Reference Adaptors</a>
</li>
<li>
<a href="#sfHost+and+sfProcess+Attributes">sfHost and sfProcess Attributes</a>
</li>
</ul>
</li>
<li>
<a href="#Attribute+Serialization">Attribute Serialization</a>
</li>
<li>
<a href="#Liveness">Liveness</a>
</li>
<li>
<a href="#Hooks">Hooks</a>
</li>
<li>
<a href="#Processes+and+Java+Virtual+Machines">Processes and Java Virtual Machines</a>
<ul class="minitoc">
<li>
<a href="#SmartFrog+Resource+References">SmartFrog Resource References</a>
</li>
<li>
<a href="#SmartFrog+Action+Descriptor">SmartFrog Action Descriptor</a>
</li>
<li>
<a href="#SFSystem+And+Command-Line+Parameters">SFSystem And Command-Line Parameters</a>
</li>
<li>
<a href="#Process+Compounds">Process Compounds</a>
</li>
<li>
<a href="#Types+Of+Processes">Types Of Processes</a>
</li>
<li>
<a href="#Process+Attributes">Process Attributes</a>
</li>
<li>
<a href="#Accessing+Process+Compounds+And+Attributes">Accessing Process Compounds And Attributes</a>
</li>
<li>
<a href="#Creating+And+Naming+Sub-Processes">Creating And Naming Sub-Processes</a>
</li>
<li>
<a href="#Naming+Applications">Naming Applications</a>
</li>
<li>
<a href="#HOST+and+PROCESS+Links">HOST and PROCESS Links</a>
</li>
</ul>
</li>
<li>
<a href="#The+SmartFrog+Security+Model">The SmartFrog Security Model</a>
<ul class="minitoc">
<li>
<a href="#Introduction-N12851">Introduction </a>
</li>
<li>
<a href="#Threat+Model">Threat Model </a>
</li>
<li>
<a href="#Security+Policy">Security Policy </a>
</li>
<li>
<a href="#Security+Mechanisms">Security Mechanisms </a>
</li>
</ul>
</li>
<li>
<a href="#Properties">Properties</a>
</li>
</ul>
</li>
<li>
<a href="#Part+5%3A+A+SmartFrog+Example">Part 5: A SmartFrog Example</a>
<ul class="minitoc">
<li>
<a href="#Example">Example</a>
<ul class="minitoc">
<li>
<a href="#The+Printer">The Printer </a>
</li>
<li>
<a href="#The+Generator">The Generator </a>
</li>
<li>
<a href="#Compiling+the+Components">Compiling the Components</a>
</li>
<li>
<a href="#The+Combined+Application">The Combined Application</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#Appendix+A.">Appendix A.</a>
<ul class="minitoc">
<li>
<a href="#Exit+Codes+for+SmartFrog+Scripts">Exit Codes for SmartFrog Scripts</a>
</li>
</ul>
</li>
</ul>
</div>
<p class="P70"></p>
<p class="P71"></p>
<p class="P71"></p>
<p class="P71"></p>
<p class="P71"></p>
<p class="P71"></p>
<p class="P71">The SmartFrog Reference Manual</p>
<p class="Subtitle"></p>
<p class="P72">A guide to programming with the SmartFrog Framework</p>
<p class="P72"></p>
<p class="P1">For SmartFrog Version 3.06</p>
<p class="P1">Localized for UK English / A4 Paper</p>
<p class="Subtitle"></p>
<p class="Text body"></p>
<p class="Text body"></p>
<p class="Text body"></p>
<p class="P72"></p>
<p class="P73"></p>
<p class="P74"></p>
<p class="P75"></p>
<p class="P75"></p>
<p class="P76"></p>
<p class="Heading">Table Of Contents</p>
<p class="P77"></p>
<p class="P82"></p>
<a name="N10043"></a><a name="Part+1%3A+An+Introduction+to+SmartFrog"></a>
<h2 class="boxed">Part 1: An Introduction to SmartFrog </h2>
<div class="section">
<a name="N10048"></a><a name="Introduction"></a>
<h3 class="boxed">Introduction </h3>
<p class="Text body">This manual is aimed at those wanting to use and understand the workings of SmartFrog. It is not a basic tutorial, though hopefully it is not too obscure, either. The notation is described fully, as is the component model. The framework, however, is only outlined. For a detailed reference description of the framework APIs, users should refer to the accompanying <span class="T5">Javadoc</span> files.</p>
<p class="P84">The manual is divided into several sections:</p>
<ol>
<li>
<p class="P85">The aims of the SmartFrog system: defining the basic goals of the system, thus ensuring that there is an awareness of these aims to aid in understanding the technical details.</p>
</li>
<li>
<p class="P85">The SmartFrog notation, describing the details and semantics of the first configuration description notation to be supported by the SmartFrog framework; other notations are in preparation but are not included in this manual.</p>
</li>
<li>
<p class="P85">The SmartFrog component model and framework, defining how to write components and run them within the SmartFrog system.</p>
</li>
<li>
<p class="P85">The SmartFrog security infrastructure, describing how SmartFrog ensures that systems are appropriately protected.</p>
</li>
</ol>
<p class="P86">A separate document covers the details of installing and running the SmartFrog system. A number of examples are also provided and documented as part of the framework.</p>
<p class="P86">This document contains sections that assume differing levels of knowledge and familiarity with the SmartFrog system. It is suggested that a first-time user read only those parts that are essential before experimenting, then progressing to more advanced topics as familiarity develops. To aid in this, sections or sub-sections are tagged with one of the following labels: <span class="T2">basic</span>, <span class="T2">advanced</span> and <span class="T2">expert</span> indicating progressively more advanced topics. If a section is tagged as a particular level of complexity, and a sub-section is considered to be of higher level, the sub-section will be tagged with this higher level.</p>
<a name="N1007A"></a><a name="Aims+Of+The+SmartFrog+Framework+-+Basic"></a>
<h3 class="boxed">Aims Of The SmartFrog Framework - Basic</h3>
<a name="N1007F"></a><a name="Configuration"></a>
<h4>Configuration</h4>
<p class="P87">For many years HP Labs has been involved in the development of large-scale distributed systems, and in particular management and measurement systems. From this experience, it became clear that configuration is often <span class="T5">the</span> major hurdle in the development, adoption and use of such large systems. This experience is supported by evidence from other domains, such as telecom service platforms, large scale e-service hosting environments, and so on. The weight of evidence clearly indicates that many of the problematic aspects of developing, delivering and maintaining such systems are resolved by the introduction of a well-designed, intuitive configuration system. These observations led to the development of the SmartFrog configuration framework described in this manual.</p>
<p class="P87">There are several significant reasons for investing in a powerful and flexible configuration environment, which in combination illustrate why this area is in many cases essential for the success of a large system. These are discussed below as a clear understanding of these reasons help in determining the requirements for a supporting environment.</p>
<a name="N1008E"></a><a name="Increased+operational+reliability"></a>
<h5>Increased operational reliability </h5>
<p class="P87">Configuration errors are the major cause of system failure. It is no coincidence that at least one system development inside of HP has termed the development of a tailored configuration system as its &lsquo;high-availability programme&rsquo;. It is pointless spending money on expensive replicated databases and computation if they contain wrong data, or are carrying out the wrong calculations. From hard experience, they know that the human element is by far the weakest point in any system of even moderate complexity.</p>
<p class="P87">Many systems are required to be resilient to a (small) number of failures, providing support for dynamic system reconfiguration in the case of such failures. This should be provided via failure detection mechanisms triggering re-configuration actions within the system components themselves (such as instigating fail-over) and through the configuration system to ensure a consistent view of the current configuration and to provide appropriate re-configuration policy (for example, where to create the replacement components in the case of a processor failure).</p>
<a name="N10099"></a><a name="Improved+quality"></a>
<h5>Improved quality</h5>
<p class="P87">After examining the architecture and design of several large-scale systems it became clear that the developers of the various component sub-systems had each created their own configuration infrastructure, often not realizing that this area is of great importance to the overall system. Each makes separate decisions as to format of the data, how it is stored, and so on. In addition, since some aspects of configuration such as configuration description or failure detection and recovery can be extremely complex, the separate development groups frequently do not utilize best practice.</p>
<a name="N100A1"></a><a name="Reduced+cost"></a>
<h5>Reduced cost</h5>
<p class="P87">Costs can arise for several reasons and in several areas such as development, installation and maintenance. For each of these, providing well-defined best-practice procedures and well-implemented support environments for configuration can save significant time and hence money. From experience with several systems, the majority of support calls for these systems (and hence source of recurring cost to the platform provider) come from configuration issues. </p>
<a name="N100A9"></a><a name="Assured+correctness+and+consistency"></a>
<h5>Assured correctness and consistency</h5>
<p class="P89">Validation rules need to be provided to ensure that a configuration is correct before it is deployed into the running system. These rules should include dependencies between various system components (e.g. version dependencies) as well as rules governing repetition (e.g. each web server should run the xxx process and &hellip;), replication (e.g. two cooperating instances of this component should exist for reliability...), location (e.g. this component should be close to the database...), and so on. Tools for modelling and reasoning about the configurations are required.</p>
<p class="P87">Given a configuration that has been defined and validated, the configuration must then be correctly and verifiably instantiated, preferably automatically, with appropriate error handling in the case of failure. Discovery services must be present to enable binding of services to each other as defined in the configuration, and status monitoring capabilities are required to provide management tools with the ability to monitor the overall state of the system and to ensure it is correct with respect to the desired configuration. </p>
<p class="P87">Complex systems may in fact be impossible to configure manually if the requirements change faster than individuals ability to track these changes and carry out the complex reconfiguration tasks. In these cases, automated, adaptive configuration, driven from general rules and auto discovery, is the only solution.</p>
<a name="N100B7"></a><a name="Increased+security"></a>
<h5>Increased security</h5>
<p class="P87">System configurations are vital to the integrity of the system. Consequently, in many environments where physical and network isolation cannot be guaranteed, a high level of basic system security must be provided. This involves not only protecting the configuration data itself from unauthorized access, but also the run-time environment must be secure. This includes discovery protocols, component instantiation services, management services and so on. It is typically hard to provide a secure environment when many independent and diverse techniques are used to provide the configuration, so again a single solution implementing best practice is an essential step to ensure system integrity. </p>
<a name="N100BF"></a><a name="Improved+Customer+Experience"></a>
<h5>Improved Customer Experience</h5>
<p class="P87">A major issue to be considered in designing systems is that different classes of user have different requirements. All too frequently, the configuration information is designed for the convenience of the system developer not the system operator. Data is required in a form that often does not reflect the skills of the administrator, or maybe is replicated in several files, or distributed over many processors, each of which can lead to a slow and error-prone configuration process. Configuration should be done in ways useful to the operator and adapted to the system and not by expecting the operator to adapt. This can be expensive and hard to implement unless there is extensive support for the systems developers.</p>
<a name="N100C7"></a><a name="The+SmartFrog+Framework"></a>
<h4>The SmartFrog Framework</h4>
<p class="P87">SmartFrog is a framework for the development of configuration-driven systems. It was originally designed as a framework for building and managing large monitoring systems where flexible configurations are essential. SmartFrog is currently in use within several products, though it is not a product in its own right.</p>
<p class="P87">The name reflects its basic design concept &ndash; the <span class="T15">Smart</span> <span class="T15">Fr</span>amework for <span class="T15">O</span>bject <span class="T15">G</span>roups. It defines systems and sub-systems as collections of software components with certain properties. The framework provides mechanisms for describing these component collections, deploying and instantiating them and then managing them during their entire lifecycle. </p>
<p class="P87">The framework consists of three major aspects:</p>
<ol>
<li>
<p class="P90">The SmartFrog configuration description environment, consisting of a description notation and tools to enable the storage, validation and manipulation of these descriptions.</p>
</li>
<li>
<p class="P90">The SmartFrog component model, defining the interfaces that a software component (or a management adapter for a component) should implement. These interfaces are to support the various lifecycle operations such as creation, versioning and termination, as well as management actions such as accessing status information.</p>
</li>
<li>
<p class="P90">The SmartFrog configuration management system, which uses these descriptions and management adapters to instantiate the software components and to monitor them throughout their lifecycle in a secure way, including an integrated run-time environment providing capabilities such as discovery and naming. </p>
</li>
</ol>
<a name="N100F2"></a><a name="Notation"></a>
<h4>Notation</h4>
<p class="Text body">The SmartFrog &lsquo;notation&rsquo; is in fact defined as a set of open data structures. In principle, this definition can support a number of parsers that provide different textual versions of the notation (for example using XML as a surface syntax). Additionally, it&rsquo;s possible to develop GUI tools that allow the users to &ldquo;drag-and-drop&rdquo; their configurations using the data structures as the common form. At this stage, no generic GUI tools are available for SmartFrog, though experimental versions have been built; usually such tools are normally best tailored to a specific class of system.</p>
<p class="Text body">The notation is object-oriented, supporting inheritance and extension of configuration descriptions. These descriptions consist of component definitions, associations and relationships between the components, and workflows associated with the lifecycle of the components and the system as a whole. The descriptions may be parameterized enabling multiple instantiations with different configuration data, and validations may be provided which verify that these instances are correct before an attempt is made to deploy the configuration.</p>
<p class="Text body">The current version of SmartFrog, though in principle able to support multiple textual languages, just provides its own specialized notation &ldquo;out-of-the-box&rdquo;. Others are in preparation for future releases.</p>
<p class="Text body">The notation is not used to define behaviour, merely the structure of collections of components and their relationships with other collections. It is not a programming language. The behavioural part of a component is assumed to be defined in an existing programming language (such as C or Java) and the component will be started as needed by the SmartFrog configuration management system. Currently only Java is tightly integrated. Java adaptors must be used to wrap code written in other languages, and these are relatively simple to implement.</p>
<a name="N10103"></a><a name="Components"></a>
<h4>Components</h4>
<p class="Text body">The component model supported by SmartFrog is a simple, extensible set of interfaces providing access to key management actions &ndash; such as instance creation, configuration, termination, and so on. A component may be fully integrated (i.e. it may implement the defined management interfaces directly, and hence be written in Java) or it may be independent, in which case a management adapter must be provided. Several standard management adapters or base integrated components have been written to provide common behaviours and these may be extended or modified as appropriate.</p>
<p class="Text body">Each component (or adapter) must implement a standard lifecycle, implemented as a set of action routines that the environment invokes in the appropriate order and at the right time to carry out the configuration or other management task required. The lifecycle process is governed and controlled by the definition of workflows within the SmartFrog system to provide a very flexible and adaptable environment for carrying out the various configuration tasks.</p>
<p class="Text body">A complete set of APIs is available to the components that allow them to access the configuration information, locate other components as defined in the configuration and to alter the running configuration if so desired.</p>
<a name="N10111"></a><a name="Environment"></a>
<h4>Environment</h4>
<p class="Text body">The SmartFrog configuration and management infrastructure is supported by a collection of services, such as: </p>
<ul>
<li>
<p class="P91">deployment &ndash; the distribution of code, configuration data and the instantiation of components in the right place with certain &lsquo;transactional&rsquo; guarantees</p>
</li>
<li>
<p class="P91">discovery and naming &ndash; providing a number of binding services to allow components to locate each other and communicate</p>
</li>
<li>
<p class="P91">management &ndash; every component is manageable via tools provided with the framework, via the web, or other consoles (if so configured) with no developer effort.</p>
</li>
</ul>
<p class="Text body">These services are incorporated so as to provide a seamless and coherent programming and configuration model. The benefits of this approach are in providing configuration abstractions to component developers that allow multiple configurations of different scale to be produced without altering the components in any way. The environment is broken into several well-defined functional units, each of which has some specific role to play. Furthermore each of these operates through well-defined and open interfaces, so it is easy to replace the existing functional units, or even to make the selection of which functional unit to use part of the configuration description.</p>
<p class="Text body">For example, suppose a component, say an SS7 stack, requires the use of another, a real-time database for storing connection information to help the recovery process in the case of system failure. This may be done in many ways. For example, the database could name itself under some well-known name in some well-known naming service, and the stack could find it there. Alternatively, the system may use SLP discovery to locate the database, or perhaps look in a file for this location information. Each approach has advantages in different system contexts, but the programmer typically has to decide up front which to support.</p>
<p class="Text body">Not so with the SmartFrog integrated environment. The SmartFrog system supports the notion of a binding and provides multiple ways &ndash; determined by the environment and driven by the configuration descriptions &ndash; for these bindings to be resolved. This includes all the above approaches and others may be added as required. So a programmer need only obtain its binding from the environment and the precise mechanism is handled by the SmartFrog environment as defined by the configuration.</p>
<p class="Text body">SmartFrog is a framework, and is designed to make it easy to provide additional binding mechanisms as they are required &ndash; for example changing the naming service or adding a specialized binding service which uses some other technologies such as databases or directories.</p>
<p class="Text body">This is equally true of the other services. Consider deployment; it is possible to provide different mechanisms for ensuring that a component is created in the right place. For instance, it might be by hostname, or perhaps by some computer&rsquo;s role within the system, or perhaps it needs to be close to another existing component. Each of these location mechanisms may be integrated into the run-time environment and then referenced freely within the configuration descriptions.</p>
<a name="N10135"></a><a name="Final+Comments"></a>
<h4>Final Comments</h4>
<p class="Text body">The design goals for SmartFrog were to produce a very lightweight and flexible configuration and management infrastructure capable of scaling from small systems to very large. This has been achieved through the use of the framework concept and providing users with the ability to alter the low-level semantics by replacing functional units, yet providing standard capabilities by offering default implementations of these units. The system also provides a flexible configuration description notation, with potential for multiple textual or GUI syntaxes to be used targeted at specific system architectures.</p>
<p class="Text body">Applications of SmartFrog have clearly demonstrated that systems are more quickly implemented using the technology, and that the structure imposed upon the implementations by the use of SmartFrog is beneficial to long-term reliability, usability and manageability.</p>
<a name="N10140"></a><a name="The+Anatomy+of+SmartFrog"></a>
<h3 class="boxed">The Anatomy of SmartFrog</h3>
<p class="Text body">This section attempts to lay out the main aspects of the SmartFrog service deployment framework, describe their relationships, and map them into the structure of the reference document. </p>
<p class="Text body">As described in the introduction, it consists of three main aspects:</p>
<ol>
<li>
<p class="P92">The SmartFrog notation, a language in which to describe the configurations, also known as service descriptions.</p>
</li>
<li>
<p class="P92">The SmartFrog component model, the way in which programmers create components that are created and managed by SmartFrog as part of a service and which can interact with the system. These are deployed according to the service description.</p>
</li>
<li>
<p class="P92">The SmartFrog runtime, the collection of services that exist as part of the SmartFrog system. This is also know as the deployment engine, but is strictly a misnomer since it is in reality a collection of predefined components.</p>
</li>
</ol>
<p class="Text body">These various components can be seen from the following outline diagram of a SmartFrog system.</p>
<p class="Text body">These three aspects will now be examined in a little greater detail.</p>
<a name="N1015E"></a><a name="Building+Systems+with+SmartFrog"></a>
<h3 class="boxed">Building Systems with SmartFrog</h3>
</div>
<a name="N10163"></a><a name="Part+2%3A+The+SmartFrog+Notation+and+Core+Data+Model"></a>
<h2 class="boxed">Part 2: The SmartFrog Notation and Core Data Model</h2>
<div class="section">
<a name="N10168"></a><a name="Introduction-N10168"></a>
<h3 class="boxed">Introduction</h3>
<p class="Text body">The statement that there is a SmartFrog notation is a simplification of reality. SmartFrog may support many notations, though it provides a 'standard' primary notation out of the box. To enable this, SmartFrog provides a well-defined interface between the language processing parts of SmartFrog and the run-time as a well-defined data model: the set of Java classes that must be used by the language processing to represent the data delivered to the runtime system.</p>
<p class="Text body">Roughly speaking, the model of SmartFrog language handling is shown in the following diagram:</p>
<p class="Text body">As is illustrated in this diagram, there may be many notations, each with their own language processing, which at the back-end of that processing produces an instance of the data model that can be understood by the remainder of the SmartFrog system. Alternatively, programmes such as a drag-and-drop gui can produce the data in the correct form directly.</p>
<p class="Text body">To support the development and use of additional languages, the SmartFrog framework provides a rudimentary structure for integrating language processors. A language processor is assumed to consist of three major steps: parsing, executing some processing phases, and then conversion to the standard data format. The set of processing phases are assumed to be language specific, including having the empty set of phases.</p>
<p class="Text body">This is illustrated in the diagram above, also showing the associated Java calls used within the framework. These are not important at this stage and are explained in detail later in the reference manual.</p>
<p class="Text body">Note that the core data mode and the primary notation are closely coupled. This means that in effect the core model can in some ways be seen as a true subset of the primary notation &ndash; it could be unparsed into the primary notation and parsed back directly into the core form without requiring any language processing. </p>
<p class="Text body">Indeed, the two are sufficiently close that the Java classes that are used to directly represent parse-trees of the notation are derived from those of the core model, and much of the same terminology is used in both. So for example, an attribute-set in both is called a <span class="T2">Component Description,</span><span class="T1"> the only difference being that in the primary notation this may have a super-type from which it inherits, whereas in the core model it may not.</span>
</p>
<p class="Text body">Each notation is assumed to have an associated name, and this name is used in the construction of a parser (selected via a standard language-name to parser-classname mapping). Furthermore, if text files or URLs are handled by the SmartFrog system, the extension associated with that file is assumed to indicate the name of the notation in use. Thus for the primary notation, files should end with &ldquo;.sf&rdquo;. </p>
<p class="Text body">Once converted to the core format, the data represented may be used in several ways:</p>
<ol>
<li>
<p class="P94">It can be data that is passed to components in the same way as any other data. Indeed many of the components provided as part of the Smart frog distribution exchange such data through their APIs.</p>
</li>
<li>
<p class="P94">It can represent the set of components that should be deployed by the SmartFrog run-time.</p>
</li>
</ol>
<p class="Text body">Now the second case is in fact just a special case of the first, where the data is passed to one of the standard SmartFrog 'Compound' components, such as the <span class="code inline">ProcessCompound</span>, that understands how to interpret these descriptions as that of a distributed set of components. This duality is described in the following diagram:</p>
<p class="Text body"></p>
<p class="Text body">The reference manual the primary notation and the core data model. </p>
<ol>
<li>
<p class="P95">The primary notation is covered in this part of the reference manual. This is the only notation covered in the reference manual.</p>
</li>
<li>
<p class="P95">The programming model for interacting with the language framework is given in section REF. This provides details of how to invoke a parser for a specific notation, how to drive the phase-resolution steps of the language, and finally how to covert to the standardized form for handling within the rest of the SmartFrog framework.</p>
</li>
<li>
<p class="P95">The core data model is described in section REF. This is only a partial description and the primary source of this information should be the Javadoc for the classes involved.</p>
</li>
</ol>
<p class="P10"></p>
<a name="N101B2"></a><a name="The+Primary+SmartFrog+Notation"></a>
<h3 class="boxed">The Primary SmartFrog Notation</h3>
<a name="N101B7"></a><a name="Background"></a>
<h4>Background</h4>
<p class="Text body">The primary SmartFrog notation has been designed to provide users of the SmartFrog framework a simple, yet powerful, attribute description language. As such, the language has similar aims to that of XML - though it predates XML by a couple of years. There are a number of significant differences between XML and the SmartFrog notation that are worth explaining and this is done in a section 15.</p>
<p class="Text body">The primary notation is designed to be very close to the common core data model, but provides a number of additional important useability features, including inheritance, linking, attribute placement, functions and various types of well-formedness predicate. Indeed all of the classes used by the parser to represent the abstract syntax tree are derived from those of the core data model.</p>
<a name="N101C2"></a><a name="Attributes"></a>
<h4>Attributes</h4>
<p class="Text body">A SmartFrog description consists of an ordered collection of attributes. The attributes are ordered because several of the operations in the SmartFrog framework require an order, for example the order in which the configuration should be instantiated.</p>
<p class="Text body">Each attribute has a name and a value, this value being either a simple value (integer, string, etc.), or an ordered collection of attributes known as a component description. This recursion provides a tree of attributes, the leaves of which are the basic values. A value may also be provided by reference to another attribute. This is described by the following BNF, where <span class="T2">Stream</span> indicates the entry point to the SmartFrog parser.</p>
<p class="Code indented">Stream ::= AttributeList</p>
<p class="Code indented"></p>
<p class="Code indented">AttributeList::= (Attribute</p>
<p class="Code indented">| <span class="T6">#include</span> String</p>
<p class="Code indented">| <span class="T6">; </span><span class="T9">//</span><span class="T6"> </span><span class="T9">allow arbitrary extra ";"</span>
</p>
<p class="Code indented">)*</p>
<p class="Code indented"></p>
<p class="Code indented">Attribute::= Name Value</p>
<p class="Code indented"></p>
<p class="Code indented">Name::= <span class="T6">--</span> | (WORD [ <span class="T6">:</span> Name ])</p>
<p class="Code indented"></p>
<p class="Code indented">Value::= Component</p>
<p class="Code indented">| SimpleValue <span class="T6">;</span>
</p>
<p class="Code last line">| <span class="T6">; </span><span class="T9">// instance of SFNull</span>
</p>
<p class="Text body">From this it is clear that the input to the parser is a collection of attributes, each named and having an optional value. If the value is not present, the value is defined to be an instance of the class <span class="code inline">SFNull</span> (note that the other way of defining a value of class <span class="code inline">SFNull</span> is to use the basic value <span class="code inline">NULL</span>). The reason for providing this feature is to enable the use of attributes where the presence of the attribute is what is important, not its value.</p>
<p class="Text body">The syntax for a name will be covered later, but for now it can be considered to be either a simple sequence of letters and digits, starting with a letter, or the double-hyphen &ldquo;<span class="code inline">--</span>&ldquo;). The double hyphen is for use at times when the attribute name is not important and so a new unique name is generated and used. This is particularly useful with the function syntax described in Section 4, and most specifically the nary operators.</p>
<p class="Text body">Include files are covered in more detail in section 2.3, but in general they consist of parseable SmartFrog text which are parsed as attribute lists and unpacked into place within the container attribute list.</p>
<p class="Text body">Values can be divided up into two main categories: nested attribute sets (components) and the rest (simple values) which include numbers, strings, vectors of these, and so on. In addition it is possible not to provide a value for the attribute, or more precisely to give a null value to it (an instance of the <span class="code inline">SFNull</span> class). This is captured by the third clause of the BNF for values above.</p>
<a name="N10238"></a><a name="Simple+Values"></a>
<h5>Simple Values</h5>
<p class="P96">Values are expressible in several syntactic forms. </p>
<p class="Code">SimpleValue::= Basic</p>
<p class="Code">| Reference</p>
<p class="Code">| Operator</p>
<p class="Code">| IfThenElse</p>
<p class="Code">
<span class="T6"></span><span class="T9">| Vector</span>
</p>
<p class="Heading 4">Basic Values</p>
<p class="Text body">The primary way is to provide a basic value, a literal syntactic form for the basic core values in the SmartFrog language. The syntax for the basic values is best given by example.</p>
<p class="Code indented">
<span class="T6">Integer:</span> 345</p>
<p class="Code indented">
<span class="T6">Long:</span> 65325L or 65325l</p>
<p class="Code indented">
<span class="T6">Float:</span> 34.76F or 34.76f or 34.76E-10F or 34.76e+10f or 34.76E10f</p>
<p class="Code indented">
<span class="T6">Double:</span> 1534.45 or 1534.45D or 1534.45d or 1534.45E10 or 1534.45E-10D</p>
<p class="Code indented">
<span class="T6">String:</span> "this is a string"</p>
<p class="Code indented">
<span class="T6">Multi-line String:</span> ## This is a string</p>
<p class="Code indented">Over many lines #</p>
<p class="Code indented">
<span class="T6">Boolean:</span> true</p>
<p class="Code indented">
<span class="T6">SFNull</span>: NULL // alternatively, leave the value empty</p>
<p class="Code last line">
<span class="T6">Byte Array</span>: #HEX#AB348eAb#</p>
<p class="Text body">Consequently, an example of a piece of SmartFrog text is as follows</p>
<p class="Code indented">portNum 4074;</p>
<p class="Code indented">hostname "ahost.smartfrog.org";</p>
<p class="Code last line">isHighPriority false</p>
<p class="Text body">defining three attributes with the appropriate values.</p>
<p class="Text body">In addition to these basic values, it is also possible to give vectors of basic values (as opposed to the more extensive vector syntax given below). These vectors are limited to containing basic values, and other vectors of basic values.</p>
<p class="Code indented">userList [| "fred", "harry" |];</p>
<p class="Code indented">empty [| |];</p>
<p class="Code last line">listOfLists [| [| 1,2,3 |], [| 4,5,6 |] |];</p>
<p class="Text body">The full syntax for the basic values is</p>
<p class="Code indented">Basic::= String</p>
<p class="Code indented">| Number</p>
<p class="Code indented">| Boolean</p>
<p class="Code indented">| <span class="T9">ByteArray</span>
</p>
<p class="Code indented">| <span class="T6">[|</span> [Basic (<span class="T6">,</span> Basic)*] <span class="T6">|]</span>
</p>
<p class="Code indented">| <span class="T6">NULL</span>
</p>
<p class="Code indented"></p>
<p class="Code indented">Number::= DOUBLE </p>
<p class="Code indented">| FLOAT</p>
<p class="Code indented">| INTEGER</p>
<p class="Code indented">| LONG</p>
<p class="Code indented"></p>
<p class="Code indented">String::= STRING // "....."</p>
<p class="Code indented">| MULTILINESTRING // ##....#</p>
<p class="Code indented"></p>
<p class="Code indented">Boolean::= <span class="T6">true</span> | <span class="T6">false</span>
</p>
<p class="P97"></p>
<p class="P97">
<span class="T9">ByteArray</span>::= #HEX#....#</p>
<p class="P97">| #DEC#....#</p>
<p class="P97">| #OCT#....#</p>
<p class="P97">| #BIN#....#</p>
<p class="Code last line">| <span class="T6">#B6</span><span class="T6">4#....#</span>
</p>
<p class="Text body">Note that byte arrays will be definable as hexadecimal (HEX), decimal (DEC), octal (OCT), binary (BIN) and base64 (B64), however only hexadecimal is currently implemented. Depending on the definitional form, the characters that may be used and the number that must be present are different. White space characters are ignored so that neat tabbed layouts may be used. They are treated in the syntax as single tokens. </p>
<p class="Heading 4">References</p>
<p class="Text body">The second form of simple value provided by the language is the reference. A reference is a link between the value of one attribute and that of another. This allows for the definition of data in one place and reused in many, easing maintenance issues for descriptions. References are dealt with in more detail in section 2.2.4, but as a first example the use of a name in the value position provides the link to the attribute of the same name. So for example:</p>
<p class="Code indented">x 42;</p>
<p class="Code last line">y x;</p>
<p class="Text body">defines y to be the same value as x, namely 42;</p>
<p class="Heading 4">Operators</p>
<p class="Text body">The remaining three forms of value definition are syntactic sugar for the use of functions. The semantics of functions are outlined in section 4 and described in detail in section . However, their syntax is </p>
<p class="Code indented">Operator::=</p>
<p class="Code indented">
<span class="T6">(</span>
</p>
<p class="Code indented">(UnaryOp SimpleValue ) </p>
<p class="Code indented">| (SimpleValue [ BinaryOp SimpleValue ])</p>
<p class="Code indented">| (SimpleValue [ (NaryOp SimpleValue)* ])</p>
<p class="Code indented">
<span class="T6">)</span>
</p>
<p class="Code indented"></p>
<p class="Code indented">UnaryOp::= <span class="T6">!</span>
</p>
<p class="Code indented"></p>
<p class="Code indented">BinaryOp::= <span class="T6">-</span> | <span class="T6">/</span> | <span class="T6">==</span> | <span class="T6">!=</span> | <span class="T6">&gt;=</span> | <span class="T6">&gt;</span> | <span class="T6">&lt;=</span> | <span class="T6">&lt;</span>
</p>
<p class="Code indented"></p>
<p class="Code last line">
<span class="T9">NaryOp::= </span><span class="T6">+</span><span class="T9"> | </span><span class="T6">*</span><span class="T9"> | </span><span class="T6">++</span><span class="T9"> | </span><span class="T6">&lt;&gt;</span><span class="T9"> | </span><span class="T6">&amp;&amp;</span><span class="T9"> | </span><span class="T6">||</span>
</p>
<p class="Text body">This states that the use of an operator is always defined within brackets (...) and that there are three types of operator: unary, binary and nary. Although with the nary operators, more than one instance of the operator symbol is present, it must always be the same operator; they cannot be mixed. However, other operators may be nested within another set of ( ). The following examples may help to make the syntax clear:</p>
<p class="Code indented">aTruthValue true;</p>
<p class="Code indented">anotherValue (! aTruthValue ) // the only unary operator: not</p>
<p class="Code indented">aNumber 45;</p>
<p class="Code indented">aMinus (100 &ndash; aNumber) // a binary operator</p>
<p class="Code last line">aSum (aNumber + aMinus + 100) // an nary operator</p>
<p class="Text body">These operators are all converted at time of parsing into the template representation of a function, and hence at no time willl operators appear in an description generated from the parsed form.</p>
<p class="Text body">Note that attribute names can contain rather a large number of special symbols, such as &ldquo;+&rdquo; and &ldquo;-&rdquo;. This means that there is a danger that an operator may lexically stick to a name if not separated from it by white space. As a consequence, it is good practise to always use white space around operator symbols.</p>
<p class="Heading 4">If-Then-Else</p>
<p class="Text body">Similarly to operators, if-then-else expressions are shorthand for the template form. This is described in detail in section . The syntax for this expression form is</p>
<p class="Code indented">IfThenElse::= <span class="T6">IF </span>SimpleValue </p>
<p class="Code indented">
<span class="T6">THEN</span> SimpleValue</p>
<p class="Code indented">
<span class="T6">ELSE</span> SimpleValue </p>
<p class="Code last line">
<span class="T6">FI</span>
</p>
<p class="Text body">The line breaks being, of course, optional. The &ldquo;if&rdquo; value is a boolean and depending on the result the expression takes the value of the &ldquo;then&rdquo; or &ldquo;else&rdquo; values. The <span class="code inline">FI</span> is merely a closing keyword. An example of its use is:-</p>
<p class="Code indented">val1 42;</p>
<p class="Code indented">val2 43;</p>
<p class="Code indented">diff IF (val1 &gt; val2) THEN (val1 &ndash; val2) ELSE (val2 &ndash; val1) FI;</p>
<p class="Heading 4">Vectors</p>
<p class="Text body">The final form of simple value is the vector. Vectors are lists of values and are constructed using the vector function described in section . However, to simplify its use, the following syntactic form has been provided.</p>
<p class="Code last line">Vector::= <span class="T6">[</span> [SimpleValue ( <span class="T6">,</span> SimpleValue) *] <span class="T6">]</span>
</p>
<p class="Text body">Thus a vector is a sequence of values separated by &ldquo;,&rdquo; and delimited by &ldquo;<span class="code inline">[ ]</span>&rdquo;. If no value is provided within the vector, an empty vector is returned. Vectors may be nested to produce vectors of vectors. Example uses of vectors are:</p>
<p class="Code indented">v1 [1,2,3];</p>
<p class="Code indented">v2 [9,8,7];</p>
<p class="Code last line">v3 [v1, v2]; // same as [[1,2,3],[9,8,7]]</p>
<p class="Text body">Note that there are two syntaxes for vectors &ndash; the one given here which provides the ability to embed references and which therefore requires a degree of processing (known as resolution). It is parsed into the use of the vector function rather than directly into a vector. The other form, using the &ldquo;[| |]&rdquo; delimiters, parses directly into a vector and hence may not have references within the definition. The reason for having simpler form in addition to the more general form is is that there are times when the fully processed (resolved) data structures need to be unparsed, and then re-parsed at some future time without further transformation. A example of this is during the signing of a description for security purposes.</p>
<p class="Heading 4">Values of Other Classes</p>
<p class="Text body">The set of values that can be described by the use of the language is limited to a few basic classes and collections of these. It would be useful to be able to include values from other classes in Java. These in principle can be generated in functions, or some user-defined phase, and added to the attribute sets. However, there are problems with this for SmartFrog, and in particular with some aspects of the security where descriptions transformed to core form need to be signed and this is restricted to the known classes.</p>
<p class="Text body">Consequently the conversion to the core form ensures that the values represented in the attribute sets, the component descriptions, are limited to these core classes. If other values need to be held within the tree, it is recommended that they are held in serialized form within a ByteArray value. This will need to be deserialized by the component at the time of deployment.</p>
<a name="N10407"></a><a name="Component+Descriptions"></a>
<h5>Component Descriptions</h5>
<p class="Text body">Attributes may have values that are collections of other attributes, known as component descriptions. They obtain their name from the fact that they may be interpreted by the framework as the description of a component, though they may equally be used to describe structured data.</p>
<p class="Text body">A component description consists of two parts, a reference to another component description to act as a source of attributes (the type), and a collection of attributes that are then added to, or override, the attributes of the referenced collection (the body). The syntax is:</p>
<p class="Code indented">Component::= <span class="T6">extends</span> [<span class="T6">LAZY] </span><span class="T9">Type Body</span>
</p>
<p class="Code indented"></p>
<p class="Code indented">Type::= [ <span class="T6">NULL</span> | BaseReference ]</p>
<p class="Code indented"></p>
<p class="Code indented">Body ::= (<span class="T6"> ;</span> | <span class="T6">{</span> AttributeList <span class="T6">} </span>)</p>
<p class="Text body"></p>
<p class="Text body">The <span class="code inline">LAZY</span> keyword may be largely ignored; it is merely a tag and only has a semantic effect during the deployment of a SmartFrog application. Extension of an existing <span class="code inline">LAZY</span> component description does not inherit the tag. </p>
<p class="Text body">Both the reference and the attribute list are effectively optional. If neither is present, the resultant attribute list is defined to be empty. The syntax is most easily explained through an example:</p>
<p class="Code indented">SFService extends { // an implicit extension of NULL</p>
<p class="Code indented">portNum 4047;</p>
<p class="Code indented">hostname "ahost.smartfrog.org";</p>
<p class="Code indented">administrators ["patrick"];</p>
<p class="Code indented">}</p>
<p class="Code indented"></p>
<p class="Code indented">UseableService extends SFService {</p>
<p class="Code indented">// an extension of the previous compnent</p>
<p class="Code indented">portNum 4048; // override the definition of portNum</p>
<p class="Code indented">users ["fred", "harry"]; // add a new attribute</p>
<p class="Code indented">}</p>
<p class="Text body">The text consists of two attributes, both of which have values that are collections of attributes. The second of these, <span class="T4">UseableService</span>, is defined as an extension of the first <span class="code inline">SFService</span>, with two attributes added to or overwriting those inherited. The text is semantically identical to the following:</p>
<p class="Code indented">SFService extends {</p>
<p class="Code indented">portNum 4047;</p>
<p class="Code indented">hostname "ahost.smartfrog.org";</p>
<p class="Code indented">administrators ["patrick"];</p>
<p class="Code indented">}</p>
<p class="Code indented"></p>
<p class="Code indented">UseableService extends {</p>
<p class="Code indented">portNum 4048;</p>
<p class="Code indented">hostname "ahost.smartfrog.org";</p>
<p class="Code indented">administrators ["patrick"];</p>
<p class="Code indented">users ["fred", "harry"];</p>
<p class="Code indented">}</p>
<p class="Text body">Note that the attributes in a component description are ordered and that when an attribute is overwritten it maintains its position, but when it is a new attribute it is added to the end. The process of expansion of the inheritance in this way is known as <span class="T2">Type Resolution</span> and is explained further below.</p>
<p class="Text body">Note also that the parsed stream is considered to be in an implicit, anonymous (i.e. not named in an outer component description), component description known as <span class="T2">ROOT</span>.</p>
<p class="Text body">The example is also shown in the diagram. It clearly shows that there are two kinds of relationship between component descriptions. One is the containment relationship, where a component description contains an attribute that is itself a component description. The second is the inheritance or extension relationship. This second class of relationship is one that can be transformed, by type resolution, to an equivalent one containing no extension (also indicated by the <span class="code inline">NULL</span> extension).</p>
<p class="Text body">Whilst the extension relationship is merely a convenient way of defining attributes, the containment hierarchy is a more fundamental construct. It should be noticed that that containment hierarchy effectively provides a naming scheme by which attributes may be referenced. In this it is similar to other such named hierarchies, such as directory hierarchies common in files systems.</p>
<a name="N104AF"></a><a name="Types+vs.+Prototypes"></a>
<h5>Types vs. Prototypes</h5>
<p class="Text body">SmartFrog does not define types for attributes and components. Rather it defines the notion of a prototype (c.f. the programming language Self). Each attribute whose value is a component description may be considered as a prototype for another: it may be taken and modified as appropriate to provide the value for the new attribute. The mechanism for this is the <span class="T2">extends</span> construct.</p>
<p class="Text body">Any attribute whose value is a component description may be, at a later juncture, selected and modified to provide a new component description to be bound to a name. This new attribute may be further modified by subsequent attributes. In this way, it is possible to provide partial definitions, with default values for attributes, to be completed or specialized when used. This provides a simple template mechanism for components.</p>
<p class="Text body">Consequently, there are no separate spaces of types and instances; every component is logically an instance, but may also be a prototype for another. However, it is clear that in providing descriptions, some components will be defined with the intention that they be used as prototypes for other components, whilst others will be defined without that expectation. Whilst this may appear strange in the first instance, it turns out to be one of the main strengths of the SmartFrog notation.</p>
<a name="N104C1"></a><a name="References"></a>
<h5>References</h5>
<p class="Text body">References may occur in three places in the syntax: as the name of an attribute &ndash; known as a placement, as a reference to the extended component (the prototype) of a component description, and as an attribute value referring to another attribute whose value is to be copied &ndash; known as a link.</p>
<p class="Text body">The primary purpose of a reference is to indicate a path through the containment hierarchy defined by the components. In this, it is similar to the notion of path common in file systems in operating systems such Linux. A path defines a traversal of the directory hierarchy, a structure similar to the component hierarchy.</p>
<p class="Text body">The syntax for references is as follows:</p>
<p class="Code indented">Reference::= [<span class="T6">LAZY</span>] BaseReference</p>
<p class="Code indented"></p>
<p class="Code indented">BaseReference::= ReferencePart ( <span class="T6">: </span>ReferencePart)*</p>
<p class="Code indented"></p>
<p class="Code indented">ReferencePart::= <span class="T6">ROOT</span>
</p>
<p class="Code indented">| <span class="T6">PARENT</span>
</p>
<p class="Code indented">| (<span class="T6">ATTRIB</span> WORD)</p>
<p class="Code indented">| (<span class="T6">HERE</span> WORD)</p>
<p class="Code indented">| <span class="T6">THIS</span>
</p>
<p class="Code indented">| WORD</p>
<p class="Code indented">| (<span class="T6">PROPERTY</span> WORD)</p>
<p class="Code indented">| (<span class="T6">IPROPERTY</span> WORD)</p>
<p class="Code indented">| (<span class="T6">HOST</span> (WORD | STRING))</p>
<p class="Code indented">| <span class="T6">PROCESS</span>
</p>
<p class="Text body"></p>
<p class="Text body">Thus, a reference is a colon-separated list of parts each of which indicates a step in the path through the containment tree. Examples of references are:</p>
<p class="Code indented">PARENT:PARENT:foo:bar</p>
<p class="Code indented">ATTRIB a:b</p>
<p class="Code indented">ROOT</p>
<p class="Code indented">x</p>
<p class="Code indented">HOST 15.144.56.65:foo:bar</p>
<p class="Code indented"></p>
<p class="Text body">Normally a reference indicates a path through the containment tree to an attribute whose value should be copied, or a component description in which an attribute should be placed. These references are &ldquo;resolved&rdquo; during the language processing to eliminate them and to carry out the appropriate copying or placement.</p>
<p class="Text body">However, occasionally the reference itself is the desired value, or the reference cannot be resolved during language processing as the data referenced is not available until a later stage. Under these circumstances, the keyword &ldquo;LAZY&rdquo; is prefixed to the reference to indicate that the reference resolution should be delayed.</p>
<p class="Text body">The general rule for the interpretation of a reference is that the reference is evaluated in a context (a component description somewhere in the description containment tree), and that each step moves the context to a possibly different component for the remainder of the reference to be evaluated. This is equivalent to path evaluation in a Linux file system, the path is evaluated in a current directory, and each part of the path moves the context to another directory.</p>
<p class="Text body">The semantics of each of the reference parts is as follows: starting at component in which the reference is defined&hellip;</p>
<ul>
<li>
<p class="P98">
<span class="T6">PARENT</span> - move context to the parent (container) component if it exists, fail otherwise (c.f. Linux &ldquo;..&rdquo;)</p>
</li>
<li>
<p class="P98">
<span class="T6">HERE</span> WORD - look for the attribute named &ldquo;word&rdquo; in the current context, fail otherwise</p>
</li>
<li>
<p class="P98">
<span class="T6">ATTRIB</span> WORD - look for the attribute named &ldquo;word&rdquo; in the current context or anywhere in the containment hierarchy (the closest is chosen), move to the context defined by this attribute, fail if no attribute is found in the containment hierarchy</p>
</li>
<li>
<p class="P98">
<span class="T6">ROOT</span> - switch context to the outer-most component (normally the implicit root component (c.f. Linux &ldquo;/ &ldquo;)</p>
</li>
<li>
<p class="P99">THIS<span class="T9"> &ndash; keep the context the same, don't switch (c.f. Linux &ldquo;.&rdquo;)</span>
</p>
</li>
<li>
<p class="P100">WORD &ndash; the interpretation of the WORD depends on the location. If it is the only part in the reference, or the first part, it is interpreted as <span class="code inline">ATTRIB</span>. If it is the second or later part of a reference it is interpreted as <span class="code inline">HERE</span>.</p>
</li>
</ul>
<p class="Text body">Some examples of references (in this case link references) are as follows:</p>
<p class="Text body">
<span class="T16"></span>The arrows in the left-hand text show the path followed as the references are resolved to obtain the referenced attribute values, noting that the resolution of <span class="T3">ref3</span> will follow the resolution of <span class="T3">ref2</span>. The contexts traversed as the resolutions progress are shown boxed and the right-hand text shows the result of resolving the three links.</p>
<p class="Text body">In addition to these four structural reference parts, there are four others that are not appropriate for all circumstances and are not related to the containment hierarchy. These are</p>
<ul>
<li>
<p class="P101">
<span class="T6">PROPERTY</span> WORD &ndash; return the value that is the Java system property named WORD. It may only occur at the end of a reference, and only in a link. Syntactically it may occur anywhere, however the remainder of the link is ignored. It is usually used in conjunction with <span class="code inline">LAZY</span>. Without <span class="code inline">LAZY</span>, the value of the property at the time of parsing will be used; with <span class="code inline">LAZY</span> the application run-time value of the property will be used when the link is resolved &ndash; see section 2. The property is always a string.</p>
</li>
<li>
<p class="P101">
<span class="T6">IPROPERTY</span> WORD &ndash; as for <span class="code inline">PROPERTY</span>, but the property is interpreted as indicating an integer which is parsed and returned as such.</p>
</li>
<li>
<p class="P101">
<span class="T6">HOST</span> (WORD | STRING) &ndash; switch to the context of the process compound on the host name WORD (or STRING &ndash; which must be used if supplying an IP address, but may also be used with a host name). This reference part is also used in conjunction with the <span class="code inline">LAZY</span> keyword and only in links. It is used to provide a naming service for applications within the SmartFrog system. Again, without <span class="code inline">LAZY</span> the parser will look-up the value in the remote process compound, with <span class="code inline">LAZY</span> this will be done at run-time when the link is resolved &ndash; see section 2.</p>
</li>
<li>
<p class="P101">
<span class="T6">PROCESS </span>&ndash; switch to the context of the process compound of the current process. This is also used in conjunction with the <span class="code inline">LAZY</span> keyword and only in links. It is used to provide a naming service for applications within the SmartFrog system. Again, without <span class="code inline">LAZY</span> the parser will look-up the value in the remote process compound, with <span class="code inline">LAZY</span> this will be done at run-time when the link is resolved &ndash; see section 2.</p>
</li>
</ul>
<p class="Text body">The above rules determine the general interpretation of references. However, each of the syntactic contexts has its own slight semantic variation; these variations appear in the detailed definition of the semantics for references. </p>
<p class="Heading 4">Reference Elimination &ndash; Resolution</p>
<p class="Text body">The key to the semantics of the SmartFrog notation is the process by which references are eliminated. This is necessary for each of the three syntactic locations where references may occur &ndash; prototype references, placement references and link references. The process by which references are eliminated is known as reference resolution. However, each type of reference has a different notion of resolution and so each has a specific resolution action &ndash; known respectively as type resolution, placement resolution and link resolution. This last name is historically also known as deployment resolution; this old name appears in parts of the API and is kept for backward compatibility. The resolution steps are described in more detail in the next few sub-sections, and then revisited as a whole to examine their interaction with each other.</p>
<p class="Heading 4">Prototype References</p>
<p class="Text body">References to prototypes, as defined in the following syntactic context,</p>
<p class="Code indented">Component ::= extends [<span class="T6">LAZY</span>] BaseComponent</p>
<p class="Code last line">BaseComponent ::= [Reference] (<span class="T6"> ;</span> | { AttributeList } )</p>
<p class="Text body">are resolved as described above except in one respect: if the reference to the prototype consists of a single <span class="T3">WORD</span> part, it is interpreted as <span class="T3">ATTRIB WORD</span><span class="T1"> in the usual way.</span>
</p>
<p class="Text body">Thus, the following are equivalent</p>
<p class="Code indented">Foo extends Bar { &hellip;}</p>
<p class="Code indented">Foo extends ATTRIB Bar {&hellip;}</p>
<p class="Text body">This is to provide a greater degree of convenience when referring to a prototype as these are most often defined in the outermost implicit root context, and frequently defined in an included file. Using this re-interpretation using <span class="code inline">ATTRIB</span>, rather than adding an implicit <span class="code inline">ROOT</span> reference part to the front, ensures that global definitions of prototypes at the top level may be locally overridden if required.</p>
<p class="Text body">The following example demonstrates most of the situations:</p>
<p class="Code indented">Foo extends { a 1; }</p>
<p class="Code indented"></p>
<p class="Code indented">Bar extends {</p>
<p class="Code indented">foo extends Foo;</p>
<p class="Code indented">}</p>
<p class="Code indented"></p>
<p class="Code indented">Baz extends {</p>
<p class="Code indented">foo extends {</p>
<p class="Code indented">b 2;</p>
<p class="Code indented">}</p>
<p class="Code indented"></p>
<p class="Code indented">foo1 extends Foo; // recall - this is equivalent to ATTRIB Foo</p>
<p class="Code indented">foo2 extends ROOT:Foo;</p>
<p class="Code indented">foo3 extends PARENT:Foo;</p>
<p class="Code indented">foo4 extends PARENT:PARENT:Foo;</p>
<p class="Code last line">}</p>
<p class="Text body">After type resolution, which includes the merging and overwrite of attributes as described in section 2.2.2, the example is equivalent to:</p>
<p class="Code indented">Foo extends { a 1; }</p>
<p class="Code indented"></p>
<p class="Code indented">Bar extends {</p>
<p class="Code indented">foo extends { a 1; } // ATTRIB Foo finds the outermost</p>
<p class="Code indented">}</p>
<p class="Code indented"></p>
<p class="Code indented">Baz extends {</p>
<p class="Code indented">foo extends { b 2; } </p>
<p class="Code indented">foo1 extends { b 2; } // ATTRIB Foo finds the closest enclosing</p>
<p class="Code indented">foo2 extends { a 1; } // ROOT:Foo finds the one in the root</p>
<p class="Code indented">foo3 extends { b 2; } // PARENT:Foo finds that in the parent</p>
<p class="Code indented">foo4 extends { a 1; } // PARENT:PARENT:Foo finds that in</p>
<p class="Code indented">// the root (in this case)</p>
<p class="Code indented">}</p>
<p class="Code indented"></p>
<p class="Heading 4">Placement References</p>
<p class="Text body">An attribute&rsquo;s name may be a reference, as described in the syntactic clauses</p>
<p class="Code indented">Attribute ::= Name Value</p>
<p class="Code last line">Name ::= BaseReference</p>
<p class="Text body">This is not completely accurate, as the syntax in fact limits references to being a reference containing <span class="code inline">WORD</span> values, the other reference parts are considered erroneous.</p>
<p class="Text body">The resolution of the reference is again largely as described above, with the following modification.</p>
<p class="Text body">The last reference part of the reference must be a WORD and is treated differently. This word part is not strictly part of the reference, but is used to identify the name of an attribute that is to be created (as opposed to referenced) in the context of the prefix part of the name reference. Thus in the attribute definition</p>
<p class="Code last line">foo:baz:bar 42;</p>
<p class="Text body">the <span class="code inline">foo:baz</span> is a reference to a location, <span class="code inline">bar</span> is the name of the attribute to be created in that context.</p>
<p class="Text body">In most cases, the name consists only of that final WORD leaving the prefix reference empty, indicating the current context. Thus, the attribute is defined in that current context. Where a non-empty reference prefixes the final word, the reference is used to determine the appropriate context and the attribute with the given name is placed into that context.</p>
<p class="Text body">Consider the example</p>
<p class="Code indented">Service extends {</p>
<p class="Code indented">portNum 4089;</p>
<p class="Code indented">}</p>
<p class="Code indented"></p>
<p class="Code indented">Service:portNum 4074;</p>
<p class="Code indented">Service:hostname "ahost.smartfrog.org";</p>
<p class="Text body"></p>
<p class="Text body">The prefix reference <span class="T3">Service</span><span class="T2">:</span> is de-referenced to indicate the Service attribute. The two prefixed attributes are therefore placed within that reference context, overriding or placed at the end of the context as appropriate. Thus, the example is roughly equivalent to the following (there are some differences in their behaviour as prototypes):</p>
<p class="Code indented">Service extends {</p>
<p class="Code indented">portNum 4074;</p>
<p class="Code indented">hostname "ahost.smartfrog.org";</p>
<p class="Code last line">}</p>
<p class="Text body">The act of placing the attributes into a location is known as placement resolution, and it occurs simultaneously with the removal of the reference-prefixed attribute from its defining context.</p>
<p class="Text body">Placement of attributes can lead to a great deal of confusion if not used properly. It reacts in interesting ways with type resolution; this interaction explained in the section on resolution.</p>
<p class="Heading 4">Link And LAZY Link References</p>
<p class="Text body">Frequently, attributes need to take on the same values as other attributes. This can be for many reasons:</p>
<ul>
<li>
<p class="P102">to avoid repetition of values at many points in a description making it easier to maintain that description</p>
</li>
<li>
<p class="P102">to hide the structure of the description to a program; explained further in section 2.</p>
</li>
<li>
<p class="P102">to provide a means of simple parameterization; explained further in the section .</p>
</li>
</ul>
<p class="Text body">This association between the value of one attribute and that of another is defined by providing a reference in the place of a value of the attribute. This reference is resolved relative to the context at the point of definition.</p>
<p class="Text body">Consider the following example, in which a server and a client both need to know the TCP/IP port on which the server will listen.</p>
<p class="Code indented">System extends {</p>
<p class="Code indented">server extends {</p>
<p class="Code indented">portNum 4089;</p>
<p class="Code indented">}</p>
<p class="Code indented">client extends {</p>
<p class="Code indented">portNum ATTRIB server:portNum;</p>
<p class="Code indented">}</p>
<p class="Code last line">}</p>
<p class="Text body">The system contains a server and a client. The server and client both have an attribute <span class="T3">portNum</span>, with that of the client being defined as a link to that of the server.</p>
<p class="Text body">There is a resolution step, known as link resolution (and occasionally deployment resolution), which replaces references by the values that they reference. During the resolution phase, chains of links are resolved appropriately.</p>
<p class="Text body">In the above example, the definition of <span class="T3">System</span> is equivalent to the following:</p>
<p class="Code indented">System extends {</p>
<p class="Code indented">server extends {</p>
<p class="Code indented">portNum 4089;</p>
<p class="Code indented">}</p>
<p class="Code indented">client extends {</p>
<p class="Code indented">portNum 4089;</p>
<p class="Code indented">}</p>
<p class="Code last line">}</p>
<p class="Text body">Consequently, both the server and client share the same value and maintenance is eased in that should the port number need be changed, this need happen in only one place in the description.</p>
<p class="Text body">It is frequently the case that the link itself is required as a value; i.e. the link should not be resolved to the value that it might refer to within the description. This reference may then be used within a SmartFrog application after deployment, for resolution at run-time rather than at the time of parsing the description. The primary use for this is described in section 2.</p>
<p class="Text body">In order to provide a reference value, rather than have it resolved to the value of another attribute during link resolution, the keyword <span class="code inline">LAZY</span> may be prefixed to the link to indicate that the link resolution should not resolve the link. An example of this is:</p>
<p class="Code indented">System extends {</p>
<p class="Code indented">server extends {</p>
<p class="Code indented">foo 42;</p>
<p class="Code indented">}</p>
<p class="Code indented">client extends {</p>
<p class="Code indented">myServer LAZY ATTRIB server;</p>
<p class="Code indented">}</p>
<p class="Code last line">}</p>
<p class="Text body">In this case, the client&rsquo;s attribute <span class="T3">myServer</span> is a reference to the server, not a copy of the server component. As is, resolution will have no effect, as the link will be left to be the attribute value. If the keyword <span class="code inline">LAZY</span> had <span class="T6">not</span> been present, the following would have been the result of resolution:</p>
<p class="Code indented">System extends {</p>
<p class="Code indented">server extends {</p>
<p class="Code indented">foo 42;</p>
<p class="Code indented">}</p>
<p class="Code indented">client extends {</p>
<p class="Code indented">myServer extends {</p>
<p class="Code indented">foo 42;</p>
<p class="Code indented">};</p>
<p class="Code indented">}</p>
<p class="Code last line">}</p>
<p class="Text body">The word <span class="code inline">LAZY</span> is an indication that it will be resolved at run-time &ndash; so far as the notation is concerned, this means that the link <span class="T17">is</span> the value.</p>
<a name="N10777"></a><a name="Comments"></a>
<h5>Comments</h5>
<p class="Text body">The SmartFrog notation follows most modern languages in providing both end-of-line comments and multi-line bounded comments. The syntax for these is identical to that of Java, namely</p>
<ul>
<li>
<p class="P3">
<span class="code inline">// this is a comment to the end of the line</span>
</p>
</li>
<li>
<p class="P3">
<span class="code inline">/* this is a comment which is terminated by */</span>
</p>
</li>
</ul>
<a name="N1078C"></a><a name="Include+Files"></a>
<h4>Include Files</h4>
<p class="Text body">A stream of text may reference include files at certain points in that text. Unlike a C include file, though, the include file is not merely textually embedded into the original stream. Rather the include file is itself parsed (and must be syntactically correct) as a stream in its own right. Every stream must parse as a collection of attribute definitions, and this is equally true of the include files.</p>
<p class="Text body">Include files may only be used within attribute lists (i.e. at the top level or within a component definition). The collection of attributes from the include file are simply added to the attribute list being parsed in the container stream.</p>
<p class="Text body">Consider the following example:</p>
<ul>
<li>
<p class="P32">file <span class="code inline">foo.sf</span> contains:</p>
</li>
</ul>
<p class="Code indented">foo extends {</p>
<p class="Code indented">a 42;</p>
<p class="Code indented">}</p>
<ul>
<li>
<p class="P32">the primary stream is:</p>
</li>
</ul>
<p class="Code indented">#include "foo.sf"</p>
<p class="Code indented">system extends {</p>
<p class="Code indented">myFoo extends foo;</p>
<p class="Code indented">#include "foo.sf"</p>
<p class="Code last line">}</p>
<p class="Text body">After the parsing is complete (but before type resolution), the following is obtained:</p>
<p class="Code indented">foo extends {</p>
<p class="Code indented">a 42;</p>
<p class="Code indented">}</p>
<p class="Code indented">system extends {</p>
<p class="Code indented">myFoo extends foo;</p>
<p class="Code indented">foo extends {</p>
<p class="Code indented">a 42;</p>
<p class="Code indented">}</p>
<p class="Code last line">}</p>
<p class="Text body">It should be noted that because includes may occur within other component descriptions, this may be used as a naming mechanism to prevent clashes of attribute name within multiple include files. Consider</p>
<ul>
<li>
<p class="P32">file <span class="code inline">foo1.sf </span>contains</p>
</li>
</ul>
<p class="Code last line">foo extends { a 42; }</p>
<ul>
<li>
<p class="P32">file <span class="code inline">foo2.sf</span> contains</p>
</li>
</ul>
<p class="Code last line">foo extends { b 42; }</p>
<ul>
<li>
<p class="P32">the primary stream contains</p>
</li>
</ul>
<p class="Code indented">foo1 extends { #include "foo1.sf" }</p>
<p class="Code indented">foo2 extends { #include "foo2.sf" }</p>
<p class="Code indented">sfConfig extends {</p>
<p class="Code indented">bar extends ATTRIB foo1:foo;</p>
<p class="Code indented">baz extends ATTRIB foo2:foo;</p>
<p class="Code last line">}</p>
<p class="Text body">If the includes had not been buried within separately named components, but both had been included into the top level, only the second of the two mentioned <span class="T3">foo</span> attributes would have been available for extension. The second would override the first.</p>
<a name="N10817"></a><a name="sfConfig"></a>
<h4>sfConfig</h4>
<p class="Text body">A stream contains a whole collection of attributes at the top level. Most are merely there to act as building blocks &ndash; prototypes for building others. Typically, there is only a single attribute that is the essence of the description &ndash; that which describes the desired configuration and is not merely a building block on the way. By convention in SmartFrog, the reserved attribute name <span class="T3">sfConfig</span> defines this special attribute and all the tools provided respect this convention.</p>
<p class="Text body">Thus, when a stream is parsed to an attribute set, the top-level attribute <span class="T3">sfConfig</span> defines the system; the rest are ignored, apart from providing definitions for extensions and other resolutions. This is equivalent to the Java language use of the &ldquo;special&rdquo; method <span class="T3">main(&hellip;)</span> to indicate the entry point to a program. The entry point to a configuration description is <span class="T3">sfConfig</span>.</p>
<p class="Text body">Thus in the following example, the attributes <span class="T3">def1</span>, <span class="T3">def2</span> and <span class="T3">def3</span> are only present for the purposes of defining <span class="T3">sfConfig</span>, and it is only this last attribute that represents the actual configuration description.</p>
<p class="Code indented">def1 extends Prim {&hellip;}</p>
<p class="Code indented">def2 extends Compound {</p>
<p class="Code indented">foo extends Prim {&hellip;}</p>
<p class="Code indented">bar extends Prim {&hellip;}</p>
<p class="Code indented">}</p>
<p class="Code indented">def3 extends Prim {&hellip;}</p>
<p class="Code indented"></p>
<p class="Code indented">sfConfig extends Compound {</p>
<p class="Code indented">d1 extends def1;</p>
<p class="Code indented">d2 extends def2;</p>
<p class="Code indented">d3 extends def3;</p>
<p class="Code last line">}</p>
<a name="N10868"></a><a name="Resolution+%E2%80%93+Semantics+For+The+SmartFrog+Notation"></a>
<h3 class="boxed">Resolution &ndash; Semantics For The SmartFrog Notation </h3>
<p class="Text body">Resolution is the process by which the raw SmartFrog definitions, with their extensions, placements and links, are turned into the set of attributes that they semantically represent. </p>
<p class="Text body">In addition to these three steps, there are other steps (phases) in the complete semantic manipulation of the SmartFrog notation, such as function resolution, predicate checking and any user-defined phases. These are described in separate sections as they are somehow less core to understanding the language.</p>
<p class="Text body">There are two ways of representing the semantics, both roughly equivalent. </p>
<ol>
<li>
<p class="P103">By defining how the value of an attribute identified by a reference is obtained from a description; defining the semantics by providing a function from reference to value for all possible references.</p>
</li>
</ol>
<ol>
<li>
<ol>
<li>
<ol>
<li>
<ol>
<li>
<ol>
<li>
<ol>
<li>
<ol>
<li>
<ol></ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<ol>
<li>
<p class="P103">By defining a set of transformation rules that eliminate the complexity of the typing (by expansion), placement (by relocation) and linking (by value copy), resulting in a normalized form of a description containing merely a hierarchical set of attribute lists.</p>
</li>
</ol>
<p class="Text body">Either of these two forms of semantic definition would do, however the definition of the semantics through transformation has a distinct advantage: these transformations are required in practice and hence are implemented within the SmartFrog system. Thus, an understanding of these transformations is essential to the use of SmartFrog.</p>
<p class="Text body">The three transformation steps are known in SmartFrog as resolution steps. These are respectively type resolution, placement resolution and link resolution. They are carried out in that order: first the types are expanded, then attributes placed into the correct context from the context in which they were defined, and finally links are resolved. </p>
<p class="Text body">It should be noted that the entire description is type and place resolved, but only the top-level <span class="T3">sfConfig</span> attribute is normally link resolved. In general if the other top-level attributes are link resolved, errors will occur; they are only present to be available as prototypes. Further, unnecessary work will have been done.</p>
<p class="Text body">The algorithms defined here for the transformations are the result of much empirical experimentation &ndash; other transformation algorithms produce more regular semantics, others are more efficient. However, those presented here are a balance between performance and semantic simplicity. They provide a great deal of control over the semantics of the resolution process.</p>
<a name="N1089F"></a><a name="Type+Resolution"></a>
<h4>Type Resolution</h4>
<p class="Text body">Type resolution is the expansion of the prototype reference optionally provided in the <span class="T3">extends</span> part of a component description. The syntactic form for a component description is roughly</p>
<p class="Code indented">name extends Reference { AttributeList } </p>
<p class="Text body"></p>
<p class="Text body">The reference refers to a prototype that is to be extended by the attributes in the provided attribute list. This process of type resolution is a depth-first pass over the root component description, in the order of definition of the attributes.</p>
<ul>
<li>
<p class="P32">Copying the prototype indicated by the reference, creating a new component description</p>
</li>
<li>
<p class="P32">Replacing the attribute values of the new component description also mentioned in the attribute list (i.e. the value, but not the order, changes)</p>
</li>
<li>
<p class="P32">Adding the remaining attributes at the end of the new prototype.</p>
</li>
<li>
<p class="P32">Type-resolving each of the component description&rsquo;s attributes if they are component descriptions.</p>
</li>
</ul>
<p class="Text body">If the prototype reference indicates a component description that is not yet resolved, it resolves it first before copying: i.e. each type resolution is carried out with respect to the location where the prototype is defined. The other point to note is that if the reference is only a <span class="T2">word,</span> it is interpreted as <span class="T3">ATTRIB word</span> for the purposes of locating the prototype for the component description.</p>
<p class="Text body">If, at the end of the process, one or more component descriptions have failed to resolve, in that their prototypes cannot be found, the whole resolution process ceases and an exception is thrown indicating the missing prototypes and the locations at which they are referenced.</p>
<p class="Text body">Note that any references that may be copied as part of the extension process are not modified. Hence, copied placements are now relative to the new location and copied links similarly. Prototype references are never copied since a prototype is always resolved before copy.</p>
<a name="N108D5"></a><a name="Placement+Resolution"></a>
<h4>Placement Resolution</h4>
<p class="Text body">Placement resolution is the process by which the attributes are placed into the correct location. Attributes are named, and this name may contain a reference to a component description as well as the name by which it is to be known in that component description. If the reference is not present, the attribute is assumed to be in the correct component description as defined.</p>
<p class="Text body">Thus in the example attribute declaration:</p>
<p class="Code last line">foo:bar:baz 42;</p>
<p class="Text body">The <span class="T3">foo:bar:</span> defines the target component description, and <span class="T3">baz</span> defines the name for the attribute in that component description.</p>
<p class="Text body">Placement resolution is the transformation process that results in the attribute definitions being removed from their point of definition and placed in the target component descriptions. The process is a multi-pass process, for each pass:</p>
<ul>
<li>
<p class="P105">traverse the component description hierarchy</p>
<ul>
<li>
<p class="P106">depth first</p>
</li>
<li>
<p class="P106">visiting the attributes in the order of definition (as determined by type resolution)</p>
</li>
</ul>
</li>
<li>
<p class="P106">each attribute visited is examined, if it should be placed elsewhere &ndash; try to do so, if it fails &ndash; leave as is.</p>
</li>
</ul>
<p class="Text body">The pass is repeated until one of the following occurs:</p>
<ul>
<li>
<p class="P106">there are no placements left to transform</p>
</li>
<li>
<p class="P106">no placements have been successfully carried out, and at least one placement has failed</p>
</li>
</ul>
<p class="Text body">In the first instance, the placement resolution has successfully completed, the second it has not and an error is generated.</p>
<p class="Text body">To see why multiple passes are necessary, consider the following:</p>
<p class="Code indented">foo extends {</p>
<p class="Code indented">a 21;</p>
<p class="Code indented">}</p>
<p class="Code indented">foo:bar:a 42;</p>
<p class="Code last line">foo:bar extends { b 34; }</p>
<p class="Text body">In the first pass, the attribute <span class="T3">foo:bar:a</span> is first to be placed, but it fails since <span class="code inline">foo</span> does not yet contain <span class="T3">foo:ba</span><span class="T2">r</span> as a component description. Also in the first pass, but later since it is defined later, <span class="T3">foo:bar</span> is placed, giving </p>
<p class="Code indented">foo extends {</p>
<p class="Code indented">a 21; </p>
<p class="Code indented">bar extends { b 34; }</p>
<p class="Code indented">}</p>
<p class="Code last line">foo:bar:a 42;</p>
<p class="Text body">This leaves a placement incomplete so a second pass is required. This time it succeeds, resulting in </p>
<p class="Code indented">foo extends {</p>
<p class="Code indented">a 21; </p>
<p class="Code indented">bar extends { </p>
<p class="Code indented">b 34;</p>
<p class="Code indented">a 42;</p>
<p class="Code indented">}</p>
<p class="Code last line">}</p>
<p class="Text body">This order dependency does not have much of an effect, except for when two identically named attributes are placed into the same component description. At this point understanding the order of resolution becomes important.</p>
<p class="Text body">Since placement resolution is carried out after type resolution, the following consequences should be noted:</p>
<ul>
<li>
<p class="P32">As type resolution is carried out before placement, attributes placed into a prototype will not be inherited by those extending the prototype.</p>
</li>
<li>
<p class="P32">Again, as type resolution is carried out before placement, do not place an attribute that is to be used as a super-type; it will not be found.</p>
</li>
<li>
<p class="P32">Wherever possible, placement should be restricted to referencing downwards into a structure from the point of attribute definition. Descriptions can be very hard to understand if <span class="code inline">PARENT</span>, <span class="code inline">ROOT</span> or <span class="code inline">ATTRIB</span> are used in a placement reference; this particularly so within a component description to be used as a type. As a consequence, this release of SmartFrog does not permit these reference parts to be used in a placement.</p>
</li>
</ul>
<p class="Text body">The reason why type resolution is done before placement resolution is that the normal use for placement is to &ldquo;fill-in&rdquo; empty &ldquo;attribute slots&rdquo; in a prototype. As each instance of the prototype will in general need differently filled slots, placement must be done after the type has been resolved for each instance.</p>
<p class="Text body">Note that placement of attributes whose values are links do not modify the links to correct for the new location. Thus, links are resolved with respect to where they are placed, not where they are defined.</p>
<a name="N10986"></a><a name="Link+Resolution"></a>
<h4>Link Resolution</h4>
<p class="Text body">Link resolution is the most straightforward of the three forms of resolution; all links are resolved in their location after type and place resolution, and the referenced value replaces the link as the value of the attribute. There are a number of points to note:</p>
<ul>
<li>
<p class="P6">Only links that are <span class="T6">not</span> <span class="code inline">LAZY</span> are resolved; those that are <span class="code inline">LAZY</span> are left unresolved with the link itself being the value.</p>
</li>
<li>
<p class="P6">If the value of the attribute is a link, this is first resolved and the result of that resolution is used.</p>
</li>
<li>
<p class="P6">Links are always resolved in the contexts in which they are located after the type and placement resolution phases are over, not necessarily those in which they were defined.</p>
</li>
<li>
<p class="P6">Links referring to an attribute whose value is a <span class="code inline">LAZY</span> link will leave the <span class="code inline">LAZY</span> link unchanged, this being the attribute&rsquo;s value.</p>
</li>
<li>
<p class="P6">In resolving a link, the value of the attribute referenced is not copied, but shared, at the original point of definition if this is relevant (e.g. For component descriptions and their parent). Thus any operation that affects the value of this data has an impact on all parts of the tree that share this data. The only operations that affect attribute values in this way are functions (or possibly a user phase). </p>
<p class="P6">Sharing has almost no effect on the language semantics unless the data shared is a component description. In this case the parent of the data remains that of the location of definition. This has an impact on how links within that component description are resolved, using the original parent, and not relative to the context in which the link was defined. </p>
<p class="P6">An explanation of the consequences of sharing is given in section REF.</p>
</li>
</ul>
<a name="N109BD"></a><a name="The+Difference+Between+Types+and+Links"></a>
<h4>The Difference Between Types and Links</h4>
<p class="Text body">On the surface, there are many similarities between the definitions of <span class="T2">x</span> and <span class="T2">y</span> in:</p>
<p class="Code">Foo extends {</p>
<p class="Code">a 10;</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">x extends Foo;</p>
<p class="Code last line">y Foo;</p>
<p class="Text body">They both appear to end up by having the definition of a component description containing <span class="T3">a</span><span class="code inline">.</span> 
</p>
<p class="Text body">One obvious difference is that since they occur each side of place resolution, a placement into <span class="code inline">Foo</span> will affect <span class="T3">y</span> but not <span class="T3">x</span>. However there are more subtle differences to do with the sharing of data with links, rather than the copying of data with extends. Consider the following example:</p>
<p class="Code">data 1;</p>
<p class="Code"></p>
<p class="Code">Foo extends {</p>
<p class="Code">a data;</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">example extends {</p>
<p class="Code">data 100;</p>
<p class="Code">x extends Foo;</p>
<p class="Code">y Foo;</p>
<p class="Code last line">}</p>
<p class="Text body">In this definition, example<span class="T2">:x:a</span> has the value 100, whereas example<span class="T2">:y:a</span> has the value 1. The reason for this discrepancy is that the extends copies the definition of <span class="code inline">Foo</span> and the following link resolution for data is done relative to the copy's location. The link, on the other hand, simply links to the definition of <span class="code inline">Foo</span> in its existing position, and there the value of data on resolution is 1.</p>
<p class="Text body">The difference can also be highlighted using one of the functions, such as <span class="T2">next</span> that return a different value at each use. Consider the following description:</p>
<p class="Code">#include "org/smartfrog/functions.sf"</p>
<p class="Code">example extends {</p>
<p class="Code">x extends next;</p>
<p class="Code">y extends x;</p>
<p class="Code">z x;</p>
<p class="Code last line">}</p>
<p class="Text body">Assuming that this is the first use of <span class="T2">next</span>, <span class="T2">example:</span><span class="T2">x</span> will have the value 1, <span class="T2">example:y</span> will have the value 2, but <span class="T2">example:z</span> will have the value 1. This is because it shares the result of the function bound to <span class="T2">example:x</span>.</p>
<p class="Text body">Note that at the very end of the language processing as part of the conversion to the core data model, the sharing is eliminated and each attribute will have its own copy of the value. This is explained in detail in section REF.</p>
<a name="N10A5F"></a><a name="Template+Parameterization+Pattern"></a>
<h3 class="boxed">Template Parameterization Pattern</h3>
<p class="Text body">When extending a prototype, it is normal to override the values of certain attributes to customize the prototype to its actual use. The simplest way is to extend with the replacement attribute &ndash; however this only works for a top-level attribute. Modification of attributes deep in the structure requires the placement of the overriding attribute into the correct context, as in the example:</p>
<p class="Code indented">Service extends {</p>
<p class="Code indented">hostname "localhost";</p>
<p class="Code indented">portNum 4567;</p>
<p class="Code indented">}</p>
<p class="Code indented">ServicePair extends {</p>
<p class="Code indented">service1 extends Service ;</p>
<p class="Code indented">service2 extends Service ;</p>
<p class="Code indented">} </p>
<p class="Code indented">sfConfig extends ServicePair { </p>
<p class="Code indented">// user needs to know structure of ServicePair</p>
<p class="Code indented">service1:hostname "riker.smartfrog.org";</p>
<p class="Code indented">service2:hostname "ackbar.smartfrog.org";</p>
<p class="Code last line">}</p>
<p class="Text body">This works adequately, but it has the disadvantage that the use of the <span class="T2">ServicePair</span> prototype requires knowledge of its structure, though it does have the advantage that any attribute in the structure may be changed if necessary. However, under normal circumstances, there are attributes whose values are expected to change, and others that are not. Under these circumstances, it would be good if the description could be parameterized on these attributes. However, the normal form of parameterization as provided in programming language functions is not a good fit to the SmartFrog notation semantics &ndash; so the language provides a way of finding a way of hiding the structure of a description and making it easier to override &ldquo;deep&rdquo; attributes.</p>
<p class="P5">This technique, more of a pattern for the use of links, is shown in the following example: </p>
<p class="Code indented">Service extends {</p>
<p class="Code indented">hostname "localhost"; // default value</p>
<p class="Code indented">portNum 4567;</p>
<p class="Code indented">}</p>
<p class="Code indented">ServicePair extends {</p>
<p class="Code indented">s1Host "localhost"; // provide default value</p>
<p class="Code indented">s2Host "localhost";</p>
<p class="Code indented">service1 extends Service { hostname s1host; } // lift attribute</p>
<p class="Code indented">service2 extends Service { hostname s2host; } // ditto</p>
<p class="Code indented">}</p>
<p class="Code indented">sfConfig extends ServicePair { </p>
<p class="Code indented">// user needn&rsquo;t know structure of ServicePair</p>
<p class="Code indented">s1host "riker.smartfrog.org";</p>
<p class="Code indented">s2host "ackbar.smartfrog.org";</p>
<p class="Code last line">}</p>
<p class="Text body">It is clear that the use of <span class="T3">ServicePair</span> requires only the extension with top-level attributes to set the attributes deeply defined in the <span class="T3">Service</span> prototype. This pattern, of the use of links lifting an attribute value to one provided in the outermost context, is called the parameterization pattern and is very frequently used.</p>
<p class="Text body">Note that if a default value for a lifted attribute is not given within the description (in this case <span class="T3">ServicePair</span> provides defaults for both the lifted attributes <span class="T3">s1Host</span> and <span class="T3">s2Host</span>), a deploy resolution error will occur if the parameter is not provided at time of use, since the value to resolve the link will not be found.</p>
<a name="N10ADF"></a><a name="Functions+and+operators"></a>
<h3 class="boxed">Functions and operators</h3>
<p class="Text body">SmartFrog provides users with a small number of predefined functions to improve the expressiveness of the descriptions. In addition, it provides mechanisms by which users may add their own functions, effectively providing an escape mechanism into Java. These functions, whilst not part of the SmartFrog language, are provided for convenience. The mechanism, a special case of a more general phase mechanism, is described in detail in section . </p>
<p class="Text body">Functions appear, to the language, as predefined component descriptions that may be extended; the parameters are given as named attributes within the body of that description. For example, a use of the string concatenate function is </p>
<p class="Code indented">#include "/org/smartfrog/functions.sf" // the standard functions</p>
<p class="Code indented"></p>
<p class="Code indented">val 42;</p>
<p class="Code indented">myString extends concat {</p>
<p class="Code indented">-- "the meaning of life is ";</p>
<p class="Code indented">-- val</p>
<p class="Code indented">}</p>
<p class="Text body"></p>
<p class="Text body">that results in the value of the <span class="T3">myString</span> attribute being <span class="T4">"the meaning of life is 42"</span>. The names of the attributes have no effect in this case, the strings being concatenated in the order of definition, but may be important for some other functions. </p>
<p class="Text body">Functions are evaluated inner-first, providing for the nesting of function application, and are evaluated after all the other resolutions steps have be completed. The definitions are themselves affected by these resolutions. Thus a function may be extended with the resultant extension also be a function. The current set of predefined functions is given in section 13. </p>
<p class="Text body">In order to make the use of functions more natural, some syntactic forms are provided that appear to be infix or prefix operators. However, these are simply translated into the relevant template form during parsing. A more compete description of this process is given in section 13. </p>
<a name="N10B11"></a><a name="Predicates%2C+Assertions+and+Schemas"></a>
<h3 class="boxed">Predicates, Assertions and Schemas</h3>
<p class="Text body">It is frequently useful to be able to define a set of well-formedness conditions on the use of a template in order to guarantee that its use is correct. However, this should be done in a way in which all the benefits of template extension are not lost. To this end, an additional phase, similar to that defined for functions, is included which will check predicates defined and attached to a template.</p>
<p class="Text body">There are three predicate types provided as part of the SmartFrog framework. These are the assertion predicates, schema predicates and the TBD (to be defined) predicates.</p>
<p class="Text body">The most flexible predefined predicate supplied by the SmartFrog framework is the schema, a description that describes the set of attributes a template should contain. Users may add their own predicate types through a similar escape mechanism to Java provided for functions. Schemas are described in detail in section 14.</p>
<p class="Text body">Schemas are best described through the use of an example, in this case of a template for a web server component. The example defines a schema for a web server template, and defines the template linked to the schema.</p>
<p class="Code indented">// the definition of schemas</p>
<p class="Code indented">#include "/org/smartfrog/predicates.sf"</p>
<p class="Code indented"></p>
<p class="Code indented">WebServerSchema extends Schema {</p>
<p class="Code indented">port extends Integer;</p>
<p class="Code indented">directory extends OptionalString;</p>
<p class="Code indented">}</p>
<p class="Code indented"></p>
<p class="Code indented">WebServerTemplate extends Prim {</p>
<p class="Code indented">schema extends WebServerSchema;</p>
<p class="Code indented">port 80; // default value</p>
<p class="Code indented">}</p>
<p class="Text body"></p>
<p class="Text body">Note that the name for the attribute linking the template to its schema need not be, as in this case, <span class="T4">schema</span>. Indeed, a template may have more than one schema attached as attributes, in which case the uses of the templates are checked against all schemas attached. Schemas must extend the base schema template <span class="T4">Schema</span>.</p>
<p class="Text body">Schemas may be extended in the same way as other templates, and their uses may easily be extended through placement as illustrated in the following examples.</p>
<p class="Code indented">// the definition of schemas</p>
<p class="Code indented">#include "/org/smartfrog/predicates.sf" </p>
<p class="Code indented"></p>
<p class="Code indented">ThreadedWebServerSchema extends WebServerSchema {</p>
<p class="Code indented">minimumThreads extends Integer;</p>
<p class="Code indented">}</p>
<p class="Code indented"></p>
<p class="Code indented">ThreadedWebServerTemplate extends WebServerTemplate { </p>
<p class="Code indented">// overwrite existing schema with extended schema</p>
<p class="Code indented">Schema extends ThreadedWebServerSchema;</p>
<p class="Code indented"></p>
<p class="Code indented">minimumThreads 7;</p>
<p class="Code indented">}</p>
<p class="Code indented"></p>
<p class="Code indented">AlternativeThreadedWebServerTemplate extends WebServerTemplate {</p>
<p class="Code indented">// add to existing schema</p>
<p class="Code indented">schema:minimumThreads extends Integer; </p>
<p class="Code indented"></p>
<p class="Code indented">minimumThreads 7;</p>
<p class="Code indented">}</p>
<p class="Text body"></p>
<p class="Text body">Note that schemas are entirely optional and need be used only if desired. The value of a schema is that it provides a strict definition and the potentially type of the attributes, both required and optional, of a component. This should make it easier to work with, and so benefit users of the component.</p>
<p class="Text body">Similarly to schemas, assertions are descriptions that are interpreted as a predicate. An assertion consists of a description that contains attributes that should all evaluate to <span class="code inline">true</span> - any attribute that evaluates to <span class="code inline">false</span>, or indeed any other value, is considered to be an assertion failure. The names of these boolean attributes are not significant other than as documentation. There is an implicit conjunction (and) between the various assertion attributes given.</p>
<p class="Text body">An assertion description must extend <span class="code inline">Assertion</span>, and must be included in the description to which it applies in the same way as a schema must.</p>
<p class="Text body">An example of an assertion is</p>
<p class="Code indented">// the definition of assertion</p>
<p class="Code indented">#include "/org/smartfrog/predicates.sf"</p>
<p class="Code indented"></p>
<p class="Code indented">WebServerAssertion extends Assertions {</p>
<p class="Code indented">portValid ((port == 80) || (port == 8080) || (port == 8088));</p>
<p class="Code indented">}</p>
<p class="Code indented"></p>
<p class="Code indented">WebServerTemplate extends Prim {</p>
<p class="Code indented">schema extends WebServerSchema;</p>
<p class="Code indented">assert extends WebServerAssertion;</p>
<p class="Code indented">port 80; // default value</p>
<p class="Code indented">}</p>
<p class="Text body"></p>
<p class="Text body">In the same way that attributes may be added to an existing schema, attributes may also be placed into an &ldquo;Assertions&rdquo; description, or more than one &ldquo;Assertions&rdquo; may be provided.</p>
<p class="Text body">The <span class="code inline">TBD</span> predicate is used to indicate that a specific attribute still requires to be assigned a value. If it has not been assigned, and an attempt is made to use it, an appropriate error message is given.</p>
<p class="Text body">An example of the predicate is as follows:</p>
<p class="Code indented">#include "/org/smartfrog/predicates.sf"</p>
<p class="Code indented"></p>
<p class="Code indented">aTemplate extends Prim {</p>
<p class="Code indented">sfClass &ldquo;org.smartfrog....&rdquo;;</p>
<p class="P97">anAttribute TBD;</p>
<p class="Code indented">}</p>
<p class="Code indented"></p>
<p class="Code indented">sfConfig extends Compound {</p>
<p class="Code indented">anInstance extends aTemplate;</p>
<p class="Code indented">anotherInstance extends aTemplate {</p>
<p class="Code indented">anAttribute 45;</p>
<p class="Code indented">}</p>
<p class="Code last line">}</p>
<p class="Text body">Here, the attribute <span class="T3">anAttribute</span> of <span class="T3">aTemplate</span> is defined as <span class="T3">TBD</span>, so any use of the template that does not set this value will generate an error. In the definition of <span class="T3">sfConfig</span>, the first use, to define <span class="T3">anInstance</span>, is erroneous whereas the second to define <span class="T3">anotherInstance</span> is valid.</p>
<p class="Text body">The <span class="code inline">TBD</span> attribute ("To be determined") is a simple substitute for the more rigorous schema declaration. Note that the type of the attribute is not defined, which can be a useful feature.</p>
<a name="N10C1D"></a><a name="Mapping+to+the+Core+Data+Model"></a>
<h3 class="boxed">Mapping to the Core Data Model</h3>
<p class="Text body">The attribute sets produced by the above phases are now simple enough to be mapped into the core data structures supported by the SmartFrog runtime. These data structures do not support extension, placements, functions or predicates &ndash; so all these have to be resolved away. Links are supported, but they are considered as values and have no further special meaning &ndash; they are all assumed to be LAZY links.</p>
<p class="Text body">The translation into these core data structures is therefore straight-forward apart from one additional point: the structures produced by the phases can share data, but this is eliminated by copying. If this copying involves Component Descriptions, these are also parented into the part of the tree into which they are being copied. </p>
<p class="Text body">The reason for this sharing elimination is to do with the semantics of the distributed system. Whilst all the data is local it could make sense to share data as it is more efficient, although care has to be taken when data is changed behind the scenes with side-effects on other parts of the tree. However, when parts of the tree get mapped to different processes during deployment, the data has to be copied and the sharing broken in any case. To ensure a common semantics between local and remote deployments, separate copies are taken at all times.</p>
<p class="Text body">This sharing elimination is illustrated by the following diagram. Note that the parent link from back from the <span class="code inline">foo</span> attribute's data only exists if the attribute is itself an attribute set (a component description).</p>
<p class="Text body">
<span class="T18"></span>
</p>
<a name="N10C36"></a><a name="Primary+Language+Processing"></a>
<h3 class="boxed">Primary Language Processing</h3>
<p class="Text body">Phases are a way transforming the SmartFrog parse tree into the final form ready for deployment (or other purpose). Each phase is a pass over the component description hierarchy carrying out an action controlled, in the case of user-defined phases, by attributes defined within the descriptions.</p>
<p class="Text body">Under normal circumstances users will not need to know about phases or how to modify on adapt them, the default collection of phases is already correct for most purposes.</p>
<p class="Text body">The predefined phases for the default language are as follows:</p>
<ul>
<li>
<p class="WW-List Bullet 2">
<span class="code inline">type</span> &ndash; carry out type resolution on the component description hierarchy; this is predefined and does not rely on attributes in the tree to trigger it.</p>
</li>
<li>
<p class="WW-List Bullet 2">
<span class="code inline">place</span> &ndash; carry out place resolution on the component description hierarchy; this is predefined and does not rely on attributes in the tree to trigger it.</p>
</li>
<li>
<p class="WW-List Bullet 2">
<span class="code inline">link</span> &ndash; carry out link resolution on the component description hierarchy; this is predefined and does not rely on attributes in the tree to trigger it.</p>
</li>
<li>
<p class="WW-List Bullet 2">
<span class="code inline">sfConfig</span> &ndash; not really a phase, rather it controls where the phases are applied. Its effect is that for the remaining phases in the current phase list, they are only applied to the <span class="code inline">sfConfig</span> attribute.</p>
</li>
<li>
<p class="WW-List Bullet 2">
<span class="code inline">print</span> &ndash; again, not really a phase, but it triggers the printing of the tree to the standard output. This provides a debugging mechanism as it can be placed between any other phases to view the intermediate state of the tree.</p>
</li>
<li>
<p class="WW-List Bullet 2">
<span class="code inline">function</span> &ndash; in reality a user-defined phase, but one which is provided by default. It causes all the functions to be evaluated. It is triggered in the same way as the other user-defined phases, by the occurrence of attributes with the name <span class="T3">phase.function</span>.</p>
</li>
<li>
<p class="WW-List Bullet 2">
<span class="code inline">predicate</span> &ndash; also a user-defined phase which is provided by default. It causes all predicates to be checked and errors reported. The schema mechanism is an instance of the use of the predicate phase, though others may be added by users. The phase is triggered in the same way as other user-defined phases, by the occurrence of the attributes with the name <span class="T4">phase.predicate</span>.</p>
</li>
</ul>
<p class="Text body">Phases are triggered in a specific order, as determined by the top-level attribute <span class="T3">phaseList</span>. If the attribute is not present, it is as though the attribute were defined as follows:</p>
<p class="Code last line">phaseList [&ldquo;type&rdquo;, &ldquo;place&rdquo;, &ldquo;sfConfig&rdquo;, &ldquo;link&rdquo;, &ldquo;function&rdquo;, &ldquo;predicate&rdquo;];</p>
<p class="Text body">This default definition provides the semantics described in the section 1.</p>
<p class="Text body">In addition to the pre-defined phases, a user may introduce their own. User phases are defined as follows:</p>
<ul>
<li>
<p class="WW-List Bullet 2">A class must be created which implements the interface <span class="T3">PhaseAction</span> in package <span class="T3">org.smartfrog.sfcore.parser</span>. The interface is fully defined in the Javadoc, but in summary, it provides two methods:</p>
</li>
</ul>
<ul>
<li>
<p class="P20">
<span class="code inline">forComponent</span> &ndash; which initializes the instance of the action with the component description on which it is to operate</p>
</li>
<li>
<p class="P20">
<span class="code inline">doit</span> &ndash; which triggers the action of the phase, </p>
</li>
</ul>
<ul>
<li>
<p class="WW-List Bullet 2">In whichever component description the action must take place, an attribute whose name starts with the string <span class="T3">phase.nnn</span> must be provided, set to the string containing the class name, where <span class="T3">nnn</span> is the desired name of the phase.</p>
</li>
<li>
<p class="WW-List Bullet 2">The <span class="T3">phaseList</span> attribute must be set at the top level of the description, containing the phase name <span class="T3">nnn</span> at the appropriate point relative to the other phases. It is recommended that this is placed after all the standard resolution phases, though occasionally it may be necessary to place the phase earlier.</p>
</li>
</ul>
<p class="Text body">There are a few points to notice. Firstly, the descriptions are traversed depth-first so the inner descriptions are visited before the outer. This makes sense for functions, for example, that are evaluated from the inside. The second point is that the action is independent of the phase, in that the attribute name determines the phase; the action is determined by the attribute value. Thus, it is possible for the same action to be used in two different phases, and for different actions to be invoked in the same phase &ndash; as is the case with all functions. It is also possible to have more than one action for each phase in a component description since the attribute name merely needs to start with the <span class="T3">phase.nnn</span> string so several may be provided.</p>
<p class="Text body">Note that both the <span class="code inline">phaseList</span> attribute and the <span class="code inline">phase.nnn</span> attributes are removed from the description after the action is invoked.</p>
<p class="Text body">Consider the following example. A class is provided that adds the <span class="T3">sfProcessHost</span> attribute (used to determine on which host a component should be deployed) to a component description, based on the value of an attribute <span class="T3">sfLogicalHost</span>. It maps the logical host to the physical host in some way not defined here &ndash; say by using the method <span class="T3">mapHost</span>. </p>
<p class="Text body">The class might be defined as follows:</p>
<p class="Code">package org.smartfrog,example;</p>
<p class="Code"></p>
<p class="Code">class MapHost implements PhaseAction {</p>
<p class="Code">ComponentDescription cmp = null;</p>
<p class="Code"></p>
<p class="Code">public void forComponent (ComponentDescription c) {</p>
<p class="Code">cmp = c;</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">public void doit() {</p>
<p class="Code">String logicalHost = c.sfResolve(</p>
<p class="Code">Reference.fromString("sfLogicalHost"));</p>
<p class="Code">c.addAttribute("sfProcessHost", mapHost(logicalHost));</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">private String mapHost(String logical) { &hellip; }</p>
<p class="Code">}</p>
<p class="P21">This class may then be used in a description, to be acted on in the phase <span class="T3">mapHosts</span>, as follows</p>
<p class="Code">phaseList ["type", "place", "sfConfig", "link", </p>
<p class="Code">"function", "predicate", "mapHosts"];</p>
<p class="Code"></p>
<p class="Code">MappedCompound extends Compound { </p>
<p class="Code">phase.mapHosts "org.smartfrog.example.MapHost"; </p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">sfConfig extends MappedCompound {</p>
<p class="Code">sfLogicalHost "databaseHost";</p>
<p class="Code">component1 extends Prim { &hellip;}</p>
<p class="Code">component2 extends Prim { &hellip; }</p>
<p class="Code">}</p>
<p class="Text body">The phase list adds the mapping phase to the end, providing for the host mapping. The <span class="code inline">MappedCompound</span>, when used, carries its phase attribute with it. Consequently, it is now contained within <span class="code inline">sfConfig</span>. Thus during that last phase, <span class="code inline">sfConfig</span> will be mapped to the correct physical host.</p>
<a name="N10D52"></a><a name="Functions"></a>
<h4>Functions </h4>
<p class="Text body">Functions are evaluated during a predefined phase, named <span class="T3">function</span>, with the effect that an attribute obtains the value of the evaluated function. To make functions easier to write, a predefined abstract <span class="T3">PhaseAction</span>, called <span class="T4">BaseFunction</span> from package</p>
<p class="Code last line">org.smartfrog.sfcore.languages.sf.functions</p>
<p class="Text body">is provided that makes writing new functions easier.</p>
<p class="Text body">New functions should extend the class <span class="T3">BaseFunction</span> and provide the method <span class="T3">doFunction()</span>, returning the result of the function as an <span class="T3">Object</span>. Any attribute may be accessed during the evaluation process.</p>
<p class="Text body">
<span class="T3">BaseFunction</span> is documented in the Javadoc and predefined functions are documented in section 13.</p>
<a name="N10D81"></a><a name="Predicates"></a>
<h4>Predicates </h4>
<p class="Text body">Predicates are evaluated during a predefined phase, named <span class="T4">predicate</span>, with the effect that the associated predicate class is evaluated and any errors notified to the user by generating an appropriate exception. Most predicates will be instances of <span class="T4">Schema</span>, however users may define their own. To make user-defined predicates easier to define, a class <span class="T4">BasePredicate</span> from package</p>
<p class="Code last line">org.smartfrog.sfcore.languages.sf.predicates</p>
<p class="Text body">is provided that makes writing new predicates easier.</p>
<p class="Text body">New predicates should extend the class <span class="T3">BasePredicate</span> and provide the method <span class="T3">doPredicate()</span>, throwing the exception</p>
<p class="Code last line">SmartFrogCompileResolutionException </p>
<p class="Text body">if there is an error. Any attribute may be accessed during the predicate evaluation.</p>
<p class="Text body">
<span class="T3">BasePredicate</span> is documented in the Javadoc and the predefined predicate <span class="T5">Schema</span> is documented in section 14.</p>
<a name="N10DB6"></a><a name="Programming+with+the+Parser"></a>
<h3 class="boxed">Programming with the Parser</h3>
<a name="N10DBB"></a><a name="Background-N10DBB"></a>
<h4>Background</h4>
<p class="Text body">The SmartFrog framework is designed to support a range of possible languages to define configurations for the deployment engine to instantiate. The languages are all required to follow a common model for their processing, and to eventually produce data structures that are suitable for the deployment system. The default language is the base SmartFrog language defined above, and which uses the file extension &ldquo;<span class="code inline">.sf</span>&rdquo;.</p>
<p class="Text body">The first stage of language processing is the parser &ndash; a tool for turning text into data structures for further processing. The parser interface allows programmers to select the parser based either on the language type of the file (as defined by file extension), by direct selection, or simply using the default (sf) parser. </p>
<p class="Text body">After parsing, the data structures produced must implement an interface for driving the remaining resolution phases. This interface is </p>
<p class="Code indented">org.smartfrog.parser.Phases</p>
<p class="Text body"></p>
<p class="Text body">Following the invocation of the various phases, the data is converted into a hierarchy of data supporting the <span class="T4">ComponentDescription</span> interface, which may then be passed to the deployment system.</p>
<p class="Text body">Using this model, it is reasonably easy to define a new language and integrate it into the system. The default SF language is the first such, but others such as XML based languages, or the more advanced SF2 language currently under development are also possible.</p>
<p class="Text body">The remainder of this section describes how to invoke the parser, how to step the language data structures through the various processing phases, and finally the nature of the resultant <span class="T4">ComponentDescription</span> data structures.</p>
<a name="N10DE3"></a><a name="Summary+of+Language+Processing"></a>
<h4>Summary of Language Processing</h4>
<p class="Text body">All of the tools provided with the SmartFrog system handle a SmartFrog text in an identical way to produce a fully resolved deployable description. The process is basically:</p>
<ul>
<li>
<p class="P8">parse the text stream to produce hierarchical data structures</p>
</li>
<li>
<p class="P8">carry out all the phases, which for the default primary language are</p>
<ul>
<li>
<p class="P8">type resolve the root </p>
</li>
<li>
<p class="P8">place resolve the root</p>
</li>
<li>
<p class="P8">extract attribute <span class="code inline">sfConfig</span> from the root</p>
</li>
<li>
<p class="P8">link resolve <span class="code inline">sfConfig</span>
</p>
</li>
<li>
<p class="P8">evaluate any functions in <span class="code inline">sfConfig</span>
</p>
</li>
<li>
<p class="P8">check predicates and schemas in <span class="code inline">sfConfig</span>
</p>
</li>
</ul>
</li>
<li>
<p class="P8">
<span class="T18">convert to standard data model, creating simple normalised attribute tree</span>
</p>
</li>
</ul>
<a name="N10E20"></a><a name="The+Parser"></a>
<h4>The Parser</h4>
<p class="Text body">The SmartFrog parser is implemented as a Java class with a method to parse an <span class="T3">InputStream</span> producing an instance of the class <span class="T4">ComponentDescription</span>, the Java class representing the parsed text allowing programmatic manipulation of the information. Any <span class="T4">InputStream</span> may be used, thus the parser may be invoked on a <span class="T3">String</span>, a <span class="T3">File</span>, a <span class="T3">URL</span>, or any indeed any object that provides a stream model.</p>
<p class="Text body">During parsing, a number of include files or URLs may be specified indicating text that should be included into the current parse. It should be noted that unlike C, the text is not merely embedded into the source text, rather the files are parsed independently by the parser and the consequent data embedded into the resultant <span class="T4">ComponentDescription</span> data structure produced by the initial stream. Note that in principle, the parsers of include files may be different from the parser for the main stream, thus providing a means for including files in different notations. However, the mechanisms for doing so are not covered in this manual.</p>
<a name="N10E47"></a><a name="The+Parser+API"></a>
<h5>The Parser API</h5>
<p class="Text body">Under normal circumstances, users of SmartFrog will not be expected to use the parser directly. Rather the parser will be invoked on the users behalf by the tools and scripts provided to start and run the SmartFrog framework. However, just in case the need arises to invoke the parser within user code the parser API is now described.</p>
<p class="Text body">Two aspects must be considered:</p>
<ol>
<li>
<p class="P107">Ensuring that security properties are maintained: if security is required, the appropriate actions should be taken to ensure that only streams from signed and trusted sources are used.</p>
</li>
<li>
<p class="P107">Invoking the parser itself on the stream.</p>
</li>
</ol>
<p class="Text body">The security model is covered in section 7, and this should be read in detail before implementing any secure code, however enough of the security API is defined here for completeness.</p>
<a name="N10E5E"></a><a name="Ensuring+Security"></a>
<h5>Ensuring Security</h5>
<p class="Text body">Two important steps must be carried out to ensure that the security of the SmartFrog framework is not compromised. The first is to initialize the SmartFrog security infrastructure, if this is not already done, and the second is to ensure that every resource (test file, URL, etc) is loaded through the secure mechanisms provided.</p>
<p class="Text body">Under normal circumstances, users will be using the parser from within the SmartFrog system itself; writing components that use the parser. However, just in case this is not so and security is still required, initializing the security mechanisms is carried out by invoking the <span class="T4">initSecurity()</span> static method on the <span class="T4">SFSecurity</span><span class="T7"> class from package </span><span class="T4">org.smartfrog.sfcore.security</span><span class="T7">, as follows:</span>
</p>
<p class="Code indented">import org.smartfrog.sfcore.security.SFSecurity;</p>
<p class="Code indented">&hellip;</p>
<p class="Code indented">SFSecurity.initSecurity();</p>
<p class="Text body"></p>
<p class="Text body">Once the security has been initialized, streams may be created on strings or files as required. However, to ensure that security is maintained, it is important that the correct class loaders are used for accessing any external resources. This is achieved by using the following invocation to create a stream from the resource:</p>
<p class="Code indented">import org.smartfrog.sfcore.security.SFClassLoader;</p>
<p class="Code indented">&hellip;</p>
<p class="Code indented">InputStream stream = SFClassLoader.getResourceAsStream(url);</p>
<a name="N10E90"></a><a name="Invoking+The+Parser"></a>
<h5>Invoking The Parser </h5>
<p class="Text body">Once a stream is created, a parser instance may be created and the input stream parsed to generate the data model. This is done through the following code</p>
<p class="Code indented">import org.smartfrog.sfcore.parser.SFParser;</p>
<p class="Code indented">import org.smartfrog.sfcore.parser.SFPhases;</p>
<p class="Code indented"></p>
<p class="Code indented">&hellip;</p>
<p class="Code indented">Phases component = new SFParser().sfParse(stream);</p>
<p class="Text body"></p>
<p class="Text body">The <span class="T3">getParser()</span> method returns a parser for the currently selected language (currently only one is available) and this parser supports the <span class="T3">sfParse(InputStream s)</span> method to parse the input stream. </p>
<p class="Text body">If the parser for a different language is required, say for the sf2 language, the following code is required</p>
<p class="Code indented">import org.smartfrog.sfcore.parser.SFParser;</p>
<p class="Code indented">import org.smartfrog.sfcore.parser.Phases;</p>
<p class="Code indented"></p>
<p class="Code indented">&hellip;</p>
<p class="Code indented">Phases component = new SFParser("sf2").sfParse(stream);</p>
<p class="Text body"></p>
<p class="Text body">The parser is built for the correct language, then asked to parse a stream.</p>
<p class="Text body">The <span class="code inline">SFSystem</span> command-line parameters that represent URLs of descriptions to load are examined to determine from the extension which parser should be used.</p>
<a name="N10ED0"></a><a name="Evaluating+The+Phases"></a>
<h5>Evaluating The Phases</h5>
<p class="Text body">Once the parser has completed, the resultant data structures must implement the <span class="T4">Phases</span> interface. Through the use of this interface the various phases of the language processing are carried out &ndash; either as a single step or by carrying them out one at a time. After each phase, date structures that implement the <span class="T4">Phases</span> interface must be returned.</p>
<p class="Text body">The complete description of the API is given in the Javadoc, but the following examples are probably sufficient to illustrate the process.</p>
<p class="Text body">To evaluate all phases in one go:</p>
<p class="Code indented">Phases phases = new SFParser().sfParse(stream);</p>
<p class="Code indented">phases = phases.sfResolvePhases();</p>
<p class="Text body"></p>
<p class="Text body">To extract the phases, then apply them one at a time:</p>
<p class="Code indented">Phases phases = new SFParser().sfParse(is);</p>
<p class="Code indented">Vector thePhases = phases.sfGetPhases();</p>
<p class="Code indented"></p>
<p class="Code indented">for (Enumeration e = thePhases.elements(); e.hasMoreElements();) {</p>
<p class="Code indented">phases = phases.sfResolvePhase((String) e.nextElement());</p>
<p class="Code indented">}</p>
<a name="N10F02"></a><a name="Converting+to"></a>
<h5>Converting to ComponentDescription</h5>
<span class="code inline">ComponentDescription</span>
<p class="Text body">Before handing the data to the deployment system, the languages own data structures must be converted to those expected by the deployment system &ndash; namely the standard data model implementing the <span class="T4">ComponentDescription</span> interface (normally, but not necessarily) an extension of <span class="T4">ComponentDescriptionImpl</span>.</p>
<p class="Text body">This is done using the <span class="T4">sfAsComponentDescription</span> method defined in <span class="T4">Phases</span>. The full code for parsing and processing a stream in the default language is</p>
<p class="Code indented">Phases component = new SFParser().sfParse(stream);</p>
<p class="Code indented">phases = phases.sfResolvePhases();</p>
<p class="Code indented">ComponentDescription component.sfAsComponentDescription();</p>
<a name="N10F2C"></a><a name="The+Common+Data+Model"></a>
<h3 class="boxed">The Common Data Model</h3>
<p class="Text body">This section describes the data structures produced after the complete cycle of language processing (i.e. phase resolution and conversion to the core data model using sfAsComponentDescription). These are the structures that are understood and accepted by the SmartFrog run-time system.</p>
<p class="Text body">The primary data structures that are generated as the output of this process implement the interface <span class="T4">ComponentDescription</span>, and it is this interface that users must understand to be able to create interesting tools or components. These data structures define the concept of an ordered attribute set.</p>
<p class="Text body">In addition, the classes that are used to represent the various attrubute values need to be considered: both the basic values such as Integers and Booleans, and the references (all LAZY by this time).</p>
<p class="Text body">In all cases, these interfaces and classes are fully defined in the accompanying Javadoc. The description provided here is only partial and is to give an overall feeling for the overall structure of the Java representation. The details of exceptions should also be obtained from the Javadoc.</p>
<a name="N10F41"></a><a name="Basic+Values"></a>
<h4>Basic Values</h4>
<p class="Text body">Each of the basic values that have a syntax in the SmartFrog notation are mapped to different classes in Java. Wherever possible, they are mapped directly to the most obvious class in Java.</p>
<ul>
<li>
<p class="P108">Numbers are mapped to the equivalent Java subclass on <span class="T19">java.lang.Number</span>.</p>
</li>
<li>
<p class="P108">Booleans are mapped to the class <span class="T19">java.lang.Boolean</span><span class="T2">.</span>
</p>
</li>
<li>
<p class="P109">Strings are mapped to the class <span class="code inline">java.lang.String</span><span class="T2">.</span>
</p>
</li>
<li>
<p class="P109">NULL is mapped to the new SmartFrog class <span class="code inline">org.smartfrog.sfcore</span><span class="code inline">.common.SFNull</span><span class="T2">.</span> This is defined so that there is exactly one value of <span class="code inline">SFNull</span>.</p>
</li>
<li>
<p class="P109">Vectors are mapped to <span class="T19">java.util.Vector</span>.</p>
</li>
<li>
<p class="P109">Byte arrays are mapped to the new SmartFrog class <span class="T19">org.smartfrog.sfcore.common.SFByteArray</span><span class="T2">. </span>From instances of this class, the byte array (<span class="code inline">byte[]</span>) can be obtained. Instances are immutable.</p>
</li>
</ul>
<p class="P10">Values of other types can be contained within Component Descriptions, but these may not be properly handled by some of the operations in SmartFrog. In particular, although SmartFrog functions can in principle return values of any class, and these will be patched into the attribute tree, when the conversion to the final component description form occurs with the <span class="code inline">sfAsComponentDescription</span> method, these will be rejected. (This is because the soon-to-be-introduced description signing will not know how to handle these arbitrary values properly.) Values of arbitrary types can be serialized into byte arrays, and then extracted and deserialized at the appropriate time.</p>
<a name="N10F96"></a><a name="Reference"></a>
<h4>Reference</h4>
<p class="Text body">
<span class="code inline">Reference</span> is the Java representation of the references that may be used in the three areas: references to super-types, placement references and as links. References are lists of <span class="T3">ReferencePart</span>, each indicating a single step in the resolution that must occur.</p>
<p class="Text body">The only interesting methods are those for constructing references, namely the constructors and the method <span class="T3">fromString</span>. The other methods are typical of those required for manipulating lists, such as adding and removing parts and enumerating over the elements.</p>
<p class="Text body">There are two constructors &ndash; one for an empty reference (one with no parts) and one for constructing a reference with a single part. Other parts must either be added to these basic references, or the reference may be created by parsing a string.</p>
<p class="Code indented">static<span class="T6"> </span>Reference<span class="T6"> fromString (</span>String<span class="T6"> </span>refString) </p>
<p class="body text last alternative">Utility method to create a reference from a string. The method is extremely expensive as it creates an instance of a parser and should therefore not be used too freely.</p>
<p class="Text body">
<span class="code inline">ReferencePart</span> is the parent class of all reference parts, there is one per syntactic reference part (<span class="code inline">ROOT</span>, <span class="code inline">ATTRIB</span>, etc.). Again, the main interest is in the constructors for these. There are a couple of static helper methods for their construction defined in <span class="code inline">ReferencePart</span>.</p>
<a name="N10FD3"></a><a name="ComponentDescription"></a>
<h4>ComponentDescription</h4>
<p class="Text body">A <span class="T3">ComponentDescription</span> is an interface, with default implementation <span class="T3">ComponentDescriptionImpl</span>, which represents the concept of an attribute set in the syntax. Consequently, it has a number of methods that enable the creation and traversal of the containment and extension hierarchies.</p>
<p class="Text body">
<span class="code inline">ComponentDescription</span>, in addition to defining its own methods, extends three further interfaces, two of which needs further description: <span class="T4">ReferenceResolver</span> and <span class="T5">Copying</span>. The third, <span class="T4">ComponentDeployer</span>, defines methods that are used internally by the SmartFrog framework.</p>
<p class="Text body">A base implementation of the interface <span class="T4">ComponentDescription</span> is the class <span class="T4">ComponentDescriptionImpl</span><span class="T5"> </span>is provided by the framework. This class may be generated directly by the language processor, or users may produce a class which extends it in some way.</p>
<p class="Text body">The interface can be considered in three parts:</p>
<ol>
<li>
<p class="P110">the core interface for construction and traversal.</p>
</li>
<li>
<p class="P110">a copying interface which provides a deep copy operator essential when handling descriptions.</p>
</li>
<li>
<p class="P110">a reference resolution interface, defining methods to look up attribute values given references that describe paths through a description hierarchy.</p>
</li>
</ol>
<a name="N11013"></a><a name="Core"></a>
<h5>Core </h5>
<p class="Text body">TO BE DONE </p>
<p class="Text body">cover add/remove/replace attribute, iterate over attributes, get the parent.</p>
<a name="N1101E"></a><a name="Copying"></a>
<h5>Copying</h5>
<p class="Text body">The interface defines two methods of note &ndash; a deep copy operator that returns an equivalent structure of data and a clone method that returns a shallow copy. The copy method is recursive, in that it clones the top level component description, then embeds within it all the data contained in the copied description - invoking the copy method first if this data implements the Copying interface.</p>
<p class="Code indented">public Object copy();</p>
<p class="body text alternative">Produce a deep copy of the component description</p>
<p class="Text body"></p>
<p class="Code indented">public Object clone();</p>
<p class="body text last alternative">Produce a shallow copy of the component description</p>
<a name="N11034"></a><a name="ReferenceResolution"></a>
<h5>ReferenceResolution</h5>
<p class="Text body">The reference resolution interface contains a number of methods to locate attributes within the hierarchy of component descriptions. The main method provided is the following:</p>
<p class="Code indented">Object <span class="T6">sfResolve</span>(Reference r) </p>
<p class="body text last alternative">Resolve a given reference in the ComponentDescription hierarchy starting from this component.</p>
<p class="Text body">In addition to this method, there is a whole family of variants, such as methods which take strings rather then references, or define the specific return type so that users can avoid the class-caste, and so on. These are fully documented in the Javadoc.</p>
<a name="N11049"></a><a name="The+SmartFrog+Grammar+Rules"></a>
<h3 class="boxed">The SmartFrog Grammar Rules</h3>
<p class="Text body">SmartFrog defines the default language's grammar using the Java Compiler Compiler system from Sun. This is a tool known as JavaCC. The SmartFrog grammar rules described here are part of the JavaCC input, the file DefaultParser.jj, which is available in the source distribution. The listing is derived from this file.</p>
<p class="Code">/*</p>
<p class="Code">* Main entry point to the grammar</p>
<p class="Code">*/</p>
<p class="Code">AttributesEntry ::= AttributeList <span class="T6">EOF</span>
</p>
<p class="Code"></p>
<p class="Code">/*</p>
<p class="Code">* Entry point for Reference parser (as used in sfResolveFromParser)</p>
<p class="Code">*/</p>
<p class="Code">ReferenceEntry ::= Reference <span class="T6">EOF</span>
</p>
<p class="Code"></p>
<p class="Code">/*</p>
<p class="Code">* Entry point for any value parser (used in tools such as sfGui)</p>
<p class="Code">*/</p>
<p class="Code">AnyValueEntry ::= Value <span class="T6">EOF</span>
</p>
<p class="Code"></p>
<p class="Code">/*</p>
<p class="Code">* Entry point for primitive value parser (used in tools such as sfGui)</p>
<p class="Code">*/</p>
<p class="Code">PrimitivevalueEntry ::= Basic <span class="T6">EOF</span>
</p>
<p class="Code"></p>
<p class="Code">/* </p>
<p class="Code">* Main body of grammar</p>
<p class="Code">*/</p>
<p class="Code">AttributeList::= ( Attribute</p>
<p class="Code">| <span class="T6">#include</span> String</p>
<p class="Code">| <span class="T6">;</span>
</p>
<p class="Code">)*</p>
<p class="Code"></p>
<p class="Code">Attribute::= Name Value</p>
<p class="Code"></p>
<p class="Code">Name::= <span class="T6">--</span> | (WORD [ <span class="T6">:</span> Name ])</p>
<p class="Code"></p>
<p class="Code">Value::= Component</p>
<p class="Code">| SimpleValue <span class="T6">;</span>
</p>
<p class="Code">| <span class="T6">;</span>
</p>
<p class="Code"></p>
<p class="Code">SimpleValue::= Reference</p>
<p class="Code">| Basic</p>
<p class="Code">| Operator</p>
<p class="Code">| IfThenElse</p>
<p class="Code">| Vector</p>
<p class="Code"></p>
<p class="Code">Operator::=</p>
<p class="Code">
<span class="T6">(</span>
</p>
<p class="Code">(UnaryOp SimpleValue ) </p>
<p class="Code">| (SimpleValue [ BinaryOp SimpleValue ])</p>
<p class="Code">| (SimpleValue [ (NaryOp SimpleValue)* ])</p>
<p class="Code">
<span class="T6">)</span>
</p>
<p class="Code"></p>
<p class="Code">IfThenElse::= <span class="T6">IF</span> SimpleValue <span class="T6">THEN</span> SimpleValue <span class="T6">ELSE</span> SimpleValue <span class="T6">FI</span>
</p>
<p class="Code"></p>
<p class="Code">Vector::= <span class="T6">[</span> [SimpleValue ( <span class="T6">,</span> SimpleValue) *] <span class="T6">]</span>
</p>
<p class="Code"></p>
<p class="Code">Component::= <span class="T6">extends</span> [<span class="T6">LAZY] </span><span class="T9">Type Body</span>
</p>
<p class="Code"></p>
<p class="Code">Type::= [ <span class="T6">NULL</span> | BaseReference ]</p>
<p class="Code"></p>
<p class="Code">Body ::= (<span class="T6"> ;</span> | <span class="T6">{</span> AttributeList <span class="T6">} </span>)</p>
<p class="Code"></p>
<p class="Code">Reference::= [ <span class="T6">LAZY</span>] BaseReference</p>
<p class="Code"></p>
<p class="Code">BaseReference::= ReferencePart ( <span class="T6">: </span>ReferencePart)*</p>
<p class="Code"></p>
<p class="Code">ReferencePart::= <span class="T6">ROOT</span>
</p>
<p class="Code">| <span class="T6">PARENT</span>
</p>
<p class="Code">| (<span class="T6">ATTRIB</span> WORD)</p>
<p class="Code">| (<span class="T6">HERE</span> WORD)</p>
<p class="Code">| <span class="T6">THIS</span>
</p>
<p class="Code">
<span class="T6"></span><span class="T9">|</span><span class="T6"> </span><span class="T9">WORD</span>
</p>
<p class="Code">| (<span class="T6">PROPERTY</span> WORD)</p>
<p class="Code">| (<span class="T6">IPROPERTY</span> WORD)</p>
<p class="Code">| (<span class="T6">HOST</span> (WORD | STRING))</p>
<p class="Code">| <span class="T6">PROCESS</span>
</p>
<p class="Code">| WORD</p>
<p class="Code"></p>
<p class="Code">Basic::= String</p>
<p class="Code">| Number</p>
<p class="Code">| Boolean</p>
<p class="Code">| ByteArray</p>
<p class="Code">| <span class="T6">[|</span> Basic (<span class="T6">, </span>Basic)* <span class="T6">|]</span>
</p>
<p class="Code">| <span class="T6">NULL</span>
</p>
<p class="Code"></p>
<p class="Code">Number::= DOUBLE </p>
<p class="Code">| FLOAT</p>
<p class="Code">| INTEGER</p>
<p class="Code">| LONG</p>
<p class="Code"></p>
<p class="Code">String::= STRING</p>
<p class="Code">| MULTILINESTRING</p>
<p class="Code"></p>
<p class="Code">Boolean::= <span class="T6">true</span> | <span class="T6">false</span>
</p>
<p class="Code"></p>
<p class="Code">
<span class="T6"></span><span class="T9">ByteArray::= Hex|Dec|Oct|Bin|B64 </span>
</p>
<p class="P111">// only Hex currently implemented</p>
<p class="Code"></p>
<p class="Code">
<span class="T9">UnaryOp::= !</span>
</p>
<p class="Code"></p>
<p class="Code">BinaryOp::= <span class="T6">-</span> | <span class="T6">/</span> | <span class="T6">==</span> | <span class="T6">!=</span> | <span class="T6">&gt;=</span> | <span class="T6">&gt;</span> | <span class="T6">&lt;=</span> | <span class="T6">&lt;</span>
</p>
<p class="Code"></p>
<p class="Code">NaryOp::= <span class="T6">+</span> | <span class="T6">*</span> | <span class="T6">++</span> | <span class="T6">&lt;&gt;</span> | <span class="T6">&amp;&amp;</span> | <span class="T6">||</span>
</p>
<a name="N11240"></a><a name="The+SmartFrog+Lexical+Rules"></a>
<h3 class="boxed">The SmartFrog Lexical Rules</h3>
<p class="Text body">The SmartFrog lexical rules described here are part of the JavaCC input, the file DefaultParser.jj, which is available in the source distribution. The listing here is a slight simplification of this file.</p>
<p class="Code">/* White Space */</p>
<p class="Code">SKIP : " "| "\t"| "\n"| "\r"| "\f"</p>
<p class="Code"></p>
<p class="Code">/* Comments */</p>
<p class="Code">SINGLELINECOMMENT: "//"(~["\n&rdquo;,&rdquo;\r"])*</p>
<p class="Code">FORMALCOMMENT: "/**" ... "*/ "</p>
<p class="Code">MULTILINECOMMENT: &ldquo;/*" ... &rdquo;*/"</p>
<p class="Code"></p>
<p class="Code">/* Reserved Tokens */</p>
<p class="Code">RESERVED: ";" | "," | "{" | "}" | "[" | "]" | ":" | </p>
<p class="Code">"true" | "false" | "NULL" | <span class="T20">"</span>--" |</p>
<p class="Code">"extends" | "LAZY" | <span class="T20">"</span>ROOT" | "ATTRIB" | "HERE" |</p>
<p class="Code">
<span class="T20">"</span>THIS&rdquo; | "PROPERTY" | "IPROPERTY" | "PARENT" |</p>
<p class="Code">"HOST" | <span class="T20">"</span>PROCESS" | "#include" | <span class="T20">"</span>(<span class="T20">"</span> | <span class="T20">"</span>)" |</p>
<p class="Code">
<span class="T20">"</span>==" | <span class="T20">"</span>!=" | <span class="T20">"</span>&gt;=" | <span class="T20">"</span>&gt;" | <span class="T20">"</span>&lt;=" | <span class="T20">"</span>&lt;" | <span class="T20">"</span>&lt;&gt;" | <span class="T20">"</span>!" |</p>
<p class="Code">
<span class="T20">"</span>+" | <span class="T20">"</span>-" | <span class="T20">"</span>*" | <span class="T20">"</span>/" | <span class="T20">"</span>++" | <span class="T20">"</span>&amp;&amp;" | <span class="T20">"</span>||" |</p>
<p class="Code">
<span class="T20">"</span>IF" | <span class="T20">"</span>THEN" | <span class="T20">"</span>ELSE" | <span class="T20">"</span>FI"</p>
<p class="Code"></p>
<p class="Code">/* Tokens &ndash; using Unicode */</p>
<p class="Code">WORD: LETTER (LETTER|DIGIT|SPECIAL)* </p>
<p class="Code">SPECIAL: [".", "_", "-", "+", "@", "#", "~", "$", "%", "^", "&amp;"] </p>
<p class="Code">LETTER:</p>
<p class="Code">[</p>
<p class="Code">"\u0024", </p>
<p class="Code">"\u0041"-"\u005a",</p>
<p class="Code">"\u005f",</p>
<p class="Code">"\u0061"-"\u007a",</p>
<p class="Code">"\u00c0"-"\u00d6",</p>
<p class="Code">"\u00d8"-"\u00f6",</p>
<p class="Code">"\u00f8"-"\u00ff",</p>
<p class="Code">"\u0100"-"\u1fff",</p>
<p class="Code">"\u3040"-"\u318f",</p>
<p class="Code">"\u3300"-"\u337f",</p>
<p class="Code">"\u3400"-"\u3d2d",</p>
<p class="Code">"\u4e00"-"\u9fff",</p>
<p class="Code">"\uf900"-"\ufaff"</p>
<p class="Code">]</p>
<p class="Code">DIGIT:</p>
<p class="Code">[</p>
<p class="Code">"\u0030"-"\u0039",</p>
<p class="Code">"\u0660"-"\u0669",</p>
<p class="Code">"\u06f0"-"\u06f9",</p>
<p class="Code">"\u0966"-"\u096f",</p>
<p class="Code">"\u09e6"-"\u09ef",</p>
<p class="Code">"\u0a66"-"\u0a6f",</p>
<p class="Code">"\u0ae6"-"\u0aef",</p>
<p class="Code">"\u0b66"-"\u0b6f",</p>
<p class="Code">"\u0be7"-"\u0bef",</p>
<p class="Code">"\u0c66"-"\u0c6f",</p>
<p class="Code">"\u0ce6"-"\u0cef",</p>
<p class="Code">"\u0d66"-"\u0d6f",</p>
<p class="Code">"\u0e50"-"\u0e59",</p>
<p class="Code">"\u0ed0"-"\u0ed9",</p>
<p class="Code">
<span class="T8"></span>"\u1040"-"\u1049"</p>
<p class="Code">]</p>
<p class="Code"></p>
<p class="Code">/* Literals */</p>
<p class="Code">STRING: ("\"" (</p>
<p class="Code">(~["\"","\\","\n","\r"])</p>
<p class="Code">| ("\\"</p>
<p class="Code">( ["n","t","b","r","f","\\","'","\""]</p>
<p class="Code">| ["0"-"3"] ["0"-"7"] ["0"-"7"]</p>
<p class="Code">)</p>
<p class="Code">)</p>
<p class="Code">)* "\"")</p>
<p class="Code"></p>
<p class="Code">MULTILINESTRING: ("##" (</p>
<p class="Code">(~["#","\\"])</p>
<p class="Code">| ("\\"</p>
<p class="Code">( ["n","t","b","r","f","\\","'","#"]</p>
<p class="Code">| ["0"-"3"] ["0"-"7"] ["0"-"7"]</p>
<p class="Code">)</p>
<p class="Code">)</p>
<p class="Code">)* "#")</p>
<p class="Code"></p>
<p class="Code">NUMBER: &lt;INTEGER&gt; | &lt;FLOAT&gt; | &lt;LONG&gt; | &lt;DOUBLE&gt;</p>
<p class="Code"></p>
<p class="Code">INTEGER: (("-")? ["1"-"9"] (["0"-"9"])*) | "0" </p>
<p class="Code"></p>
<p class="Code">FLOAT_BASE: ("-")?</p>
<p class="Code">(</p>
<p class="Code">(["0"-"9"])+ "." (["0"-"9"])* (&lt;EXPONENT&gt;)?</p>
<p class="Code">| "." (["0"-"9"])+ (&lt;EXPONENT&gt;)?</p>
<p class="Code">| (["0"-"9"])+ &lt;EXPONENT&gt;</p>
<p class="Code">| (["0"-"9"])+ (&lt;EXPONENT&gt;)?</p>
<p class="Code">)</p>
<p class="Code"></p>
<p class="Code">EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ &gt;</p>
<p class="Code"></p>
<p class="Code">DOUBLE: &lt;FLOAT_BASE&gt; (["d", "D"])?</p>
<p class="Code"></p>
<p class="Code">LONG: &lt;INTEGER&gt; (["l", "L"])?</p>
<p class="Code"></p>
<p class="Code">FLOAT: &lt;FLOAT_BASE&gt; ["f", "F"]</p>
<p class="Code"></p>
<p class="Code">Hex: "#HEX#" (["A"-"F", "a-f", "0"-"9", "\n", "\t", " "])* "#"</p>
<p class="Code">Oct: "#OCT#" (["0"-"7", "\n", "\t", " "])* "#" </p>
<p class="Code">Bin: "#BIN#" (["0"-"1", "\n", "\t", " "])* "#" </p>
<p class="Code">Dec: "#DEC#" (["0"-"9", "\n", "\t", " "])* "#" </p>
<p class="Code">B64: "#B64#" (["A"-"Z", "a-z","0"-"9", "/", "+", "\n", "\t", " "])* "#"</p>
<p class="Code"></p>
<a name="N113CF"></a><a name="Predefined+SmartFrog+Functions"></a>
<h3 class="boxed">Predefined SmartFrog Functions</h3>
<p class="Text body">SmartFrog provides a number of functions. These functions are all available as templates that are defined in a file which must be included if they are to be used. However, some are also available as operators, using the SmartFrog operator syntax, and in this case the include file is not required.</p>
<p class="Text body">The operators are all converted into an instance of the expanded template at time of parsing, so may in every respect be treated in the same way as a use of the template itself. Furthermore, it should be noted that any references that are used within an expression containing operators, these references will be resolved in the context of the templates &ndash; this means that use of reference parts such as <span class="code inline">PARENT</span> are hard to use. <span class="code inline">ATTRIB</span> reference parts are useable in the normal way.</p>
<p class="Text body">Note also that since attribute names may contain many of the operator symbols, it is best to always surround the operators with space characters to ensure that they do not accidentally &ldquo;stick&rdquo; to the names.</p>
<p class="Text body">The functions are defined by including the <span class="T3">functions.sf</span> file as follows:</p>
<p class="Code last line">#include "org/smartfrog/functions.sf"</p>
<p class="Text body">The functions defined as operators may be grouped into three main categories: unary, binary and nary. </p>
<a name="N113F2"></a><a name="Unary+Operators"></a>
<h4>Unary Operators</h4>
<p class="Text body">There is currently only one unary operator, the Boolean negation operator. The syntax for unary operators is</p>
<p class="Code last line">( opsymbol value )</p>
<p class="Text body">The surrounding <span class="T19">( )</span> symbols must be present. All templates for unary operators have as their parameter the attribute &ldquo;<span class="code inline">data</span>&rdquo;. Other attributes are allowed, but are ignored for the purpose of evaluating the function. They may, of course, be used for the definition of the data attribute during earlier phases.</p>
<a name="N11408"></a><a name="not"></a>
<h5>not</h5>
<p class="Text body">Operator symbol: !</p>
<p class="Text body">The function not is defined as the negation of the boolean attribute &ldquo;<span class="code inline">data</span>&rdquo;. If the attribute is not present or of the wrong type, an exception is reported.</p>
<p class="Code">x true;</p>
<p class="Code">foo (! x);</p>
<p class="Code">bar extends not {</p>
<p class="Code">data x;</p>
<p class="Code last line">}</p>
<a name="N11426"></a><a name="Binary+Operators"></a>
<h4>Binary Operators</h4>
<p class="Text body">There are a number of binary operators covering primarily the arithmetic, comparison and logical operators. The syntax for binary operators is</p>
<p class="Code last line">( value opsymbol value )</p>
<p class="Text body">The surrounding <span class="code inline">( )</span> symbols must be present. All templates for binary operators have as their parameter attributes the names &ldquo;<span class="code inline">left</span>&rdquo; and &ldquo;<span class="code inline">right</span>&rdquo;, to indicate which value it is. Other attributes may be present and are ignored whilst evaluating the operator.</p>
<a name="N11440"></a><a name="Minus"></a>
<h5>Minus</h5>
<p class="Text body">Operator symbol: <span class="code inline">-</span>
</p>
<p class="Text body">The minus operator subtracts the right attribute from the left, resulting in a number which satisfies the Java rules for numbers. If either of the two attributes are not numbers, an exception is thrown. Other attributes that may be defined in the template are ignored.</p>
<p class="Code">minus10 extends minus {</p>
<p class="Code">value;</p>
<p class="Code">left value;</p>
<p class="Code">right 10;</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">foo extends minus10 {</p>
<p class="Code">value 34;</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code last line">aFoo ( 34 &ndash; 10 );</p>
<a name="N1146D"></a><a name="divide"></a>
<h5>divide</h5>
<p class="Text body">Operator symbol: /</p>
<p class="Text body">The divide operator divides the left attribute by the right, resulting in a number which satisfies the Java rules for numbers. If either of the two attributes are not numbers, an exception is thrown. Other attributes that may be defined in the template are ignored.</p>
<p class="Code">percent extends product {</p>
<p class="Code">fraction extends divide {</p>
<p class="Code">enum; denom;</p>
<p class="Code">left enum;</p>
<p class="Code">right denom;</p>
<p class="Code">}</p>
<p class="Code">-- 100;</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">foo extends percent {</p>
<p class="Code">fraction:enum 34;</p>
<p class="Code">fraction:denom 56;</p>
<p class="Code last line">}</p>
<p class="Text body"></p>
<a name="N114A0"></a><a name="EQ%2C+NE"></a>
<h5>EQ, NE</h5>
<p class="Text body">Operator symbols: <span class="code inline">==</span>, <span class="code inline">!=</span>
</p>
<p class="Text body">These operators are the comparator operators, equals and not equals respectively. The two attributes, left and right, are compared using the Java equals method (<span class="code inline">left.equals(right)</span>). The result of the function is the boolean value that is returned by that test.</p>
<a name="N114B6"></a><a name="GE%2C+GT%2C+LE%2C+LT"></a>
<h5>GE, GT, LE, LT</h5>
<p class="Text body">Operator symbols: <span class="code inline">&gt;=, &gt;, &lt;=, &lt;</span>
</p>
<p class="Text body">These operators are the numeric value comparators, testing to see if the left attribute value is greater than or equal to (or whatever operator is used) the right attribute. The Java rules for numeric comparison are used.</p>
<a name="N114C4"></a><a name="Nary+Operators"></a>
<h4>Nary Operators</h4>
<p class="Text body">Nary operators are operators that are may have a arbitrary number of attribute parameters. All the attributes provided within the template are assumed to be part of the function, and the names used to provide these attributes are ignored. Thus the &ldquo;unique&rdquo; name &ndash; is normally used for these operators.</p>
<p class="Text body">The syntax for an nary operator is as follows:</p>
<p class="Code last line">( value opsymbol value opsymbol value opsymbol ... )</p>
<p class="Text body">Each of the operator symbols must be identical, though other may be used by nesting the use of operators wherever a value is expected. The above form is converted to the expanded template form during parsing, so any references that are used when a value is expected is resolved relative to the template and not the operator expression.</p>
<a name="N114D5"></a><a name="concat"></a>
<h5>concat</h5>
<p class="Text body">Operator symbol: <span class="code inline">++</span>
</p>
<p class="Text body">The concatenate function takes each of its attribute parameters and concatenates them in the order of definition. These attributes are converted to strings using the <span class="T3">toString()</span> Java method. An example of the use of the concatenate function is:</p>
<p class="Code">myString extends concat {</p>
<p class="Code">a "the meaning of life is ";</p>
<p class="Code">b 42;</p>
<p class="Code">c extends concat {</p>
<p class="Code">a " by ";</p>
<p class="Code">b "Douglas Adams";</p>
<p class="Code">}</p>
<p class="Code last line">}</p>
<p class="Text body">which results in the string <span class="T2">&ldquo;the meaning of life is 42 by Douglas Adams&rdquo;</span>.</p>
<a name="N11506"></a><a name="append"></a>
<h5>append</h5>
<p class="Text body">Operator symbol: <span class="code inline">&lt;&gt;</span>
</p>
<p class="Text body">The append function is similar to the vector function, except that all parameters must be vectors and these are expanded in-line. The difference can be seen by considering the same example</p>
<p class="Code">myVector extends vector {</p>
<p class="Code">-- ["the meaning of life is "];</p>
<p class="Code">-- [42];</p>
<p class="Code">-- extends vector {</p>
<p class="Code">-- " by ";</p>
<p class="Code">-- "Douglas Adams";</p>
<p class="Code">}</p>
<p class="Code last line">}</p>
<p class="Text body">which results in the vector </p>
<p class="Code last line">[ "the meaning of life is", 42, "by", "Douglas Adams"]</p>
<p class="Text body">The operator form can be used for the same purpose. The following definition is equivalent to the definition of <span class="code inline">myVector</span> above.</p>
<p class="Code">MyVector ( ["the meaning of life is"] </p>
<p class="Code">&lt;&gt; [42] </p>
<p class="Code last line">&lt;&gt; ["by", "Douglas Adams"] );</p>
<a name="N11542"></a><a name="sum"></a>
<h5>sum</h5>
<p class="Text body">Operator symbol: <span class="code inline">+</span>
</p>
<p class="Text body">The sum function sums each of its attributes which must be numbers, failure will result in an exception. The names of the attributes are, of course, irrelevant. An example of the use of the sum function is:</p>
<p class="Code">val1 34;</p>
<p class="Code">val2 45;</p>
<p class="Code">num extends sum {</p>
<p class="Code">-- val1;</p>
<p class="Code">-- 345;</p>
<p class="Code">-- val2</p>
<p class="Code">}</p>
<p class="Text body">This will result in <span class="T3">num</span> being set to <span class="T3">424</span>. An equivalent expression is</p>
<p class="Code last line">num (val1 + 345 + val2);</p>
<a name="N11573"></a><a name="product"></a>
<h5>product</h5>
<p class="Text body">Operator symbol: <span class="code inline">*</span>
</p>
<p class="Text body">The product function multiplies each of its attributes type-cast to integers, failure will result in an exception. The order is irrelevant. An example of the use of the product function is:</p>
<p class="Code">times10 extends product {</p>
<p class="Code">ten 10;</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">myNum extends times10 {</p>
<p class="Code">val 34;</p>
<p class="Code last line">}</p>
<p class="Text body">This will result in <span class="T3">myNum</span> being set to <span class="T3">340</span>.</p>
<a name="N115A0"></a><a name="and"></a>
<h5>and</h5>
<p class="Text body">Operator symbol: <span class="code inline">&amp;&amp;</span>
</p>
<p class="Text body">The conjunction operator takes the logical &ldquo;and&rdquo; of all its attribute parameters. Each of the parameters must be a boolean and if they are not, an exception is thrown. As with all nary operators the names of the attributes are irrelevant.</p>
<a name="N115AE"></a><a name="or"></a>
<h5>or</h5>
<p class="Text body">Operator symbol: ||</p>
<p class="Text body">The disjunction operator takes the logical &ldquo;or&rdquo; of all its attribute parameters. Each of the parameters must be a boolean and if they are not, an exception is thrown. As with all nary operators the names of the attributes are irrelevant.</p>
<a name="N115B9"></a><a name="Other+Functions"></a>
<h4>Other Functions</h4>
<p class="Text body">In addition to the operators, there are a number of other functions provided. Some of these also have specialised syntactic forms &ndash; most notably the <span class="code inline">ifThenElse</span> and the vector function. These syntactic forms are converted to the template form at time of parsing, and do not require the use of the include file &ldquo;<span class="code inline">functions.sf</span>&rdquo;. If the templates are used directly, then this file must be included.</p>
<a name="N115C9"></a><a name="IfThenElse"></a>
<h5>IfThenElse</h5>
<p class="Text body">The <span class="code inline">ifThenElse</span> function is provided to conditionally provide a value for an attribute. The template uses three well-known attributes: <span class="code inline">if</span>, <span class="code inline">then</span> and <span class="code inline">else</span>. Other attributes may be present but are ignored. If one of the attributes is not provided, or is the if attribute is not a boolean value, an exception will be thrown. Since the <span class="code inline">ifThenElse</span> template is defined through attributes, these may be changed by extension or placement.</p>
<p class="Code">aStepFunction extends ifThenElse {</p>
<p class="Code">boundary 10;</p>
<p class="Code">value;</p>
<p class="Code"></p>
<p class="Code">if (value &gt; boundary);</p>
<p class="Code">then 20;</p>
<p class="Code">else 30;</p>
<p class="Code">}</p>
<p class="Contents 1"></p>
<p class="Text body">This may now be used as follows:</p>
<p class="Code">aValue extends aStepFunciton {</p>
<p class="Code">value 5;</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">anotherValue extends aStepFunction {</p>
<p class="Code">value 15;</p>
<p class="Code last line">}</p>
<p class="Text body">Which would give values for these two attributes as <span class="code inline">20</span> and <span class="code inline">30</span> respectively.</p>
<p class="Text body">The special syntactic form for <span class="code inline">ifThenElse</span> is as follows:</p>
<p class="Code last line">foo IF (10 &gt; 20) THEN 5 ELSE 15 FI;</p>
<p class="Text body">defining <span class="code inline">foo</span> to be 15. Note that as with all special forms, any references used within it are evaluated relative to the transformed syntax, and not that given. The definition for <span class="code inline">foo</span> above is equivalent to:</p>
<p class="Code">foo extends ifThenElse {</p>
<p class="Code">if (10&gt;20);</p>
<p class="Code">then 5;</p>
<p class="Code">else 15;</p>
<p class="Code last line">}</p>
<a name="N11644"></a><a name="vector"></a>
<h5>vector</h5>
<p class="Text body">The vector function takes each of its attribute parameters in the order provided and creates a vector whose elements are the values of the attributes (names are ignored, hence unique naming is useful). An example is</p>
<p class="Code">myData extends vector {</p>
<p class="Code">-- "the meaning of life is ";</p>
<p class="Code">-- 42;</p>
<p class="Code">-- extends vector {</p>
<p class="Code">-- " by ";</p>
<p class="Code">-- "Douglas Adams";</p>
<p class="Code">}</p>
<p class="Code last line">}</p>
<p class="Text body">which results in the vector with three elements, the third of which is itself a vector.</p>
<p class="Text body">There is a special syntactic form for vector which is as follows:</p>
<p class="Code last line">myData ["the meaning of life is", "42", ["by", "Douglas Adams"]];</p>
<p class="Text body">This is the equivalent of the earlier definition using the template. Again, any reference provided within the vector syntax is resolved relative to the transformation into the template form.</p>
<a name="N11670"></a><a name="formatString"></a>
<h5>formatString</h5>
<p class="Text body">
<span class="T4">FormatString</span> is a function that takes a format string and a set of parameters and creates a resultant string which has the values of the parameters embedded. The format string attribute itself should be named <span class="T4">format</span><span class="T5"> </span>and the various parameter strings should be named <span class="T4">sx</span> where x is a single digit. The format string should identify the places where the various parameter strings should be embedded using the characters &ldquo;<span class="code inline">$x</span>&rdquo; for a single digit x. An example is</p>
<p class="Code">myString extends formatString {</p>
<p class="Code">format "the meaning of $2 is $1";</p>
<p class="Code">s1 42;</p>
<p class="Code">s2 "life";</p>
<p class="Code last line">}</p>
<p class="Text body">The attributes may of course be links to other values, but not <span class="code inline">LAZY</span> links as these are not resolved in time for the function phase.</p>
<a name="N116A0"></a><a name="random"></a>
<h5>random</h5>
<p class="Text body">The <span class="code inline">random</span> function, which in truth is not really a function since it returns a different value for each invocation, returns a random number as follows:</p>
<ul>
<li>
<p class="WW-List Bullet 2">if the attribute <span class="T3">integer</span> is set to <span class="T3">true</span>, an integer between attributes <span class="T3">min</span> and <span class="T3">max</span><span class="T2"> </span>is returned, otherwise a floating point value between 0 and 1. The default values for <span class="code inline">min</span> and <span class="code inline">max</span> are 0 and 10 respectively.</p>
</li>
<li>
<p class="WW-List Bullet 2">if the attribute <span class="T3">seed</span> is provided, and the random number generator has not yet been initialized, that seed is used.</p>
</li>
</ul>
<p class="Text body">Examples of the use of the random are:</p>
<p class="Code">dice extends random {</p>
<p class="Code">integer true;</p>
<p class="Code">min 1;</p>
<p class="Code">max 6;</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">myConfig extends Compound {</p>
<p class="Code">throw1 extends dice;</p>
<p class="Code">throw2 extends dice;</p>
<p class="Code">}</p>
<p class="Text body">Each of <span class="T3">throw1</span> and <span class="T3">throw2</span> will be some random integer between 1 and 6. Note that each invocation in <span class="T3">myConfig</span> is independent. Each JVM contains a single random number generator for use during function resolution.</p>
<a name="N11703"></a><a name="next"></a>
<h5>next</h5>
<p class="Text body">The <span class="code inline">next</span> function is one that returns a monotonically increasing value, guaranteed never to return the same number twice within a single description. Again, it is not strictly a function since it never returns the same value for the same parameters. The only parameter attribute is the <span class="code inline">base</span> attribute, setting a minimum value for the values. If the <span class="code inline">base</span> is below the next value, it is ignored. If it is above, the next value will be the <span class="code inline">base</span>. The default <span class="code inline">base</span> is 0.</p>
<p class="Text body">An example of the use of <span class="T2">next</span> is</p>
<p class="Code">unique extends concat {</p>
<p class="Code">prefix "xxyyyqqq";</p>
<p class="Code">postfix extends next;</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">myConfig extends Compound {</p>
<p class="Code">name extends unique;</p>
<p class="Code">otherAttr 42;</p>
<p class="Code last line">}</p>
<a name="N11740"></a><a name="ref"></a>
<h5>ref</h5>
<p class="Text body">The ref function converts a string to a reference, and then optionally resolves the reference in place or leaves it as a LAZY link. This allows links to be created by using functions over strings, such as concatenation, to generate a reference. The attributes for the ref function are <span class="T21">reference </span><span class="T22">which is the string to convert, and the optional attribute </span><span class="T21">lazy</span><span class="T22"> which defaults to false and controls whether to leave the reference as a lazy link, or to resolve to replace it with the value obtained.</span>
</p>
<p class="Text body">An example of the use of ref is:</p>
<p class="Code">x "ROOT";</p>
<p class="Code">y "a";</p>
<p class="Code">a 24;</p>
<p class="Code"></p>
<p class="Code">myConfig extends ref {</p>
<p class="Code">reference (x ++ y);</p>
<p class="Code">lazy false; // default</p>
<p class="Code last line">}</p>
<p class="Text body">This results in <span class="code inline">myConfig</span> being set to 24.</p>
<a name="N11775"></a><a name="date"></a>
<h5>date</h5>
<p class="Text body">The <span class="code inline">date</span> function returns a string representation of the current date. There are no formatting parameters. Again, this is not strictly a function.</p>
<a name="N11781"></a><a name="userinput"></a>
<h5>userinput</h5>
<p class="Text body">The <span class="code inline">userinput</span> function asks the user for an input on the command line. It returns the value entered. The prompting message may be specified in the <span class="code inline">prompt</span> attribute. </p>
<p class="Code">anything extends userinput {</p>
<p class="Code">prompt "Enter any value";</p>
<p class="Code last line">}</p>
<p class="Text body">This will result in <span class="T3">anything</span><span class="T2"> </span>being set to <span class="T7">whatever </span>has been entered on the command line. A default value may also be set using the attribute &ldquo;<span class="code inline">default</span>&rdquo;. This function is not really meant for serious use, but more for experimentation and testing.</p>
<a name="N117AC"></a><a name="Schemas"></a>
<h3 class="boxed">Schemas</h3>
<p class="Text body">Schemas are descriptions that may be attached to other descriptions and cause them to be checked against the schema description. Schemas are evaluated as part of the standard predicate phase.</p>
<p class="Text body">Schemas are defined by extending the predefined template Schema, defined in the file <span class="T4">/org/smartfrog/predicates.sf</span>:</p>
<p class="Code">mySchema extends Schema {</p>
<p class="Code">// schema entries</p>
<p class="Code last line">}</p>
<p class="Text body">Each of the schema entries are attributes whose names are to be found in the template to be validated. Each of these entries must extend a description that defines certain properties about the attribute. The properties are</p>
<ul>
<li>
<p class="P24">
<span class="code inline">optional</span>: a Boolean that states whether the attribute is optional or compulsory</p>
</li>
<li>
<p class="P24">
<span class="code inline">binding</span>: a string which defines whether the attribute must be lazy <span class="T4">"lazy"</span>), must be eager (<span class="T4">"eager"</span>), or may be either (<span class="code inline">&ldquo;</span><span class="T4">anyBinding</span>&rdquo;) &ndash; this controls whether a link may exist instead of a value of the correct class</p>
</li>
<li>
<p class="P24">
<span class="code inline">class</span>: a string which defines the name of the class which should be found as the value of the attribute (e.g. <span class="code inline">&ldquo;</span><span class="T4">java.lang.Integer</span><span class="code inline">&rdquo;</span>), or any class (<span class="code inline">&ldquo;</span><span class="T4">anyClass</span><span class="code inline">&rdquo;</span>).</p>
</li>
</ul>
<p class="Text body">Thus entries in a schema for a web server component may be</p>
<p class="Code">WebServerSchema extends Schema {</p>
<p class="Code">port extends { </p>
<p class="Code">optional false;</p>
<p class="Code">binding "anyBinding";</p>
<p class="Code">class "java.lang.Integer"; }</p>
<p class="Code">directory extends {</p>
<p class="Code">optional true;</p>
<p class="Code">binding "anyBinding";</p>
<p class="Code">class "java.lang.String"; }</p>
<p class="Code last line">}</p>
<p class="Text body">However this is rather cumbersome, so some helper templates are defined in the include file. These are defined as follows, with the obvious meanings.</p>
<p class="Code">Compulsory extends {</p>
<p class="Code">optional false;</p>
<p class="Code">binding "anyBinding";</p>
<p class="Code">class "anyClass";</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">Optional extends {</p>
<p class="Code">optional true;</p>
<p class="Code">binding "anyBinding";</p>
<p class="Code">class "anyClass";</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">OptionalBoolean extends Optional {</p>
<p class="Code">class "java.lang.Boolean";</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">Boolean extends Compulsory {</p>
<p class="Code">class "java.lang.Boolean";</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">OptionalInteger extends Optional {</p>
<p class="Code">class "java.lang.Integer";</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">Integer extends Compulsory {</p>
<p class="Code">class "java.lang.Integer";</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">OptionalDouble extends Optional {</p>
<p class="Code">class "java.lang.Double";</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">Double extends Compulsory {</p>
<p class="Code">class "java.lang.Double";</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">OptionalLong extends Optional {</p>
<p class="Code">class "java.lang.Long";</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">Long extends Compulsory {</p>
<p class="Code">class "java.lang.Long";</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">OptionalFloat extends Optional {</p>
<p class="Code">class "java.lang.Float";</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">Float extends Compulsory {</p>
<p class="Code">class "java.lang.Float";</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">OptionalString extends Optional {</p>
<p class="Code">class "java.lang.String";</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">String extends Compulsory {</p>
<p class="Code">class "java.lang.String";</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">OptionalVector extends Optional {</p>
<p class="Code">class "java.lang.Vector";</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">Vector extends Compulsory {</p>
<p class="Code">class "java.lang.Vector";</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">OptionalReference extends Optional {</p>
<p class="Code">class "org.smartfrog.sfcore.reference.Reference";</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">Reference extends Compulsory {</p>
<p class="Code">class "org.smartfrog.sfcore.reference.Reference";</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">OptionalCD extends Optional {</p>
<p class="Code">class "org.smartfrog.sfcore.componentdescription.ComponentDescription";</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">CD extends Compulsory {</p>
<p class="Code">class "org.smartfrog.sfcore.componentdescription.ComponentDescription";</p>
<p class="Code last line">}</p>
<p class="Text body">These templates allow for a neater definition of the schema given above;</p>
<p class="Code">WebServerSchema extends Schema {</p>
<p class="Code">port extends Integer;</p>
<p class="Code">directory extends OptionalString;</p>
<p class="Code last line">}</p>
<p class="Text body">To attach a schema to a description, the schema need only be an attribute within the description to which it applies. Thus we can complete the above example as follows:</p>
<p class="Code">// the definition of schemas</p>
<p class="Code">#include "/org/smartfrog/predicates.sf"</p>
<p class="Code"></p>
<p class="Code">WebServerSchema extends Schema {</p>
<p class="Code">port extends Integer;</p>
<p class="Code">directory extends OptionalString;</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">WebServerTemplate extends Prim {</p>
<p class="Code">schema extends WebServerSchema;</p>
<p class="Code">// default value</p>
<p class="Code">port 80; </p>
<p class="Code last line">}</p>
<p class="Text body">Note that the name for the attribute linking the template to its schema need not be, as in this case, <span class="T4">schema</span>. Indeed, a template may have more than one schema attached as attributes, in which case the uses of the template are checked against all schemas attached. </p>
<p class="Text body">Schemas may be extended in the same way as other templates, and their uses may easily be extended through placement as illustrated in the following examples.</p>
<p class="Code">#include "/org/smartfrog/predicates.sf" // the definition of schemas</p>
<p class="Code"></p>
<p class="Code">ThreadedWebServerSchema extends WebServerSchema {</p>
<p class="Code">minimumThreads extends Integer;</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">ThreadedWebServerTemplate extends WebServerTemplate {</p>
<p class="Code">//overwrite with extended schema</p>
<p class="Code">Schema extends ThreadedWebServerSchema; </p>
<p class="Code">minimumThreads 7;</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">AlternativeThreadedWebServerTemplate extends WebServerTemplate {</p>
<p class="Code">// add to existing schema</p>
<p class="Code">schema:minimumThreads extends Integer; </p>
<p class="Code">minimumThreads 7;</p>
<p class="Code last line">}</p>
<p class="Text body">Note that schemas are entirely optional and need be used only if desired. They carry no overhead during deployment and at run-time, but they can be expensive at language processing time.</p>
<p class="Text body">Prim and Compound templates both have schemas associated with them. This can be useful to locate errors, but they also have two other effects. Firstly, when the descriptions are printed in any expanded form the schemas occupy a rather large amount of the overall description and can hide the structure of a description. Secondly, they can make a large description very expensive to process. Consequently, an attribute can be set at the top level to control whether these schemas should be included. Thus the following would switch off the use of the Prim and Compound schemas:</p>
<p class="Code">sfSchema false;</p>
<a name="N11984"></a><a name="Comparing+the+SmartFrog+Notation+with+XML"></a>
<h3 class="boxed">Comparing the SmartFrog Notation with XML</h3>
<p class="Text body">In this appendix, a basic and partial comparison is provided between the SmartFrog notation and XML. This is intended to explain the rationale behind the design choices made in the definition of the SmartFrog notation, and to provide an explanation as to why XML has not been substituted for the SmartFrog notation (it also happens to predate XML by a couple of years). It should be noted, however, that XML can be considered as a syntactic framework within which the SmartFrog language semantics could be encoded. This is not considered below, and only a direct comparison of the core notions is made.</p>
<p class="Text body">The main areas examined in detail are:</p>
<ol>
<li>
<p class="P31">Naming: how attributes are identified and referenced</p>
</li>
<li>
<p class="P31">Composition: how attributes are composed into hierarchies or collections</p>
</li>
<li>
<p class="P31">Inheritance: how collections of attributes are built from other collections</p>
</li>
<li>
<p class="P31">Schemas, typing and validation: how collections are checked for correctness, and the correctness constraints defined</p>
</li>
<li>
<p class="P31">Templates and parameterization: how the notations provide a degree of end-user customization of given configuration templates</p>
</li>
</ol>
<p class="Text body">These are not the only differences, but they are some of the major ones, and have a particular importance when it comes to examining the requirements for a rationally designed configuration notation.</p>
<p class="Heading 4">Naming and Composition</p>
<p class="Text body">Perhaps the most striking difference between the two notations is that in SmartFrog, every attribute is of the same kind (there is no distinction between attributes and elements), and every attribute is named. In XML, there are named attributes (given as an addition to the tag) and elements that are un-named in the parent element. </p>
<p class="Text body">The tag itself cannot be considered a name for two reasons. First, it is not required to be unique within the parent element, and secondly it is a property of the tagged element &ndash; the <span class="T5">infoset</span> model supported by XML has the tag belonging to the tagged element rather than merely the name it has in the parent. If the element were copied elsewhere, it would maintain the same tag.</p>
<p class="Text body">XML has three types of data that might be considered &ldquo;attributes&rdquo; (ignoring comments and processing instructions which are now obsolete). These are:</p>
<ul>
<li>
<p class="P32">elements &ndash; a grouping and composition notion delineated by tags, in which the order in the parent is important;</p>
</li>
<li>
<p class="P32">attributes &ndash; named values associated with an element;</p>
</li>
<li>
<p class="P32">character data - strings of text associated with an element, unnamed but ordered.</p>
</li>
</ul>
<p class="Text body">Not providing naming has one severe consequence &ndash; attributes cannot be uniquely identified within a structure. This is can be a real problem, though naming can be replaced by a somewhat heavy query mechanism returning a (possibly empty) set of elements. This is the <span class="T5">Xpath</span> standard in XML.</p>
<p class="Text body">SmartFrog, on the other hand, has but one notion &ndash; that of attributes. These are values that may be named within an attribute collection (known as a <span class="code inline">ComponentDescription</span>), which is in turn an attribute. This provides a clean model but perhaps without the richness (or complexity) of XML &ndash; however this simplicity is a great advantage when describing and explaining the notation, and the extra notions present in XML are of uncertain benefit. </p>
<p class="Text body">To represent the notion of an element tag, SmartFrog would need to encode that somehow into the attribute structure, perhaps by the inclusion of an extra attribute in a component description to indicate a tag &ndash; for example sfTag. This, plus any schemas, predicates and default attribute values associated with that tag, could be encoded as a template to be inherited and used as required.</p>
<p class="Heading 4">Inheritance</p>
<p class="Text body">Inheritance in this context is the ability to take a description of a configuration (as a collection of attributes) and extend or redefine some of these to provide a modified configuration. Its role is identical to inheritance in an object-oriented language. It is perhaps not a strictly necessary feature in a world where we have editors, cut and paste operations, and so on &ndash; but experience with OO languages is that without this capability the results are unmaintainable</p>
<p class="Text body">SmartFrog provides a model of single inheritance, where one definition may extend another. This use of single inheritance solves the issue of what happens when two attributes with the same name are inherited through two paths in the inheritance hierarchy. However, the model can easily be extended to provide multiple inheritance if a specific model of attribute precedence is provided or some name disambiguation scheme is used. The only other form of combinator provided in SmartFrog is aggregation, where an attribute set may be a named attribute within another attribute set.</p>
<p class="Text body">Unfortunately, XML does not provide any form of inheritance. It does provide a model of aggregation, where an existing document can be embedded into a new document, but it becomes a single element within that document.</p>
<p class="Heading 4">Functions and Phases vs. XSLT</p>
<p class="Text body">SmartFrog provides a small selection of functions and operators that can be used within the definition of a description, and a set of user creatable phases for manipulating the description. XML does not have this notion in quite the same way. Instead it has a transformational framework, XSLT, which allows users to provide very general transform rules over the description, sufficiently general to even encode the notion of extends. Although powerful and expressive, there are two issues with this. The first is that it can be rather hard for end users to understand the consequences of using a transform &ndash; they are typically not robust to misuse &ndash; and secondly the syntax can be rather obscure.</p>
<p class="Heading 4">Schemas, Typing and Validation</p>
<p class="Text body">SmartFrog is untyped &ndash; the attributes may be any value representable within the notation, currently various numeric types, strings and attribute sets. Under inheritance, the type may be changed to another. This has not proved to be a significant problem, however statically typed descriptions do have distinct advantages in certain areas. Finally, there is no way of specifying which attributes should, or should not, be present in a configuration description. SmartFrog takes a different approach to the problem. There is an optional way of describing predicates and attaching them as attributes to a configuration description. Being attributes, they are inherited in the same way as other attributes are inherited, and hence apply to the new description (unless explicitly overridden). The predicates may test the existence or type of any attribute, and may potentially execute arbitrarily complex tests over single or any combination of attributes taken from the collection of attributes as a whole. This provides a very powerful mechanism for defining the correctness of descriptions, without the need for a parallel schema mechanism.</p>
<p class="Text body">XML documents are basically untyped, or more specifically they only contain the single basic type &ldquo;character data&rdquo; on top of the basic notion of element. To extend this, a schema mechanism is provided which allows users to specify which attributes must be present and how the character data should be interpreted. In addition a small set of simple predicates are provided for defining such things as sub-ranges of numbers.</p>
<p class="Text body">XML schemas do provide inheritance in that one schema may be an extension of another, however this is unmatched in the document space. </p>
<p class="Heading 4">Templates</p>
<p class="Text body">There is a clear requirement to provide templates for configurations that may be parameterized. We should be able to define a configuration that defines:</p>
<ol>
<li>
<p class="P33">A set of &ldquo;parameter&rdquo; attributes which must be provided to complete a configuration; this set is itself a configuration.</p>
</li>
<li>
<p class="P33">A configuration template which, when instantiated with this set of attributes, produces a complete configuration.</p>
</li>
<li>
<p class="P33">It must be possible to constrain this set of parameter attributes in a way that guarantees a valid configuration as the result of the instantiation.</p>
</li>
</ol>
<p class="Text body">Put simply, the ability to write functions is required, producing a configuration from a configuration.</p>
<p class="Text body">XML provides no support for the notion of template. The very fixed notion of a document, without inheritance, limits the ability to even provide an approximation.</p>
<p class="Text body">SmartFrog implicitly supports templates through a combination of capabilities &ndash; inheritance and linking. A requirement for an attribute can be expressed by providing an un-resolved link to a top-level attribute that may then be instantiated via inheritance. Although in many ways a satisfactory solution, it does not provide clear expression of the requirements for instantiation, as the parameter attributes are never clearly identified. However, even in the rather limited form provided in SmartFrog, the benefits of providing a template notion is clear.</p>
</div>
<a name="N11A0F"></a><a name="Part+3%3A+The+SmartFrog+Component+Model"></a>
<h2 class="boxed">Part 3: The SmartFrog Component Model</h2>
<div class="section">
<a name="N11A14"></a><a name="Introduction-N11A14"></a>
<h3 class="boxed">Introduction</h3>
<a name="N11A19"></a><a name="Components-N11A19"></a>
<h4>Components</h4>
<p class="Text body">Having written the description of a service in a notation, and having had this processed by the appropriate language processor (done in most instances by the SmartFrog command-line tools), the simplified models are passed to SmartFrog to carry out the deployment process. This process consists of the hierarchical deployment of components as defined by the description. At this point, ignoring how the description defines which components should run where, it is worth defining the very notion of a component.</p>
<p class="Text body">A component is an instance of a Java class that implements a specific Java interface: the Prim interface. The classes for components are normally implemented by extending one of the predefined classes that already provide most of the required semantics, adding to or modifying this behaviour as appropriate. This interface is quite complex and extensive, however most of it is for SmartFrog's internal operation. Programmers really only need to use a subset of these.</p>
<p class="Text body">The most important aspect, and that which is core to the notion of a component, is that of the lifecycle and the methods associated with it. A component has a simple lifecycle to bring it into being, to start its activity, and eventually to terminate it. This lifecycle is implemented as a set of methods provided by the programmer (or through inheritance, by one of the classes provided as part of SmartFrog).</p>
<p class="Text body">As illustrated by the diagram above, the lifecycle of a component is generally thought of as the phased start-up of first component creation, then component initialization (also know as deployment) and finally component initiation: starting the active parts of the component. Termination and clean-up can happen asynchronously at any time after the initial creation, triggered internally by the component, externally by the environment, for example in response to some form of failure.</p>
<p class="Text body">In addition to considering a single component and its lifecycle, it is necessary to consider the lifecycles of collections of components. These collections might define the set of components in a specific application or service. As such, the sum of the lifecycles of these components effectively determine the lifecycle of the service itself. As an example, consider a service that manages web servers and creates or terminates web servers according to loading . Any single component has a simple start/stop lifecycle as determined by the lifecycle model given above, but the collection has a much more complex lifecycle involving the dynamic modification of the collection of web server components that are included in the service &ndash; sometimes adding and sometimes removing these web server components.</p>
<p class="Text body">Now the lifecycle of services, or more generally the service of some collection of components, are mediated by other components &ndash; known as compound components &ndash; that make use of SmartFrog's APIs to interact with the SmartFrog framework to instantiate and terminate the components for which it is responsible.</p>
<p class="Text body">Most such compound components are very specific to a service &ndash; for example the component that monitors the response-time of the web servers to decide whether to deploy or terminate a web server is a specific component to that service. However there are some generic types of collection that can also be defined and which can usefully be implemented as part of a core framework such as SmartFrog.</p>
<p class="Text body">The most important such specific collection is the Compound (as opposed to the more general concept of a compound component). The Compound component is one where every member of the collection shares fate with the others in the group. Thus they are all created or none are, they are all initialized or none are, they all start together or none start, and they all terminate or fail together.</p>
<p class="Text body">An example of where this Compound behaviour is appropriate might be where the collection consists of the component to collect service response data and the component that uses this data to decide how many web servers to be running. It would not be appropriate to tie the different web servers together in such a group so that terminating one web server would terminate them all.</p>
<p class="Text body">All of these group behaviours are mediated by components that can be defined and then made available for use by other services wherever this is appropriate. In addition to the pre-defined compound components, such as Compound, users may define their own specific to their service.</p>
<a name="N11A3C"></a><a name="Defining+Components+in+the+Language"></a>
<h4>Defining Components in the Language</h4>
<a name="N11A41"></a><a name="The+SmartFrog+Component+Model"></a>
<h3 class="boxed">The SmartFrog Component Model</h3>
<p class="Text body">This section describes how a set of attributes is interpreted by the SmartFrog framework as a collection of components distributed across a number of hosts in a network. There are several aspects to consider:</p>
<ul>
<li>
<p class="P112">how attributes indicate type of component.</p>
</li>
<li>
<p class="P112">how attributes are used to indicate the location of components.</p>
</li>
<li>
<p class="P112">how the system carries out the creation of components.</p>
</li>
<li>
<p class="P112">how components are started and stopped.</p>
</li>
<li>
<p class="P112">how components may use the framework APIs to access configuration values.</p>
</li>
<li>
<p class="P112">how components may dynamically interact with the framework to dynamically modify the sets of components that are created.</p>
</li>
</ul>
<p class="Text body">First, however, it is worth a general discussion of the concepts behind the SmartFrog application model.</p>
<a name="N11A65"></a><a name="Applications+As+Component+Collections"></a>
<h4>Applications As Component Collections</h4>
<p class="Text body">SmartFrog considers a whole system to be a collection of applications running over a distributed collection of compute resources. This collection of applications may be dynamic, generated on demand by a variety of external and internal events, such as a user request or a new resource being started.</p>
<p class="Text body">Each application is, in turn, a collection of components defined statically via an application description or generated dynamically at run-time according to the requirements determined at that time. The components of an application may be dynamic, changing over time to adjust for circumstances.</p>
<p class="Text body">These terms, namely <span class="T2">system</span>, <span class="T2">application</span> and <span class="T2">component</span>, deserve better definition to highlight their respective roles and the ways in which SmartFrog manages them. It is easier to consider them in reverse order.</p>
<p class="Heading 4">Component</p>
<p class="Text body">A component is defined as a single Java object which implements a specific API (defined in the <span class="T3">Prim</span> interface) and which consequently implements the specific lifecycle as defined by the SmartFrog component model.</p>
<p class="Text body">Since the component is implemented as a single object, it resides entirely within one JVM on a single host. The component may, behind the scenes, create and manage other objects including other processes and programs written in other languages. However, for the purpose of SmartFrog, the management view of component is entirely defined by the <span class="T3">Prim</span> object. </p>
<p class="Heading 4">Application</p>
<p class="Text body">An application consists of a collection of components, and consequently it is not an atomic object as seen by SmartFrog. This means that the lifecycle is not viewed through a single interface, complicating the handling of the lifecycle of the whole application. An application has two characteristics that characterize the notion:</p>
<ul>
<li>
<p class="P113">Each component is tightly bound to the others via a parent-child relationship, each may be a parent to others and each (unless it is the root component) has a parent. This transitive closure of the parent-child relationship is the scope of the application.</p>
</li>
<li>
<p class="P113">The lifecycle of each component in an application is tied to the lifecycle of the others via this parent-child relationship &ndash; parents are notified of child death, and vice-versa, and the parents are entirely responsible for the lifecycle of their children. The order of component start-up and termination is well defined and may be relied on for the simplification of component coding.</p>
</li>
</ul>
<p class="P114">Components of an application may locate each other, thereby enabling communication, using the built-in SmartFrog naming capabilities by following the parent-child relationships. These links between components are specified via <span class="T3">LAZY </span><span class="T1">links</span>.</p>
<p class="Heading 4">System</p>
<p class="Text body">A system is simply a collection of applications, loosely grouped over the distributed resources. Applications within a system do not have direct links between their components, nor any direct responsibility for, nor notification of, their respective lifecycle (though these may be implemented within specific component behaviour).</p>
<p class="Text body">Typically, applications locate each other through naming or discovery services, and they must be able to cope appropriately with the non-existence of applications on which they depend, both at start-up and during operation.</p>
<a name="N11AB2"></a><a name="Applications+and+Component+Descriptions"></a>
<h4>Applications and Component Descriptions</h4>
<p class="Text body">As described above, each application is a collection of components connected via a parent-child hierarchy. Thus an application is a tree structure similar to the tree structure present in a component description hierarchy, as described in section 10. Indeed, it is the role of the SmartFrog system to convert a description into the equivalent running application according to an appropriate interpretation of attributes present in the description. </p>
<p class="Text body">The process of taking a description and converting it into a running application is defined roughly as follows:</p>
<ul>
<li>
<p class="P115">A description in SmartFrog notation is parsed and resolved.</p>
</li>
<li>
<p class="P115">The specific <span class="T2">interesting</span> component description is selected, namely the <span class="T3">sfConfig</span> component description.</p>
</li>
<li>
<p class="P115">The result is a hierarchy of component descriptions (each extending <span class="code inline">NULL</span>, the empty description).</p>
</li>
<li>
<p class="P115">The role of SmartFrog is to create an equivalent hierarchy of objects, as determined by the attributes present in the component description hierarchy.</p>
</li>
</ul>
<p class="Text body">Consider the following small example:</p>
<p class="Code indented">StatusMonitor extends Prim {</p>
<p class="Code indented">sfClass "org.smartfrog.examples.StatusMonitor";</p>
<p class="Code indented">}</p>
<p class="Code indented"></p>
<p class="Code indented">LogMonitor extends Prim {</p>
<p class="Code indented">sfClass "org.smartfrog.examples.LogMonitor";</p>
<p class="Code indented">}</p>
<p class="Code indented"></p>
<p class="Code indented">sfConfig extends Compound {</p>
<p class="Code indented">log extends LogMonitor;</p>
<p class="Code indented">status extends StatusMonitor;</p>
<p class="Code indented">}</p>
<p class="Standard"></p>
<p class="Text body">
<span class="T3">Prim</span> and <span class="T3">Compound</span> are described in detail in section 2.3.4, but in effect define collections of attributes that describe leaves (<span class="T3">Prim</span>) and nodes (<span class="T3">Compound</span>) of a component hierarchy. <span class="code inline">Prim</span> is a collection that defines some basic attributes relevant to all components (such as default code base), and Compound contains at least the additional attribute:</p>
<p class="Code indented">sfClass "org.smartfrog.sfcore.compound.CompoundImpl";</p>
<p class="Text body"></p>
<p class="Text body">After all the resolution steps, and after selection of the <span class="T3">sfConfig</span> attribute, the following description is obtained:</p>
<p class="Code indented">sfConfig extends {</p>
<p class="Code indented">sfClass "org.smartfrog.sfcore.compound.CompoundImpl";</p>
<p class="Code indented">// plus Prim attributes</p>
<p class="Code indented">log extends {</p>
<p class="Code indented">sfClass "org.smartfrog.examples.LogMonitor";</p>
<p class="Code indented">// plus Prim attributes</p>
<p class="Code indented">}</p>
<p class="Code indented">status extends {</p>
<p class="Code indented"> sfClass "org.smartfrog.examples.StatusMonitor";</p>
<p class="Code indented">// plus Prim attributes</p>
<p class="Code indented">}</p>
<p class="Code indented">}</p>
<p class="Text body">This is a hierarchy of component descriptions. The SmartFrog framework takes this description and turns it into the following running application: a component parent-child hierarchy using the <span class="T23">sfClass</span> attribute to determine the class of object to instantiate.</p>
<p class="Text body"></p>
<p class="Text body">In both cases, the described and running, a <span class="T3">Context</span> (section 10) is used to store the attributes. In the described case, the values are the component descriptions of the next level in the tree, whereas in the running case the same attributes hold the RMI references to the running components represented by the equivalent component description. </p>
<p class="Text body">Consequently, the application forms a naming structure mirroring the one in the description and indeed, references may be used to traverse the structure in exactly the same way as with the descriptions. The difference is that once the application is deployed, references to components return the RMI object reference to the component rather than a copy of the attributes in the referenced description.</p>
<a name="N11B5A"></a><a name="Representing+Components+With+Attributes"></a>
<h4>Representing Components With Attributes</h4>
<p class="Text body">Applications are described using the SmartFrog notation. To create an application, its description is parsed, resolved and the <span class="code inline">sfConfig</span> attribute extracted. The <span class="T3">ComponentDescription</span> obtained is given to the framework to create and manage the components associated with that description. The means by which the SmartFrog framework does so depends on the attributes that are present within the <span class="T3">ComponentDescriptions</span>.</p>
<p class="Text body">Each description that is intended to represent a running component has two types of attributes, though these are indistinguishable within the notation. These are</p>
<ul>
<li>
<p class="P116">the template attributes that define the Java class of the component, where it should be created, and certain other management aspects; these are all identified by their &ldquo;well-known&rdquo; names. All template attributes start with the letters <span class="T3">sf</span>.</p>
</li>
<li>
<p class="P116">the component configuration attributes containing configuration information to control the component behaviour; these are all the attributes other than the template attributes, and their interpretation is component specific.</p>
</li>
</ul>
<p class="Text body">This section is concerned only with the template attributes. The template attributes may be split into several categories, the most important of which are described in the following sub-sections.</p>
<a name="N11B81"></a><a name="Defining+the+Component+Class"></a>
<h5>Defining the Component Class</h5>
<p class="Text body">Each component created by SmartFrog is an instance of a class that implements the <span class="T3">Prim</span> interface (and usually extends the class <span class="T3">PrimImpl</span>). The key attribute of any component is therefore defining the identity of that component class. This is done by providing the well-known attribute <span class="T3">sfClass</span> holding a string representing the full package and class name of the component. Thus the description:</p>
<p class="Code indented">sfConfig extends {</p>
<p class="Code indented">sfClass "org.smartfrog.example.AClass";</p>
<p class="Code indented">}</p>
<p class="Text body"></p>
<p class="Text body">defines an application with a single component, an instance of the class <span class="T3">AClass</span> in the package <span class="T3">org.smartfrog.examples</span>.</p>
<p class="Text body">The code for the component class is normally loaded from the codebase defined at the point of launching the daemon. However it is also possible to define a codebase for a specific component, or a whole sub-tree of a description, by setting the <span class="T4">sfCodeBase</span> attribute within the definition. This also affects all sub-components, which may reset the codebase to the default by setting the <span class="T4">sfCodeBase</span> attribute to the string <span class="code inline">"default":</span>
</p>
<p class="Code indented">sfConfig extends {</p>
<p class="Code indented">sfcodebase "default";</p>
<p class="Code indented">}</p>
<p class="Text body">
<span class="code inline"></span>
</p>
<p class="Text body">Note that the <span class="T4">sfCodeBase</span> defines an additional location where a class may be found &ndash; the default codebase is still searched for the definition.</p>
<a name="N11BCD"></a><a name="Controlling+Deployment"></a>
<h5>Controlling Deployment </h5>
<p class="Text body">In addition to specifying the class of the component, it is necessary to define where the component is to be created. Components are created in SmartFrog processes known as <span class="T2">daemons</span>. Daemons have a variety of flavours, however all provide the ability for the SmartFrog infrastructure to request the creation of new components. The two primary flavours are the <span class="T6">root</span> daemon that must run on each host, started manually or automatically at boot time, and named sub-daemons that may be created on demand by the SmartFrog framework.</p>
<p class="Text body">SmartFrog provides a mechanism by which daemons may be identified via a combination of host and process names, however it also provides the means by which other location identification mechanisms may be implemented; an example of this being the use of SLP. </p>
<p class="Text body">The two key attributes for identifying locations are the <span class="T3">sfProcessHost</span> and the <span class="T3">sfProcessName</span> attributes, both strings identifying the host and process respectively. If neither attribute is present, the current process is assumed; the current process being whichever is currently carrying out the deployment. If the <span class="T3">sfProcessHost</span> attribute is present, but the <span class="T3">sfProcessName</span> is not, the root daemon is assumed. Clearly any such use of the <span class="code inline">sfProcessHost</span> attribute assumes that a root SmartFrog daemon is running on the identified host, and that security settings of the remote host permit the local system to deploy to it.</p>
<p class="Text body">Thus, the following example will create the example component in the root process on the specified host.</p>
<p class="Code indented">sfConfig extends {</p>
<p class="Code indented">sfClass "org.smartfrog.example.AClass";</p>
<p class="Code indented">sfProcessHost "15.144.56.243";</p>
<p class="Code indented">}</p>
<p class="Text body">and the following will place the component into a sub-process named <span class="T3">ExampleProcess</span>, creating it if it does not already exist.</p>
<p class="Code indented">sfConfig extends {</p>
<p class="Code indented">sfClass "org.smartfrog.example.AClass";</p>
<p class="Code indented">sfProcessHost "15.144.56.243";</p>
<p class="Code indented">sfProcessName "ExampleProcess";</p>
<p class="Code indented">}</p>
<a name="N11C1C"></a><a name="RMI"></a>
<h5>RMI</h5>
<p class="Text body">SmartFrog relies on Java/RMI to provide the transport layer for carrying out management tasks, such as initiating the creation of a component. SmartFrog also makes it easy to use RMI to provide inter-component communication for application purposes. In particular, the RMI reference of a component is returned whenever a LAZY link is dereferenced to point to a component. However, it is an overhead for all components to be full-blown RMI servers; it is only necessary that the first component of any hierarchy of components in a daemon be a server, though others may be so if required.</p>
<p class="Text body">If it is unnecessary for a component to be <span class="T2">exported</span> as an RMI server, the <span class="T3">sfExport</span> attribute may be set:</p>
<p class="Code indented">sfConfig extends {</p>
<p class="P117">sfClass "org.smartfrog.example.AClass";</p>
<p class="Code indented">sfExport "false";</p>
<p class="Code indented">}</p>
<p class="Text body"></p>
<p class="Text body">It is equally possible to set it to true to ensure that the RMI export is done, although this is also the default if the attribute is not explicitly set. If the export is set to <span class="code inline">"false"</span>, only components in the same JVM will be able to access the component.</p>
<a name="N11C44"></a><a name="Prim+and+Compound"></a>
<h5>Prim and Compound</h5>
<p class="Text body">In the notation, the root of all extensions is the <span class="code inline">NULL</span> attribute set; this is normally indicated by extending nothing. However, when components are being described (as opposed to arbitrary structured data) it is conventional to use the description <span class="T3">Prim</span> as the root of all descriptions. This provides a single place where default-valued template attributes may be placed, thus guaranteeing that all components inherit them.</p>
<p class="Text body">Prim is defined in the file <span class="T3">org/smartfrog/components.sf</span>. Thus, this must effectively be included in every description, as in the following example.</p>
<p class="Code indented">#include "/org/smartfrog/components.sf"</p>
<p class="Code indented">sfConfig extends Prim {</p>
<p class="Code indented">sfClass "org.smartfrog.example.AClass";</p>
<p class="Code indented">}</p>
<p class="Text body">In addition to <span class="T3">Prim</span>, there is a standard component called <span class="T3">Compound</span> defined in the same <span class="T3">components.sf</span> file. This provides the definition of the most commonly used application-grouping component, which creates a set of components as part of an atomic collection. Thus, most applications are similar to the following example in their use of <span class="T3">Prim</span> and <span class="T3">Compound</span>:</p>
<p class="Code indented">#include "org/smartforg/components.sf"</p>
<p class="Code indented">Service extends Prim {</p>
<p class="Code indented">sfClass "org.smartfrog.example.Service";</p>
<p class="Code indented">// and other attributes</p>
<p class="Code indented">}</p>
<p class="Code indented">ServicePair extends Compound {</p>
<p class="Code indented">service1 extends Service{ &hellip; }</p>
<p class="Code indented">service2 extends Service { &hellip; }</p>
<p class="Code indented">} </p>
<p class="Code indented">sfConfig extends ServicePair {</p>
<p class="Code indented">sfProcessHost "localhost";</p>
<p class="Code indented">}</p>
<p class="Text body">The <span class="T3">Compound</span> description is unlike <span class="T3">Prim</span>, in that it contains an <span class="T3">sfClass</span> attribute defining the compound implementation class, which means that it is directly instantiable in a deployment. Otherwise, it is empty but may be used to define default template attributes for all compounds.</p>
<p class="Code indented">Compound extends Prim {</p>
<p class="Code indented">sfClass &ldquo;org.smartfrog.sfcore.compound.CompoundImpl&rdquo; ;</p>
<p class="Code indented">}</p>
<p class="Text body">Compounds are described further in section 4.</p>
<a name="N11CBD"></a><a name="Lifecycles"></a>
<h4>Lifecycles</h4>
<p class="Text body">An important aspect of the SmartFrog component model is the lifecycle. The lifecycle is implemented as a simple state machine, shown in the following diagram.</p>
<p class="Text body"></p>
<p class="Text body">The transitions in the state machine are associated with actions implemented (if required) by the components. The transition actions are implemented by the invocation of methods on the component, during which the component may take any appropriate action. These transition methods, also known as the template methods, are indicated along side the transition in the diagram.</p>
<p class="Text body">These methods are described more fully in section 3. Default minimal actions are provided if the component has no specific action to carry out during the transition.</p>
<p class="Text body">In an application with multiple components, the lifecycle of the whole system is defined by the combination of component lifecycles in some order. It is not completely defined within SmartFrog as to how these lifecycles are composed as it depends on the specific components used, and specifically those that are compound components. </p>
<p class="Text body">The root parent of the parent-child hierarchy is controlled by the framework, and it is responsible for triggering the lifecycle transitions. It is the responsibility of that component to transition each of its children. The most common component used as root, and as intermediate nodes of the hierarchy is the <span class="T3">Compound</span> and this defines a simple combined lifecycle aimed at providing the notion of a single atomic composition with a shared lifecycle:</p>
<ul>
<li>
<p class="P118">on transition to the <span class="T2">instantiated</span> state, all children are similarly instantiated;</p>
</li>
<li>
<p class="P118">on transition to the <span class="T2">initialized</span> state, all children are initialized;</p>
</li>
<li>
<p class="P118">on transition to <span class="T2">running</span>, all children are started;</p>
</li>
<li>
<p class="P118">on transition of any component to <span class="T2">terminated</span>, all children and the parent are terminated, and thereby the whole hierarchy is terminated.</p>
</li>
</ul>
<p class="Text body">This specific semantics has some important properties. The entire application is stepped through the lifecycle in a synchronous way: all components are created before any are initialized and all components are initialized before any are started. Termination is rather different as its occurrence is asynchronous with respect to the other transitions and any component in the hierarchy may be the first to transition to the terminated state (i.e. unlike the other transitions, it is not only the root which may initiate it). Nevertheless, the semantics are such that the whole application will terminate if any component terminates.</p>
<p class="Text body">There are other possible semantics for parent-child lifecycle combination other than <span class="T3">Compound</span>, and some are provided by the framework. In particular, the workflow package provides a number of combinations such as parallel composition and sequential composition. The workflow package, documented in an accompanying manual, is designed to provide a simple lightweight workflow-style capability to the SmartFrog framework. </p>
<p class="Text body">Only <span class="T3">Compound</span>, and its close relative <span class="T3">DetachingCompound</span>, will be considered within this manual, as it is the core implementation of component composition and is used by all others.</p>
<a name="N11D0D"></a><a name="The+SmartFrog+API"></a>
<h4>The SmartFrog API</h4>
<p class="Text body">The SmartFrog API is in essence the interface that each component must implement. This is the <span class="T3">Prim</span> interface (not to be confused with the <span class="T3">Prim</span> description) in the package <span class="T3">org.smartfrog.sfcore.prim</span>. All the SmartFrog capabilities are defined through the methods defined in this interface. To provide default implementations of these methods, all components should extend the class <span class="T3">PrimImpl</span> to define their default behaviour and enable access to the framework services.</p>
<p class="Text body">The API is divided into two parts:</p>
<ul>
<li>
<p class="P119">The template methods that a component may wish to redefine; these are primarily the lifecycle methods.</p>
</li>
<li>
<p class="P119">The utility methods that provide the component with the ability to access the SmartFrog framework capabilities, which includes access to the component&rsquo;s configuration attributes. Equally they provide the SmartFrog system or other components access to the same capabilities on that component.</p>
</li>
</ul>
<p class="Text body">Both of these parts are defined in the <span class="T2">Prim</span> interface and are fully documented in the accompanying <span class="T5">Javadoc</span>; a partial description of the more important aspects is given in section 3.</p>
<a name="N11D3C"></a><a name="Primitives"></a>
<h3 class="boxed">Primitives</h3>
<p class="Text body">Primitives are the core of the SmartFrog component model, they are the basis for all the components that are created to implement application behaviour. Implementing a prim component in Java is the essence of SmartFrog programming.</p>
<p class="Text body">Creating a prim class involves the following steps:</p>
<ul>
<li>
<p class="P120">Inheriting from the <span class="T3">PrimImpl</span> class and implementing the <span class="T3">Prim</span> interface (note that although <span class="T3">PrimImpl</span> itself implements <span class="T3">Prim</span>, it is necessary for RMI that the component directly declares that it implements it or another <span class="code inline">Remote </span>interface. </p>
</li>
<li>
<p class="P120">Providing an empty default constructor throwing the RMI remote exception, this constructor is used by SmartFrog to create the component instance.</p>
</li>
<li>
<p class="P120">Providing the appropriate lifecycle template methods if they are required &ndash; default methods are provided by the <span class="T3">PrimImpl</span> class should no action be required at a specific point in the lifecycle.</p>
</li>
<li>
<p class="P120">Implementing any component-specific interface required by the component.</p>
</li>
</ul>
<p class="Text body">The component-specific behaviour defined in the template methods or in the component-specific interfaces may use the utility methods.</p>
<a name="N11D73"></a><a name="Template+Methods"></a>
<h4>Template Methods</h4>
<p class="Text body">The template methods are defined to be the ones shown in the lifecycle diagram, namely:</p>
<ul>
<li>
<p class="P121">
<span class="code inline">sfDeployWith(&hellip;)</span> is the method that is used alongside the default constructor for the basic creation of a component. It should not be overridden with application specific behaviour.</p>
</li>
<li>
<p class="P121">
<span class="code inline">sfDeploy()</span> is the method that the system invokes to transition the component from the created state to the initialized state. Users may override this method to provide component specific initialization code, though care should be taken to invoke the superclass implementation to maintain correct behaviour. After this method, components should be ready to receive requests from other components in the application. Thus, listener threads must be started but threads that invoke other components may not. The component may assume that all other components in the same application have been created, but may not assume that they have been initialized. </p>
</li>
<li>
<p class="P121">
<span class="code inline">sfStart()</span> is the method that the system invokes to transition the component from the initialized state to the running state. Users may override this method to provide component specific initialization code, though care should be taken to invoke the superclass implementation to maintain correct behaviour. The method will start any required active threads. The component may assume that all other components in the application have been initialized, but may not assume that they have been started.</p>
</li>
<li>
<p class="P121">
<span class="code inline">sfTerminateWith(TerminationRecord tr)</span> is the method that may be called at any time to transition from any state to the terminated state. The termination record contains details of the reason for termination. All threads must be stopped, all resources must be released, etc. No assumptions may be made as to the state of any other component in the application. The superclass termination method must be invoked to ensure correct behaviour.</p>
</li>
</ul>
<p class="Text body">Thus, a typical SmartFrog primitive has the following shape:</p>
<p class="Code">import org.smartfrog.sfcore.prim.Prim;</p>
<p class="Code">import org.smartfrog.sfcore.prim.PrimImpl;</p>
<p class="Code">import org.smartfrog.sfcore.prim.common.SmartFrogException;</p>
<p class="Code"></p>
<p class="Code">import java.rmi.RemoteException;</p>
<p class="Code"></p>
<p class="Code">public class MyPrim extends PrimImpl implements Prim, &hellip; {</p>
<p class="Code">/* any component specific declarations */</p>
<p class="Code"></p>
<p class="Code">public MyPrim() throws RemoteException {</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">public synchronized void sfDeploy() </p>
<p class="Code">throws RemoteException, SmartFrogException {</p>
<p class="Code">super.sfDeploy();</p>
<p class="Code">/* any component specific initialization code */</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">public synchronized void sfStart() </p>
<p class="Code">throws RemoteException, SmartFrogException {</p>
<p class="Code">super.sfStart();</p>
<p class="Code">/* any component specific start-up code */</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">public synchronized void sfTerminateWith(TerminationRecored tr) { </p>
<p class="Code">/* any component specific termination code */</p>
<p class="Code">super.sfTerminateWith(tr);</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">/* any component specific methods */</p>
<p class="Code">}</p>
<p class="Text body">This template is absolutely the key to programming SmartFrog components. The three template methods may be left out if they are not required. Note the fact that all the three methods call the super-class method, and note that in <span class="code inline">sfDeploy</span> and <span class="code inline">sfStart</span> this is done before the component specific part, whilst with <span class="code inline">sfTerminateWith</span> this is done at the end. The <span class="code inline">sfTerminateMethod</span> must also be written so as not to fail if called before the component was actually started.</p>
<a name="N11E04"></a><a name="Utility+Methods"></a>
<h4>Utility Methods</h4>
<p class="Text body">The utility methods are defined in <span class="T3">PrimImpl</span> designed to provide a component programmer with the key utilities to enable interaction with the SmartFrog system. These are the ability to find and manipulate attributes, locate application components and to terminate itself and hence (under normal circumstances) the whole application. </p>
<p class="Text body">The utility methods are primarily defined in <span class="T3">Prim</span>, however other methods are defined in the <span class="T3">RemoteReferenceResolver</span> interface that <span class="T3">Prim</span> extends. A brief overview of these methods is now given, however a more complete definition is provided with the <span class="T5">Javadoc</span>. The precise signature of these methods should also be checked in the <span class="T5">Javadoc</span>,</p>
<p class="Code">Object sfResolve(Reference r)</p>
<p class="body text alternative">Locate an attribute when given a reference. This method resolves from the point in the component hierarchy that is the Prim on which it is called. References may be constructed using the class constructor (recommended) or the <span class="T2">fromString(&ldquo;&hellip;&rdquo;)</span> method defined on Reference to provide a simple, though inefficient, way of creating complex references. The class <span class="T2">Reference</span> is documented in section .</p>
<p class="P122"></p>
<p class="Code">void sfTerminate(TerminationRecord tr)</p>
<p class="body text alternative">Terminate the component and hence (under normal circumstances) the application. This will cause the termination template method to be called at some point in the future, though not necessarily immediately.</p>
<p class="body text alternative"></p>
<p class="Code">void sfDetach()</p>
<p class="body text alternative">Split the application tree into two independent components; the parent-child link becomes severed and thus the lifecycles of the parent and the child components become separated. The child component becomes a root component, i.e. one with no parent.</p>
<p class="body text alternative"></p>
<p class="Code">sfAddAttribute/sfReplaceAttribute/sfRemoveAttribute</p>
<p class="body text alternative">These are a collection of methods that allow the modification or removal of the component&rsquo;s attributes.</p>
<p class="body text alternative"></p>
<p class="Code">Prim sfParent()</p>
<p class="body text alternative">Returns the parent of the component, or null if it is a root component.</p>
<p class="body text alternative"></p>
<p class="Code">Context sfContext()</p>
<p class="body text last alternative">Each component contains the context that was originally given to the component as its description. This method returns that context.</p>
<p class="Code">Reference sfCompleteName() throws RemoteException</p>
<p class="body text last alternative">Returns the complete name of the component from the root of the application. Throws exception if unable to trace the component hierarchy starting from the root.</p>
<p class="Code">Reference sfCompleteNameSafe()</p>
<p class="body text last alternative">Returns the complete name of the component from the root of the application and does not throw any exception.</p>
<p class="Text body">These methods form the basis of the programming API for components providing interactions with the SmartFrog system. Other methods, to do with dynamically modifying the structure of the application hierarchy, such as deploying new branches of the tree, are covered in the section on Compounds, section 4. </p>
<p class="Text body"></p>
<a name="N11E6E"></a><a name="Compounds"></a>
<h3 class="boxed">Compounds</h3>
<p class="Text body">SmartFrog provides the ability to create collections of components with certain semantic guarantees. These collections &ndash; whatever their semantics &ndash; are known as compounds. SmartFrog provides a small number of these collections; others may be defined as required. The primary collection component is simply known as &ldquo;<span class="code inline">Compound</span>&rdquo; and is the root of all other collections.</p>
<p class="Text body">There are three aspects to consider with <span class="code inline">Compound</span>
</p>
<ul>
<li>
<p class="P123">The component description for compound &ndash; contained in the file "<span class="code inline">/</span><span class="T3">org/smartfrog/components.sf"</span>.</p>
</li>
<li>
<p class="P123">The interface <span class="T3">Compound.java</span>.</p>
</li>
<li>
<p class="P123">the implementation of the base class of all compounds: <span class="T3">CompoundImpl.java</span>.</p>
</li>
</ul>
<a name="N11E9C"></a><a name="Compound+Component+Descriptions"></a>
<h4>Compound Component Descriptions</h4>
<p class="Text body">The component description is an extension of the component description <span class="T3">Prim</span> and adds attributes relevant to the liveness mechanisms and, importantly, it adds the <span class="T3">sfClass</span> attribute to ensure that the compound component description generates an instance of the <span class="T3">CompoundImpl</span> class when deployed.</p>
<p class="Text body">In order to define a collection of components, the description must extend Compound and add any <span class="T3">Prims</span> or <span class="T3">Compounds</span> that are required. For example</p>
<p class="Code">#include "org/smartfrog/components.sf"</p>
<p class="Code">sfConfig extends Compound {</p>
<p class="Code">component1 extends Comopund {</p>
<p class="Code">foo extends Prim { sfClass "&hellip;"; }</p>
<p class="Code">bar extends Prim { sfClass "&hellip;"; }</p>
<p class="Code">}</p>
<p class="Code">baz extends Prim {sfClass "&hellip;"; }</p>
<p class="Code">}</p>
<p class="Text body"></p>
<p class="Text body">defines the system to be a collection containing a sub-collection and a primitive. The sub-collection <span class="T3">component1</span> contains two primitives. Note that the extension of the <span class="T3">Compound</span> does not contain an <span class="T3">sfClass</span> attribute as this is supplied by the definition of <span class="T3">Compound</span> in the include file.</p>
<a name="N11EE8"></a><a name="The+Compound+Interface"></a>
<h4>The Compound Interface</h4>
<p class="Text body">The Compound interface, in the package <span class="T3">org.smartfrog.sfcore.compound</span>, is an extension of the Prim interface, hence any compound is by definition also a primitive component. It also defines a number of additional features:</p>
<ul>
<li>
<p class="P124">Compound extends the interface <span class="T3">ChildMinder</span> that provides methods for registering and removing child components. These methods will rarely be used by SmartFrog programmers as they are automatically invoked as required by the underlying system. These methods are documented in the Javadoc for the interface.</p>
</li>
<li>
<p class="P124">Compound directly defines a number of methods to allow applications, should they desire it, to deploy additional application descriptions. Although in the normal course of events this will not be used directly by SmartFrog programmers, it is sufficiently frequently used to merit some further explanation here. There are three methods:</p>
</li>
</ul>
<p class="Code">public Prim sfDeployComponentDescription(Object name,</p>
<p class="Code">Compound parent,</p>
<p class="Code">ComponentDescription cmp, </p>
<p class="Code">Context parms)</p>
<p class="Code">throws RemoteException, SmartFrogException;</p>
<p class="Code">public Prim sfCreateNewChild(Object name,</p>
<p class="Code">ComponentDescription cmp, </p>
<p class="Code">Context parms)</p>
<p class="Code">throws RemoteException, SmartFrogException;</p>
<p class="Code">public Prim sfCreateNewApp(ComponentDescription cmp, </p>
<p class="Code">Context parms)</p>
<p class="Code">throws RemoteException, SmartFrogException;</p>
<p class="Text body"></p>
<p class="Text body">The first of these is primarily intended to be an internal method for use by the framework and should be used cautiously by programmers. The method is given a component description that has already been parsed and resolved and deploys it (i.e., creates and calls <span class="code inline">sfDeployWith(...)</span>) with the following additional aspects:</p>
<ul>
<li>
<p class="P125">A parent, an existing <span class="code inline">Compound</span> including the one implementing the called method, may be provided, or <span class="code inline">null</span> if no parent is required. If no parent is provided, a wholly new application is created.</p>
</li>
<li>
<p class="P125">The name by which this component is to be known within that parent compound &ndash; again may be null if a parent is not required</p>
</li>
<li>
<p class="P125">A set of additional attributes that should be placed into the top-level component description before deployment.</p>
</li>
</ul>
<ol>
<li>
<ol>
<li>
<ol>
<li>
<ol>
<li>
<ol></ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<ul>
<li>
<p class="P125">The name by which this component is to be known within that parent compound &ndash; again may be null if a parent is not required</p>
</li>
<li>
<p class="P125">A set of additional attributes that should be placed into the top-level component description before deployment.</p>
</li>
</ul>
<p class="Text body">The error handling during the lifecycle is defined to be to detach and terminate the new child, if necessary, and to throw an appropriate exception in the calling thread.</p>
<p class="Text body">The second of these methods, <span class="code inline">sfCreateNewApp</span>, is used to create a new application which is its own root &ndash; it has not parent. Consequently, no parent is required, and no name for it to be associated with within a parent. Consequently, in addition to the description, the only additional data required is</p>
<ul>
<li>
<p class="P125">A set of additional attributes that should be placed into the top-level component description before deployment.</p>
</li>
</ul>
<p class="Text body">The error handling during the lifecycle is defined to be to terminate the application (there is no need to detach &ndash; it is a new root), and to throw an appropriate exception in the calling thread.</p>
<a name="N11F67"></a><a name="CompoundImpl"></a>
<h4>CompoundImpl</h4>
<p class="Text body">The class <span class="code inline">CompoundImpl</span> in package <span class="code inline">org.smartfrog.sfcore.compound</span> is the implementation of the core capabilities of SmartFrog collections. In addition to being the class which is extended whenever a new type of Compound is defined, it provides all the semantics for one of the most common type of grouping &ndash; the shared-lifecycle component collection.</p>
<p class="Text body">The purpose of the <span class="code inline">CompoundImpl</span> is to provide a collection with the following semantics:</p>
<ul>
<li>
<p class="WW-List Bullet">The <span class="T3">Compound</span> provides a notion of child component &ndash; one for whose lifecycle it is responsible. A child is an attribute of the <span class="T3">Compound</span>, but also has a specific relationship relative to lifecycle management and failure monitoring.</p>
</li>
<li>
<p class="WW-List Bullet">The <span class="T3">Compound</span> and its sub-components share an identical lifecycle, i.e.</p>
</li>
<li>
<p class="P20">whenever the compound is created, so are the sub-components in order of definition</p>
</li>
<li>
<p class="P20">whenever the compound is initialized, so are the sub-components in order of definition</p>
</li>
<li>
<p class="P20">whenever the compound is started, so are the sub-components in order of definition </p>
</li>
<li>
<p class="P20">whenever the compound fails or is terminated, so are the sub-components; this may be done asynchronously or synchronously in order of definition</p>
</li>
</ul>
<ol>
<li>
<p class="P127">This phasing of the lifecycle is of extreme importance to the SmartFrog system. The phasing carries through the hierarchy of the compounds and effectively provides a top-down, depth-first traversal of the compound parent-child containment tree. Thus, each child is guaranteed that each of the other children (and indeed the entire tree) has been stepped through the previous phase of the lifecycle before it will step through the next. Thus, all components will be initialized before any are started, and so on. The only exception to this is termination, which may occur at any time and may be completely asynchronous.</p>
</li>
</ol>
<ul>
<li>
<p class="WW-List Bullet">The <span class="T3">Compound</span> monitors its children for their status using the child&rsquo;s <span class="T3">sfPing</span> template method. If there is any failure of this method (either an exception or the method returning false), the child is assumed to have died and the compound propagates this as defined by the shared lifecycle principle. Note that other semantics for failure recovery, or other semantics for lifecycles, may be implemented and many are provided within the accompanying workflow package </p>
</li>
</ul>
<a name="N11FB5"></a><a name="Component+Template"></a>
<h3 class="boxed">Component Template</h3>
<p class="Text body">The following text is the typical outline for a primtive component in SmartFrog</p>
<p class="Code">import org.smartfrog.sfcore.prim.Prim;</p>
<p class="Code">import org.smartfrog.sfcore.prim.PrimImpl;</p>
<p class="Code">import org.smartfrog.sfcore.prim.common.SmartFrogException;</p>
<p class="Code"></p>
<p class="Code">import java.rmi.RemoteException;</p>
<p class="Code"></p>
<p class="Code">public class MyPrim extends PrimImpl implements Prim {</p>
<p class="Code"></p>
<p class="Code">/* any component specific declarations */</p>
<p class="Code"></p>
<p class="Code">public MyPrim() throws RemoteException {</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">public synchronized void sfDeploy() </p>
<p class="Code">throws RemoteException, SmartFrogException {</p>
<p class="Code">super.sfDeploy();</p>
<p class="Code">/* any component specific initialization code */</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">public synchronized void sfStart() </p>
<p class="Code">throws RemoteException, SmartFrogException {</p>
<p class="Code">super.sfStart();</p>
<p class="Code">/* any component specific start-up code */</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">public synchronized void sfTerminateWith(TerminationRecored tr) { </p>
<p class="Code">/* any component specific termination code */</p>
<p class="Code">super.sfTerminateWith(tr);</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">/* any component-specific helper or public methods go below here */</p>
<p class="Code"></p>
<p class="Code last line">}</p>
<p class="Text body">The template to write a basic modified compound is similar, but using <span class="T3">Compound</span> and <span class="T3">CompoundImpl</span> in place of <span class="T3">Prim</span> and <span class="T3">PrimImpl</span>.</p>
<a name="N1202A"></a><a name="Well-Known+Attributes"></a>
<h3 class="boxed">Well-Known Attributes</h3>
<p class="Text body">SmartFrog defines a number of predefined component templates, such as the ones for <span class="code inline">ProcessCompound</span>, which require specific attributes to be defined. These attributes are captured in the interface: </p>
<p class="Code last line">org.smartfrog.sfcore.common.SmartFrogCoreKeys</p>
<p class="Text body">The special attributes used in the framework are:</p>
<ul>
<li>
<p class="P47">
<span class="code inline">sfProcessHost</span>: Attribute used to determine the host to use to locate the root process compound on that host.</p>
</li>
</ul>
<ul>
<li>
<p class="P48">
<span class="code inline">sfProcess</span>: Attribute used to determine the process/subprocess name where a component runs.</p>
</li>
</ul>
<ul>
<li>
<p class="P49">
<span class="code inline">sfProcessName</span>: Attribute used to name a process/subprocess</p>
</li>
</ul>
<ul>
<li>
<p class="P50">
<span class="code inline">sfProcessComponentName</span>: Attribute used to name a component</p>
</li>
</ul>
<ul>
<li>
<p class="P51">
<span class="code inline">sfRootLocatorPort</span>: Registry port used by the <span class="code inline">rootProcess</span> daemon</p>
</li>
</ul>
<ul>
<li>
<p class="P52">
<span class="code inline">sfSubprocessGCTimeout</span>: Attribute with garbage collection time out for subprocesses</p>
</li>
</ul>
<ul>
<li>
<p class="P53">
<span class="code inline">sfHost</span>: attribute used to determine the host address where a component runs</p>
</li>
</ul>
<ul>
<li>
<p class="P54">
<span class="code inline">sfProcessAllow</span>: Attribute used to define if subprocesses can be used</p>
</li>
</ul>
<ul>
<li>
<p class="P55">
<span class="code inline">sfProcessTimeout</span>: Attribute with subprocess deployment timeout</p>
</li>
</ul>
<ul>
<li>
<p class="P56">
<span class="code inline">sfProcessJava</span>: Attribute that holds the process java start command</p>
</li>
</ul>
<ul>
<li>
<p class="P57">
<span class="code inline">sfProcessClass</span>: Attribute that holds the class name for subprocesses</p>
</li>
</ul>
<ul>
<li>
<p class="P58">
<span class="code inline">sfDeployerClass</span>: Attribute that holds the class name for deployer</p>
</li>
</ul>
<ul>
<li>
<p class="P59">
<span class="code inline">sfSyncTerminate</span>: Attribute that determines asynchronous or synchronous termination of compound</p>
</li>
</ul>
<ul>
<li>
<p class="P60">
<span class="code inline">sfClass</span>: Attribute that holds the class that implements a component</p>
</li>
</ul>
<ul>
<li>
<p class="P61">
<span class="code inline">sfConfig</span>: Attribute that determines the resolution root of a SmartFrog description</p>
</li>
</ul>
<ul>
<li>
<p class="P62">
<span class="code inline">sfSchemaDescription</span>: Attribute that determines the definition of a schema</p>
</li>
</ul>
<ul>
<li>
<p class="P63">
<span class="code inline">sfCodeBase</span>: Attribute that defines the codebase for a component</p>
</li>
</ul>
<ul>
<li>
<p class="P64">
<span class="code inline">sfLivenessDelay</span>: Attribute that defines how often to send liveness in seconds.</p>
</li>
</ul>
<ul>
<li>
<p class="P65">
<span class="code inline">sfLivenessFactor</span>: Attribute that defines how many multiples of the liveness delay to wait till a liveness failure of the parent is declared</p>
</li>
</ul>
<ul>
<li>
<p class="P66">
<span class="code inline">sfExport</span>: Attribute that defines if a component has to accept remote method calls</p>
</li>
</ul>
<ul>
<li>
<p class="P67">
<span class="code inline">sfRootLocatorClass</span>: Attribute that defines the root locator class</p>
</li>
</ul>
<ul>
<li>
<p class="P68">
<span class="code inline">sfBootDate</span>: Attribute that hold the boot time of the root process daemon</p>
</li>
</ul>
<p class="Text body"></p>
<p class="Text body">Some special names used in the framework:</p>
<ul>
<li>
<p class="P69">
<span class="code inline">rootProcess</span>: Name used to name root process</p>
</li>
<li>
<p class="P69">
<span class="code inline">ROOT</span>: Name used to refer to the root reference in a particular hierarchy of components or description</p>
</li>
</ul>
<ul>
<li>
<p class="P44">
<span class="code inline">sfRunProcess</span>: Name used to name a root process deployed without registry</p>
</li>
</ul>
<ul>
<li>
<p class="P45">
<span class="code inline">unnamed_</span>: Prefix use to name unnamed deployments</p>
</li>
</ul>
<ul>
<li>
<p class="P46">
<span class="code inline">sfDeployFailure</span>: Name used to name a deploy phase failure</p>
</li>
</ul>
<ul>
<li>
<p class="P128">
<span class="code inline">sfStartFailure</span>: Name used to name a start phase failure</p>
<p class="P128"></p>
</li>
</ul>
</div>
<a name="N12126"></a><a name="Part+4%3A+The+SmartFrog+Runtime"></a>
<h2 class="boxed">Part 4: The SmartFrog Runtime</h2>
<div class="section">
<a name="N1212B"></a><a name="Deployment+In+Detail"></a>
<h3 class="boxed">Deployment In Detail</h3>
<p class="Text body">In SmartFrog, the term deployment is used to indicate the creation of the components in response to the system being given a suitable parsed and resolved description. A parsed component description may be deployed in two primary ways:</p>
<ul>
<li>
<p class="WW-List Bullet 2">by invoking the <span class="T3">sfDeployComponentDescription</span> method on a compound, and passing the parsed component to it &ndash; this would on the whole be restricted to those cases when the compound is to be the parent, or when it is simply desired to have the initial deployment occur near the compound (i.e. in the same JVM).</p>
</li>
<li>
<p class="WW-List Bullet 2">by invoking the same method on the <span class="T3">ProcessCompound</span> of the SmartFrog JVM in which the top-level component should be created, though any use of deployment control attributes, such as <span class="T3">sfProcessHost</span>, may still cause the component to be deployed elsewhere.</p>
</li>
</ul>
<p class="Text body">The SmartFrog system uses the second of these two mechanisms for deploying the descriptions that are given to it on the command-line.</p>
<p class="Text body">In either case, the deployment semantics are identical and proceeds as follows:</p>
<ul>
<li>
<p class="WW-List Bullet 2">The compound passes the top description to the deployer.</p>
</li>
<li>
<p class="WW-List Bullet 2">The deployer, if it is the right one, examines the description for the attribute <span class="T3">sfClass</span>, extracts the class-name and creates an instance of the component class using the default constructor. If it is not the correct deployer, it locates and passes on the request &ndash; see section 1.1 for a description of how this is done.</p>
</li>
<li>
<p class="WW-List Bullet 2">The instance is initialized using the <span class="T3">sfDeployWith</span> method, being passed its component description as a parameter.</p>
</li>
</ul>
<ul>
<li>
<p class="P20">If the component is a prim, it carries out some basic initialization and returns.</p>
</li>
<li>
<p class="P20">If the component is a compound, it examines the attributes of the description and extracts those that are non-lazy component descriptions. It passes these descriptions to the deployer to create an instance of its subcomponents.</p>
</li>
</ul>
<ul>
<li>
<p class="WW-List Bullet 2">The object reference (possibly remote) is returned as the result of the <span class="T3">sfDeployComponentDescription</span> method call. The receiving object is then responsible for invoking the remaining lifecycle methods in the correct order.</p>
</li>
</ul>
<p class="Text body">A number of facts should be noted. Firstly, that any component tagged <span class="code inline">LAZY</span> is not deployed by its parent compound &ndash; this leaves the description to be used as structured data or for later programmatic deployment. Secondly, the semantics of what is considered a component in a description is not defined by the framework; rather it is defined by the compound component. This alternation of responsibility between the deployer to create a single instance of a component and the component to decide the next steps is an important feature of the deployment mechanisms within the SmartFrog framework. The last fact is that the follow-up initialize/start lifecycle is entirely up to the components that control the deployment &ndash; they are responsible for invoking these methods. It is true that the framework will invoke a specific lifecycle on the initial descriptions that are passed on the command-line &ndash; however, any other component that initiates a deployment may chose to impose a different lifecycle if so desired.</p>
<a name="N1217C"></a><a name="Selecting+Deployers"></a>
<h4>Selecting Deployers</h4>
<p class="Text body">A deployer is a Java object that is capable of creating an instance of a component in a specific place, as described by attributes in the component description. SmartFrog comes with three deployers, each providing a little more capability than the previous. Some of the services supplied with SmartFrog may add additional deployers. There are two aspects to cover</p>
<ul>
<li>
<p class="WW-List Bullet 2">how a deployer is chosen</p>
</li>
<li>
<p class="WW-List Bullet 2">how each deployer interprets the attributes to select a location for deployment. </p>
</li>
</ul>
<p class="Text body">The first of these is either the class defined by the <span class="T3">sfDeployerClass</span><span class="T24"> </span>attribute of the component description to be deployed or the default deployer if this is not provided. The default is an instance of the <span class="T3">PrimProcessDeployerImpl</span> class. Thus in the example</p>
<p class="Code">sfConfig extends Compound {</p>
<p class="Code">sfDeployerClass "org.smartfrog.example.NewDeployer";</p>
<p class="Code">&hellip;</p>
<p class="Code">}</p>
<p class="Text body"></p>
<p class="Text body">The component will be deployed with the <span class="T3">NewDeployer</span> class. If this attribute had not been present, the default would be used. Each component in a hierarchy may be deployed with a different deployer.</p>
<p class="Text body">The three deployers provided by the core SmartFrog system are as follows:</p>
<ul>
<li>
<p class="WW-List Bullet 2">
<span class="code inline">PrimDeployerImpl</span> &ndash; deploys the component in the current JVM, ignoring any other attributes</p>
</li>
<li>
<p class="WW-List Bullet 2">
<span class="code inline">PrimHostDeployerImpl</span> - deploys the component in the root process compound of the host whose name is provided in by the <span class="T3">sfProcessHost</span> attribute. If no name is provided, the current JVM is used.</p>
</li>
<li>
<p class="WW-List Bullet 2">
<span class="code inline">PrimProcessDeployerImpl</span> &ndash; deploys the component in the named process (or the root process if not provided) of the specified host. If neither is provided, the deployer uses the current JVM. The process name is defined using the <span class="T3">sfProcessName</span> attribute, the host using the <span class="T3">sfProcessHost</span> attribute. This is the default deployer.</p>
</li>
</ul>
<p class="Text body">Thus, the following description will be deployed on the appropriate host and process, given that the default deployer will be selected.</p>
<p class="Code">sfConfig extends Compound {</p>
<p class="Code">sfProcessHost &ldquo;sfhost.smartfrog.org&rdquo;;</p>
<p class="Code">sfProcessName &ldquo;example&rdquo;;</p>
<p class="Code">&hellip;</p>
<p class="Code">}</p>
<p class="Text body"></p>
<p class="Text body">A description of processes, root processes and named sub-processes, is given in section 6.</p>
<a name="N121EC"></a><a name="Termination"></a>
<h4>Termination </h4>
<p class="Text body">Termination may be initiated on a component in one of three ways:</p>
<ul>
<li>
<p class="WW-List Bullet 2">By a call of the API method <span class="T3">sfTerminate(&hellip;)</span> by a thread started by the component, or from an external source such as a management system.</p>
</li>
<li>
<p class="WW-List Bullet 2">From the parent of the component.</p>
</li>
<li>
<p class="WW-List Bullet 2">From a child of the component, indicating that the child has terminated &ndash; although depending on the semantics of the compound, this may trigger an action other than the propagation of termination. The standard <span class="code inline">CompoundImpl</span>, though, will propagate this termination to itself, the other children and its parent.</p>
</li>
</ul>
<p class="Text body">Whereas for most of the component lifecycle stages, the compounds and primitives are stepped synchronously through the cycle &ndash; each is created before any are initialized, and each is initialized before any is started &ndash; this is not necessarily a good model for termination. In many cases, termination may be carried out asynchronously. Indeed, in the case of failure of a component or the network, this is an absolute necessity. In other cases, it may be desirable to terminate in a specified order whenever possible.</p>
<p class="Text body">SmartFrog allows a degree of control over the termination process. The default model is to terminate asynchronously, notifying parent component and child components in arbitrary order, and calling the termination template method on the component &ndash; the <span class="T3">sfTerminateWith(&hellip;)</span> method &ndash; at some point in that process.</p>
<p class="Text body">If a component must be terminated synchronously, the attribute <span class="T3">sfSyncTerminate</span> must be set to the boolean value <span class="T3">true</span>. If not set, or set to <span class="T2">false</span>, the component will terminate asynchronously. </p>
<a name="N12222"></a><a name="Synchronous+Termination"></a>
<h5>Synchronous Termination </h5>
<p class="Text body">Synchronous termination causes a component to carry out the following steps in order:</p>
<ul>
<li>
<p class="WW-List Bullet 2">Inform the children to terminate, waiting for each to be complete until the next is invoked. This is done in the order of definition in the component description.</p>
</li>
<li>
<p class="WW-List Bullet 2">Terminate self by calling the <span class="T3">sfTerminateWith</span> template method.</p>
</li>
<li>
<p class="WW-List Bullet 2">Notify parent that termination has occurred, if not initially told by the parent to terminate.</p>
</li>
</ul>
<p class="Text body">Note that a child component need not terminate itself synchronously, this is set by the attributes within the child. If it is desired that all components terminate synchronously, the definition of <span class="T3">Prim</span> should be modified in the file <span class="T3">components.sf</span> to include the appropriate attribute.</p>
<a name="N12246"></a><a name="Asynchronous+Termination"></a>
<h5>Asynchronous Termination</h5>
<p class="Text body">This is the default mode of termination. The same three steps are undertaken, though the children are all informed of the need to terminate in separate threads that are created for this purpose. The implications of this are that there may be some delay in the termination process, that resources may not be freed immediately. However, it also means that long termination sequences are scheduled independently of notifying its termination to its parent. This fast notification may be important for fault tolerance purposes, for example.</p>
<a name="N1224E"></a><a name="Terminator+Thread"></a>
<h5>Terminator Thread</h5>
<p class="Text body">As mentioned in section 9.2.2, asynchronous termination is done using a separate thread. Terminator thread provides a standard way of asynchronously terminating <span class="code inline">SmartFrog</span> components. This class is defined in <span class="code inline">org.smartfrog.sfcore.common</span> package. For example:</p>
<p class="Code">// create an instance of terminator thread by passing component reference and termination record</p>
<p class="Code">TerminatorThread terminator = new TerminatorThread(compRef, terminationRec);</p>
<p class="Code">// Start the thread</p>
<p class="Code">terminator.start();</p>
<p class="Code"></p>
<p class="Code">// Terminator thread object can also be constucted using another constuctor</p>
<p class="Code">public TerminatorThread(Prim target, Throwable t, Reference compId);</p>
<p class="Text body"></p>
<p class="Text body">Some utility methods are available in the <span class="code inline">TerminatorThread</span> class:</p>
<p class="Code">// returns a TerminatorThread object which does not notify</p>
<p class="Code">// components parent while terminating the component </p>
<p class="Code">public TerminatorThread quietly();</p>
<p class="Code"></p>
<p class="Code">// returns a TerminatorThread object which </p>
<p class="Code">// detaches the component from parent before terminating</p>
<p class="Code">// the component</p>
<p class="Code">public TerminatorThread detach();</p>
<p class="Code"></p>
<p class="Code">// returns a TerminatorThread object which</p>
<p class="Code">// does not terminate the underlying component</p>
<p class="Code">public TerminatorThread dontTerminate();</p>
<a name="N1229D"></a><a name="Attributes%2C+LAZY+Links+and+RMI+Object+References"></a>
<h3 class="boxed">Attributes, LAZY Links and RMI Object References</h3>
<a name="N122A2"></a><a name="Accessing+Attributes+At+Runtime"></a>
<h4>Accessing Attributes At Runtime </h4>
<p class="Text body">Attributes of a component are stored in a <span class="T3">Context</span>, as defined by the <span class="T3">ComponentDescription</span> used to create the component. These attributes may be accessed using the <span class="T3">sfResolve</span> method of the <span class="T3">Prim</span> interface. This method takes a reference and, relative to the component on which it the method is initially invoked, de-references it to obtain the desired attribute. This method may equally be used by any component, one that has an RMI reference to the object or by the component itself. If called within the body of component, the reference is de-referenced starting with the component itself.</p>
<p class="Text body">The <span class="T3">sfResolve</span> method is defined as follows.</p>
<p class="Code">Object sfResolve(Reference r)</p>
<p class="body text last alternative">Locate an attribute when given a reference. This method resolves from the point in the component hierarchy that is the Prim on which it is called. References may be constructed using the class constructor (recommended) or the <span class="T2">fromString("&hellip;")</span> method defined on Reference to provide a simple, though inefficient, way of creating complex references. </p>
<p class="Text body">This method will return an <span class="T2">Object</span> that may be inspected using reflection or caste to an appropriate class. For most attributes it is clear from the context what the value returned should be. </p>
<p class="Text body">Although the above method is the primary one for accessing attributes, there are a number of other methods with a number of semantics &ndash; they are all documented in the Javadoc.</p>
<a name="N122D5"></a><a name="LAZY+links+And+RMI"></a>
<h4>LAZY links And RMI </h4>
<p class="Text body">If the description contained a LAZY link, the link resolution phase would not have resolved it in advance &ndash; rather it would have left the reference to be the value of the attribute. There are now two possibilities when <span class="T3">sfResolve</span> is invoked:</p>
<ul>
<li>
<p class="WW-List Bullet 2">That the reference is de-referenced at this point, returning the appropriate value.</p>
</li>
<li>
<p class="WW-List Bullet 2">That the reference itself is returned as the attribute value.</p>
</li>
</ul>
<p class="Text body">The first of these semantics is that implemented by <span class="T3">sfResolve</span><span class="T2"> </span>(though not by all methods in the <span class="code inline">Prim</span> interface). Consequently, if an attribute is a <span class="code inline">LAZY</span> link, it is silently de-referenced at the time it is accessed, following the parent-child component hierarchy in exactly the same way as is done with <span class="code inline">ComponentDescription</span> declarations during link resolution.</p>
<p class="Text body">Note that the value returned by the resolution is not cached locally. It will be fetched each time the attribute is accessed. The value should be cached by the component itself if this is required.</p>
<p class="Text body">There are several reasons why a <span class="code inline">LAZY</span> link might be used instead of a normal link, in spite of the fact that delaying access in this way is much less efficient &ndash; particularly so when the attribute referenced may be remote. These reasons are all related to the property that the value of the attribute is not available at time of link resolution.</p>
<ul>
<li>
<p class="WW-List Bullet 2">The attribute referenced may be set at run-time by the component, or may continually change its value and must be read many times. This variability is the reason for not automatically caching values locally.</p>
</li>
<li>
<p class="WW-List Bullet 2">The link may reference a component with the intention of obtaining the RMI object reference of the component</p>
</li>
</ul>
<p class="Text body">Consider the following example:</p>
<p class="Code">sfConfig extends {</p>
<p class="Code">comp1 extends Prim { &hellip; }</p>
<p class="Code">comp2 extends Prim { &hellip;</p>
<p class="Code">otherComp LAZY comp1;</p>
<p class="Code">}</p>
<p class="Code">}</p>
<p class="Text body"></p>
<p class="Text body">The link to <span class="T3">comp1</span> from within <span class="T3">comp2</span> is defined as <span class="code inline">LAZY</span>. This is because the link, if it de-referenced at the time of link resolution, results in a copy of the <span class="T3">ComponentDescription</span> that is <span class="T3">comp1</span> being placed within that of <span class="T3">comp2</span> under the name <span class="T3">otherComp</span>. Thus, if it were not <span class="code inline">LAZY</span>, after resolution the result would be the resolved equivalent of</p>
<p class="Code">sfConfig extends {</p>
<p class="Code">comp1 extends Prim { &hellip; }</p>
<p class="Code">comp2 extends Prim { &hellip;</p>
<p class="Code">otherComp extends Prim { &hellip; };</p>
<p class="Code">}</p>
<p class="Code">}</p>
<p class="Text body">which is not the intended behaviour. If the link is made lazy, on the other hand, the resolution is carried out at run-time by the <span class="code inline">Compound</span>/<span class="code inline">Prim</span> hierarchy and instead of the <span class="code inline">ComponentDescription</span> being copied, the RMI object reference of the component referenced is returned. Under these circumstances, <span class="T3">comp2</span> would be able to call the exported methods of <span class="T3">comp1</span>.</p>
<a name="N12376"></a><a name="The+Moving+ROOT"></a>
<h4>The Moving ROOT</h4>
<p class="Text body">The root reference part appears simple, but it can have some unexpected side effects. The meaning of the <span class="code inline">ROOT</span> reference part is that, at the time of resolution, the <span class="T3">ComponentDescription</span> or <span class="T3">Compound</span><span class="T2">/</span><span class="T3">Prim</span><span class="T2"> </span>hierarchy is traversed upwards from the point of initial resolution until there is no parent. This top <span class="T3">ComponentDescription</span> or <span class="T3">Component</span> is the root.</p>
<p class="Text body">Therefore, when a link is defined using the ROOT reference part, the ROOT refers to the file itself, the virtual <span class="code inline">ComponentDescription</span> containing all the attributes at the top level.</p>
<p class="Text body">At run-time, however, this <span class="code inline">ComponentDescription</span> no longer exists &ndash; the component called <span class="T3">sfConfig</span> from that file is normally the new run-time root. Consequently, <span class="code inline">LAZY</span> links with <span class="code inline">ROOT</span> resolve differently from the way they would have done if they had not been lazy and had been resolved at the time of link resolution.</p>
<p class="Text body">The situation is even more confused, though, since the structure of the tree can change during the life of an application. For example, the use of <span class="T4">sfDetach</span><span class="T5"> </span>changes the structure of the tree during its execution. This difficulty in pinning the meaning of <span class="code inline">ROOT</span> can cause great confusion and therefore the use of <span class="code inline">ROOT</span> should be limited to occasions where the semantics are clear.</p>
<a name="N123C7"></a><a name="Modifying+Attributes+Values"></a>
<h4>Modifying Attributes Values</h4>
<p class="Text body">Given the use of <span class="code inline">LAZY</span> links, with the ability to read attribute values many times, they may be used as a way of passing information between components. To provide the ability to add, remove and replace attribute values from the context, three methods are provided as part of the <span class="T3">Prim</span> interface. Note that these descriptions of these methods do not accurately define the signature. These should be found from the Javadoc.</p>
<p class="Code">public Object sfAddAttribute(Object name, Object value)</p>
<p class="body text last alternative">Add an attribute to the component's context. Values should be marshallable types if they are to be referenced remotely at run-time. If an attribute with this name already exists it is not replaced.</p>
<p class="Code">public Object sfRemoveAttribute(Object name)</p>
<p class="body text last alternative">Remove named attribute from component context. Non present attribute names are ignored.</p>
<p class="Code">public Object sfReplaceAttribute(Object name, Object value)</p>
<p class="body text last alternative">Replace named attribute in component context. If attribute is not present it is added to the context.</p>
<a name="N123E9"></a><a name="Trapping+Accesses+And+Reference+Adaptors"></a>
<h4>Trapping Accesses And Reference Adaptors</h4>
<p class="Text body">Attributes of a component are stored in a <span class="T3">Context</span>, as defined by the <span class="T3">ComponentDescription</span>, and made available through the <span class="T3">Prim</span> interface using the <span class="T3">sfResolve</span> method. However, it can be useful for a component to provide an attribute that is not stored within its context but is evaluated on demand, for example an attribute representing the current load on the component.</p>
<p class="Text body">For this, the request for an attribute value must be trapped, diverted from the lookup in the context, and the correct value returned. This is possible by understanding how a reference is de-referenced.</p>
<p class="Text body">The <span class="T3">sfResolve</span> method is almost immediately converted into a request to resolve the reference from a specific index of the reference parts using the method</p>
<p class="Code">Object sfResolve(Reference r, int index)</p>
<p class="body text alternative">This method resolves one part to get to another ComponentDescription, and forwards the request adding one to the index. In this way the reference is eventually fully de-referenced and the attribute value returned.</p>
<p class="body text alternative"></p>
<p class="Text body">This method is implemented by <span class="T3">PrimImpl</span>, and its default implementation is to look up in the context and forward if the reference is not yet completely de-referenced.</p>
<p class="Text body">The accepted way of trapping a request is to override the default implementation in the appropriate component class, checking to see if the attribute is one that needs special handling and if not, invoking the super-class method to continue as normal. If it has to be handled specially, carry out the appropriate processing and return the evaluated attribute value.</p>
<p class="Text body">This mechanism has some interesting possibilities. For example, it is possible to intercept a reference early on in its de-referencing process, within a component that may then use the rest of the reference parts to be a parameter to the component to evaluate its attribute value. This may be used, for example, to provide an adaptor into other naming and discovery technologies. </p>
<p class="Text body">Consider a component that uses a database to extract a value for an attribute given a table name, a key and the column name required. Assume further that this component has been deployed on a specific host, say <span class="T3">db.smartfrog.org</span>, with the <span class="T3">sfProcessComponentName</span> set to <span class="T3">dbAccess</span>. Descriptions may now use references of the form</p>
<p class="Code">foo LAZY HOST db.smartfrog.org:dbAccess:ttt:kkk:ccc</p>
<p class="Text body">where <span class="T2">ttt, kkk, ccc</span> are the table name, key and column respectively. This is again an example of how a component which is accessing the attribute <span class="T2">foo</span> need know little of how the attribute&rsquo;s value is obtained. This is an issue for the configuration not for the component code.</p>
<a name="N1243D"></a><a name="sfHost+and+sfProcess+Attributes"></a>
<h4>sfHost and sfProcess Attributes</h4>
<p class="Text body">Every component, when created, adds two attributes to its collection of attributes. These are the hostname and process name in which the component is running. These are defined in the very earliest phase of the lifecycle, during construction. Consequently they are present during all other phases.</p>
<a name="N12445"></a><a name="Attribute+Serialization"></a>
<h3 class="boxed">Attribute Serialization</h3>
<p class="Text body">At run time, when components are scattered across a number of hosts, components exchange the values of attributes through the use of link resolution. As these values are passed around, they traverse a number of hosts. For example, consider the diagram below:</p>
<p class="Text body"></p>
<p class="Text body">In this diagram, component A requests the attribute &ldquo;foo&rdquo; from component B whenever the attribute &ldquo;bar&rdquo; is accessed. This is passed back in response to the request to resolve the bar attribute. The attribute has to be of a class that is known to both hosts containing the components A and B, otherwise some form of exception will occur. However, what is not so obvious is that the attribute value is also passed through the compound component containing A and B.</p>
<p class="Text body">It should be noted that although in the language a very limited number of classes can be used for attribute values, and these are known everywhere, at run-time attributes can have other values than these simple ones, indeed any serializable class, and in particular this will include all the RMI stub classes for the various components. </p>
<p class="Text body">Early versions of SmartFrog simply insisted that the classes of attributes that were passed through intermediate nodes in response to a resolution request had to be known to those intermediate nodes. This was not an adequate solution, so an alternative model had to be found.</p>
<p class="Text body">An attempt at solving this automatically wrapped all attribute values within a well-known wrapper class (SFMarshalledObject) for passing around. This wrapper held the actual value as a byte array containing the serialized value. In this way only the wrapper class needed to be known at every host and the serialization and deserialization simply occurred transparently at each end of a link resolution (in this case at the hosts containing A and B). At the intermediate node, only the wrapper would be handled and the real attribute value would be held as bytes within it.</p>
<p class="Text body">This solved many of the problems associated with the need for attribute classes to be known everywhere, but it introduced others. Consider if two components are always together on the same host. They locate each other using a link in the normal way, and use local interfaces to communicate (this is often done for security reasons, not to expose to remote calls sensitive interfaces). As the objects are serialized and deserialized within any link resolution, the result is always a remote object reference even though the object is local. This cannot be caste to a local-only interface, so it became impossible to ever call a local interface on a component located through link resolution. As it is impossible to extract the real object from an RMI Object Reference, so there is no easy way out of this problem.</p>
<p class="Text body">The final solution, and that in the current version, is for the wrapper to be a little more intelligent about the serialization of the value it wraps. It only does so if it is being serialized itself &ndash; so if the wrapper is never passed between hosts, the value it wraps is not serialized either.</p>
<p class="Text body">This fixes most of the problems associated with local interfaces, as well as solving the issue of classes having to be known everywhere. However it is not perfect. If a value is ever passed remotely, even if it ends up on the original host, it will have become serialized. A classic example of this is shown in the following diagram. </p>
<p class="Text body">Although A and B are on the same host, the compound is not and the attribute referenced will therefore pass through the remote host. So if A and B need to communicate using local interfaces, this is not a suitable description. An additional container compound will need to be added on the same host as A and B to act as the local container and so ensure that the link resolution never traverses a host boundary. This is also more efficient for deployment and for liveness, so is anyway to be encouraged.</p>
<p class="Text body">Note that in the discussion above, for host one should really read process. Crossing process boundaries, even on the same host, introduces the same problems.</p>
<a name="N1246A"></a><a name="Liveness"></a>
<h3 class="boxed">Liveness</h3>
<p class="Text body">A feature of SmartFrog is its all-or-nothing semantics for Compounds, its shared lifecycle for all components. This must be done in a context where any host within the network or, indeed, the network itself, may fail at any time. These failures may result in applications losing some components, or perhaps being partitioned into two or more parts if the network itself fails.</p>
<p class="Text body">The guarantees that SmartFrog attempts to provide, such as all-or-nothing deployment, cannot be achieved by purely passive means. The system needs to monitor the various components to ensure that they are still active, can be accessed and are in good shape. Detection of the failure of an application component, or of the network between such components, must be notified to the application in an appropriate way. Note that the difference between failure of a node and the failure of the network between nodes cannot normally be diagnosed from the perspective of another node.</p>
<p class="Text body">The hierarchical nature of an application provides a natural chain of responsibility &ndash; a parent is responsible for the checking and monitoring of its children, and vice-versa. Notification of failures will be made to these components and it is the responsibility of these components to take appropriate action.</p>
<p class="Text body">SmartFrog provides a default liveness checking mechanism based on a parent regularly heart-beating its children. Each component provides a method <span class="T3">sfPing</span><span class="T2"> </span>as part of the <span class="T2">Prim</span> interface. This method either returns or throws an exception, and it may be overwritten by the component implementer to carry out any appropriate checks.</p>
<p class="Text body">There are two possibilities when this method is called:</p>
<ul>
<li>
<p class="WW-List Bullet 2">The method succeeds, and returns normally &ndash; this is considered as confirmation that the component is alive.</p>
</li>
<li>
<p class="WW-List Bullet 2">The method fails by throwing an exception, implying one of the following:</p>
</li>
</ul>
<ul>
<li>
<p class="P20">that the remote host has failed.</p>
</li>
<li>
<p class="P20">that the network has failed and the two components are out of communication.</p>
</li>
<li>
<p class="P20">that the component is indicating that an error has occurred and it should be considered as dead.</p>
</li>
</ul>
<ol>
<li>
<p class="P129">The default <span class="T3">Compound</span> semantics is to terminate itself under any of these circumstances and hence the whole application follows suit &ndash; again alternative semantics may be defined.</p>
</li>
</ol>
<p class="Text body">On the child side, it monitors how frequently the parent is checking its state. If the parent misses more than a specified number of heart-beats, the child assumes that the parent has failed, or there is a network failure, and handles the failure &ndash; again the default is to terminate itself (and hence any part of the application below it in the hierarchy).</p>
<p class="Text body">Should the parent or network recover, the child will respond with an exception to any request for status, and the parent and hence the rest of the application will terminate by default.</p>
<p class="Text body">If the default behaviour needs to be changed, the report to the component is done via a call to the method <span class="T3">sfLivenessFailure</span>. This method, in the default implementation provided by <span class="code inline">PrimImpl</span>, simply terminates. This method may be over-ridden if required.</p>
<p class="Text body">To try to be a little more efficient, the SmartFrog system does not create a liveness thread for each component. Rather, it creates one for every component that is in a different process. This thread is responsible for checking all the components in the hierarchy downwards until it has checked a single level of remote components. Equally, it is only the &ldquo;first&rdquo; component that monitors whether it is being checked on a regular basis. Consequently, overheads for large numbers of components on one host are minimal. The following diagram makes this clear.</p>
<p class="P130"></p>
<p class="Text body">The frequency of liveness checking can be modified to balance responsiveness requirements and overheads in any particular system. Two attributes may be set:</p>
<ul>
<li>
<p class="P131">
<span class="code inline">sfLivenessDelay</span>: (default 15 seconds) how frequently in seconds should the liveness be checked. Zero indicates no checking.</p>
</li>
<li>
<p class="P131">
<span class="code inline">sfLivenessFactor</span>: (default 2 misses) how many missed heart-beats should be considered a parent failure.</p>
</li>
</ul>
<p class="Text body">These may be modified for the entire system by setting them in prim.sf, or for all components rooted in a process by setting the attribute definitions in the process compound for that process, or it can be set for the sub-tree of a component by setting it in that component.</p>
<p class="Text body">Each component searches for the current value of these attributes up the containment tree up to the root (using an <span class="code inline">ATTRIB</span> reference part). If it does not find them anywhere up the tree, including in the root component, the default is taken from the local process compound (this defines the defaults of 15 seconds and 2 misses given above). </p>
<a name="N124DA"></a><a name="Hooks"></a>
<h3 class="boxed">Hooks</h3>
<p class="Text body">At times, it is necessary to carry out an action for some or all of the phases of the lifecycle of every object &ndash; a typical use being to trace or log the components that come and go. To enable this, a set of lifecycle hooks have been provided, such that at every component lifecycle phase the appropriate hook is called, parameterized by the component.</p>
<p class="Text body">The hooks are called in the <span class="T3">PrimImpl</span><span class="T2"> </span>base class, as part of the default implementation of the template lifecycle methods. For the hooks to be called, therefore, it is essential that the superclass template methods are called in any derived class, as indicated in the primitive template in Appendix E.</p>
<p class="Text body">To create a new hook class, the class should implement the interface <span class="T3">PrimHook</span> in package <span class="T3">org.smartfrog.sfcore.prim</span><span class="T2">.</span> This interface defines a single method, <span class="T3">sfHookAction</span><span class="T2">,</span> which is called when the hook is invoked. This method is documented in the <span class="T5">Javadoc</span>.</p>
<p class="Text body">To register a hook, an instance of the hook class should be added to one of the four <span class="T3">HookSet</span> members available in <span class="code inline">Prim</span> (using the <span class="T3">addHook</span> method), namely <span class="T3">sfDeployWithHooks</span>, <span class="T3">sfDeployHooks</span>, <span class="T3">sfStartHooks</span>, and <span class="code inline">sfTerminateWithHooks</span>; one for each of the template methods. Note that the effect of the hook is local to a specific process.</p>
<p class="Text body">Removal of hooks is also possible, so creating a component that adds a hook on start, and removes it on termination, is feasible &ndash; so for example a management component could, on demand, capture all the lifecycles for a period of time at a process and send the information back to some central console.</p>
<p class="Text body">The mechanism is primarily intended for debugging and management. </p>
<a name="N1252A"></a><a name="Processes+and+Java+Virtual+Machines"></a>
<h3 class="boxed">Processes and Java Virtual Machines</h3>
<p class="Text body">The SmartFrog system is designed to form the basis for a fully distributed configuration and programming environment. As such, the system must be able to deal with deploying components into many processes (Java Virtual Machines) on many different hosts. This section covers the subject of these processes, how they may be identified and located, and how they may be started and managed. It also deals to a degree with the APIs provided to allow applications to interact with them, however, as usual, the full API is described in the accompanying Javadoc.</p>
<p class="P13">There are two concepts to understand as part of the underlying control of the SmartFrog system. The first of these is the SmartFrog Resource Reference (SFREF). This is a URL to a description file to deploy or otherwise use. The second is an SmartFrog Action Descriptor (SFACT), which is used to indicate to SmartFrog an action to take. These are now described in more detail.</p>
<a name="N12535"></a><a name="SmartFrog+Resource+References"></a>
<h4>SmartFrog Resource References</h4>
<p class="P13">Throughout the SmartFrog system, including on the command line, references to SmartFrog resources (i.e. files) may be given in a number of ways:</p>
<ul>
<li>
<p class="P14">as a URL to the file;</p>
</li>
<li>
<p class="P14">as a relative or absolute path name to a file;</p>
</li>
<li>
<p class="P14">as a path to a resource in a jar file on the classpath or code base.</p>
</li>
</ul>
<p class="P13">In this last case, the reference should be given as a path relative to the root of the package structure within the jar file, i.e. without the leading "<span class="code-inline">/</span>". In most cases this leading "<span class="code-inline">/</span>"is removed by the code, but there may be some instances where this is not so.</p>
<p class="P13">In the following descriptions of the scripts, a reference to such a resource is referred to as an <span class="code-inline">SFREF</span>.</p>
<a name="N1255C"></a><a name="SmartFrog+Action+Descriptor"></a>
<h4>SmartFrog Action Descriptor</h4>
<p class="P13">An action descriptor is used on the command line to describe a certain type of action that will be carried on by the daemon. An action has a number of &ldquo;:&rdquo; separated fields, most of which may be left blank in many cases.</p>
<p class="P13">The format is: </p>
<p class="Code last line">NAME:ACTION:SFREF:SUBREF:HOST:PROCESS</p>
<p class="P13">The semantics of the fields are defined as follows:</p>
<a name="N1256D"></a><a name="NAME"></a>
<h5>NAME</h5>
<p class="Text body">The name is a single word, or a SmartFrog reference in which case it must be surrounded by quotes. The name has one of two interpretations depending on the action to be taken (see next field). </p>
<p class="Text body">In <span class="code-inline">TERMINATE</span>, <span class="code-inline">DETACH</span>, <span class="code-inline">DETaTERM, PING</span>, <span class="code-inline">DIAGNOSTICS</span> the name is a reference to the component on which to apply the action.</p>
<p class="Text body">In <span class="code-inline">DEPLOY</span>, the name is treated like a placement and the name is split into two: all but the last part is a reference to another component and the last (or only) part is the name which will be given to the deployed component within that referenced component. If the component is not a <span class="code-inline">ProcessCompound</span>, the component is also made the parent of the deployment.</p>
<p class="Text body">In all cases, the <span class="code-inline">NAME</span> is resolved relative to the process compound of the <span class="code-inline">HOST</span> and <span class="code-inline">PROCESS</span> specified by the appropriate fields.</p>
<p class="Text body">When a name is not provided, it indicates the process compound of the host and process defined in the <span class="code-inline">HOST</span> and <span class="code-inline">PROCESS</span> fields. Also, in <span class="code-inline">DEPLOY</span> no name means use the <span class="code inline">sfProcessComponentName</span> from the description if available or generate a random name to name the deployed description.</p>
<p class="Text body">Examples:</p>
<p class="Code last line">foo</p>
<p class="Code last line">"HOST localhost:foo"</p>
<a name="N125BE"></a><a name="ACTION"></a>
<h5>ACTION</h5>
<p class="Text body">This field defines the action to be taken on the named component</p>
<ul>
<li>
<p class="P132">
<span class="code-inline">DEPLOY</span> a component or application.</p>
</li>
<li>
<p class="P132">
<span class="code-inline">TERMINATE</span> a component or application.</p>
</li>
<li>
<p class="P132">
<span class="code-inline">DETACH</span> a component from its parent.</p>
</li>
<li>
<p class="P132">
<span class="code-inline">DETaTERM</span> detach and terminate a component from its parent.</p>
</li>
<li>
<p class="P132">
<span class="code-inline">PING</span> a component.</p>
</li>
<li>
<p class="P132">
<span class="code-inline">PARSE</span> a description and generates report.</p>
</li>
<li>
<p class="P132">
<span class="code-inline">DIAGNOSTICS</span> a component and generate report.</p>
</li>
</ul>
<a name="N125F8"></a><a name="SFREF"></a>
<h5>SFREF</h5>
<p class="Text body">The SmartFrog description (if needed) to be used by ACTION. It is a SmartFrog Resource Reference see 3.1. It needs to use quotes (&ldquo; or ') when the reference is using &ldquo;<span class="code-inline">:</span>&rdquo;. Currently this is only required for a <span class="code-inline">DEPLOY </span><span class="code-inline"><span class="T25">and</span></span><span class="code-inline"><span class="T26"> </span></span><span class="code-inline"><span class="code-inline">PARSE</span></span> actions and is ignored otherwise.</p>
<p class="Text body">Examples:</p>
<p class="Code last line">/home/sf/foo.sf</p>
<p class="Code last line">"c:\sf\foo.sf"</p>
<p class="Code last line">'c:\sf\foo.sf'</p>
<a name="N12623"></a><a name="SUBREF"></a>
<h5>SUBREF</h5>
<p class="Text body">When the SFREF is parsed and resolved, the result is a component description containing a number of attributes. In the &ldquo;sf&rdquo; language, this is the contents of the <span class="code-inline">sfConfig</span> definition. Under normal circumstances, it is this whole definition that is used for the deployment, but occasionally, for testing purposes perhaps, it is useful to specify some single subcomponent. Under these circumstances, the name of this attribute, or a reference to a deeply nested application, may be provided. This is the SUBREF.</p>
<p class="Text body">Examples:</p>
<p class="Code last line">foo</p>
<p class="Code last line">"fist:foo"</p>
<p class="Code last line">'fist:foo'</p>
<a name="N1263B"></a><a name="HOST"></a>
<h5>HOST</h5>
<p class="Text body">host name or IP from where to resolve the name. If HOST is not present, the process name is ignored and the process executing is used. If you want to refer to another process, other than the executing one, on the local host, "<span class="code inline">localhost</span>" should be used and the appropriate PROCESS name used.</p>
<p class="Text body">Examples:</p>
<p class="Code last line">foo.hpl.hp.com</p>
<p class="Code last line">127.0.0.1</p>
<a name="N12650"></a><a name="PROCESS"></a>
<h5>PROCESS</h5>
<p class="Text body">process name from where to resolve the name. When empty it defaults to &ldquo;<span class="code-inline">rootProcess</span>&rdquo;. </p>
<a name="N1265C"></a><a name="Examples"></a>
<h5>Examples</h5>
<p class="Text body">These examples show the use of the action descriptors for different purposes.</p>
<p class="Text body">Example 1: Deploy a description in the local daemon</p>
<p class="Code last line">Ex1:DEPLOY:org/smartfrog/examples/counter/example.sf::localhost:</p>
<p class="Text body">Example 2. Terminate the local <span class="code-inline">sfDaemon</span>
</p>
<p class="Code last line">rootProcess:TERMINATE:::localhost: </p>
<p class="Text body">or</p>
<p class="Code last line">:TERMINATE:::localhost:</p>
<p class="P13">Example 3: Deploy "<span class="code-inline">counterToSucceed</span>" from <span class="code-inline">counter/example2.sf</span>
</p>
<p class="Code last line">counterEx3:DEPLOY:org/smartfrog/examples/counter/example2.sf:"testLevel1:counterToSucceed":localhost:</p>
<p class="P13">Example 4: Get diagnostics report for "<span class="code-inline">sfDefault</span>" component running in <span class="code inline">localhost</span>
</p>
<p class="Code last line">sfDefault:DIAGNOSTICS:::localhost:</p>
<a name="N12693"></a><a name="SFSystem+And+Command-Line+Parameters"></a>
<h4>SFSystem And Command-Line Parameters</h4>
<p class="Text body">The main loop of a SmartFrog process is provided by the class <span class="T3">SFSystem</span>. When this class is invoked, it reads various command line parameters and system properties to generate the appropriate type of SmartFrog process and to trigger the desired configuration actions. The general form of the command line for SmartFrog is</p>
<p class="Code last line">java [&ndash;D properties] org.smartfrog.sfcore.SFSystem [parameters]</p>
<p class="Text body">In general the command line will be triggered by a script setting up the properties as defined and described below, and arranging for the command line parameters to be correctly defined. The parameters are:</p>
<ul>
<li>
<p class="P133">
<span class="code inline">-a SFACT: </span>SmartFrog Action Descriptors (SFACT). There can be more than one of this. See format for SFACT in 13.2</p>
<p class="P134"></p>
</li>
<li>
<p class="P135">
<span class="code inline">-f SFREF:</span> file that contains a set of file that contains a set of SmartFrog Action Descriptors (SFACT). There can be more than one of this. See format for SFREF in 13.1.</p>
</li>
<li>
<p class="P135">
<span class="code inline">-e</span> : exit after deployment of the configurations is complete.</p>
</li>
<li>
<p class="P135">
<span class="code inline">-?</span>: usage and help information.</p>
</li>
</ul>
<p class="Text body"></p>
<p class="Text body">The system properties are rather more complex in their effect. To understand their effect on SmartFrog behaviour, the concept of a process compound must be explained. Of course, additional properties may be defined to parameterize specific applications that require it (this is particularly useful in conjunction with the <span class="code inline">PROPERTY</span> and <span class="code inline">IPROPERTY</span> links).</p>
<a name="N126D1"></a><a name="Process+Compounds"></a>
<h4>Process Compounds</h4>
<p class="Text body">Every process contains a specialized component known as a <span class="T3">ProcessCompound</span> created by <span class="T3">SFSystem</span> at start-up. It is a modified <span class="code inline">Compound</span> providing the full component creation interface offered by all compounds. As such, it is the means by which all top-level components within the process are created. As it is a compound, it also contains attributes and sub-components:</p>
<ul>
<li>
<p class="P136">It contains attributes that affect the behaviour of the process, such as security settings, classpath information, and so on.</p>
</li>
<li>
<p class="P136">It contains an attribute referencing each application that is running in the process. These applications are all children of the <span class="T3">ProcessCompound</span><span class="T2">, </span>in the sense that<span class="T2"> </span>the <span class="T3">ProcessCompound</span> does monitor the children for status. This is so they may be removed from the <span class="T3">ProcessCompound</span> on termination. The applications, however, do not consider the <span class="T3">ProcessCompound</span> as their parent.</p>
</li>
<li>
<p class="P136">It contains, as a child, the <span class="T3">ProcessCompound</span> of any sub-process that may be created during the deployment process: it is possible to have a simple two-level tree of processes controlled by attributes within the <span class="T3">ComponentDescription</span> to be deployed. A sub-process does consider the root process as its parent and will terminate if the root dies.</p>
</li>
</ul>
<p class="Text body">However, to interact with the <span class="T3">ProcessCompound</span> in a process, for example to initiate a deployment, it is necessary to obtain the RMI object reference to that <span class="T3">ProcessCompound</span>. SmartFrog defines a core mechanism using the RMI registry for this purpose, though other mechanisms may additionally be defined. One such is that provided with the SLP discovery infrastructure described in a separate document. Only the registry-based mechanism is described here.</p>
<a name="N1271C"></a><a name="Types+Of+Processes"></a>
<h4>Types Of Processes</h4>
<p class="Text body">Processes come in three main types:</p>
<ul>
<li>
<p class="P137">Root Processes that create an instance of an RMI registry and register themselves within it so that they may be located. Note that a host may have several root processes so long as they use different ports for the registry. However there are restrictions in the current release that limit the degree of interactions of processes on different ports and hence this should only be done if the two belong to different SmartFrog systems. A SmartFrog system is designed so that a single root process exists on each host, and that these are on the same port number.</p>
</li>
<li>
<p class="P137">Sub-processes are processes that register with the root process and become children of the root process, and hence are named within the <span class="T3">ProcessCompound</span> of the root process. This is the mechanism by which the sub-processes are located and their RMI references obtained. Subprocesses may be created in two ways &ndash; by explicit launching from a command line or by defining that an application should be deployed in a sub-process that is created if it does not already exist.</p>
</li>
<li>
<p class="P137">Basic processes are processes that do not use the core SmartFrog mechanisms to advertise their existence &ndash; either because they are not required to be accessed or because they use other mechanisms for this purpose.</p>
</li>
</ul>
<p class="Text body">The normal model for a SmartFrog system is that a root process compound is created as a service or daemon on each host, possibly at boot time, and that applications are created (in dynamically created sub-processes if so desired) as defined by applications that are launched from basic processes that exit when the application has been successfully deployed.</p>
<a name="N12738"></a><a name="Process+Attributes"></a>
<h4>Process Attributes</h4>
<p class="Text body">Each process, when it is started, customizes its behaviour dependent on attributes that are given it in two distinct ways:</p>
<ul>
<li>
<p class="P138">As attributes defined in the <span class="T3">processcompound.sf</span><span class="code inline"> </span>file that is read at the start-up of any process.</p>
</li>
<li>
<p class="P138">System properties set on the command line that override the defaults provided in the above start-up file.</p>
</li>
</ul>
<p class="Text body">These attributes control aspects of process behaviour such as type of process it should be, what port is used for the registry within the system, whether security should be enabled and where remote code is available for remote downloading. Most of the attributes may be defined in either or both the above ways, however a few of the attributes must be passed as system properties. In particular, the security properties need to be set before the <span class="T3">processcompound.sf</span> file is read.</p>
<p class="Text body">When the <span class="T3">processcompound.sf</span> file is parsed, all system properties with the prefix <span class="T3">org.smartfrog.sfcore.processCompound</span> are added to the context before deployment, thereby creating the process compound itself. Consequently, using the command line option </p>
<p class="Code last line">-Dorg.smartfrog.sfcore.processCompound.sfRootLocatorPort=2000</p>
<p class="Text body">when starting Java overrides the default value defined in <span class="T3">processcompound.sf</span><span class="code inline">.</span> The attributes from <span class="code inline">processcompound.sf</span> that are considered user-modifiable are as follows:</p>
<ul>
<li>
<p class="P139">
<span class="code inline">sfProcessName</span> 
<br>(no default value preset in <span class="T3">processcompound.sf</span>)</p>
</li>
<li>
<p class="P140">
<span class="code inline">sfLivenessDelay 15;</span>
</p>
</li>
</ul>
<p class="P141">how frequently (in seconds) to check children processes and applications to status</p>
<ul>
<li>
<p class="P140">
<span class="code inline">sfLivenessFactor 5;</span>
</p>
</li>
</ul>
<p class="P141">how many missed checks from parent process before assuming that parent process is dead</p>
<ul>
<li>
<p class="P140">
<span class="code inline">sfProcessAllow true;</span>
</p>
</li>
</ul>
<p class="WW-List 4">allow sub-processes &ndash; only used with the root process compound</p>
<ul>
<li>
<p class="P140">
<span class="code inline">sfProcessTimeout 60;</span>
</p>
</li>
</ul>
<p class="P141">how long to wait (in seconds) for a child process to be created before failure is assumed</p>
<ul>
<li>
<p class="P142">
<span class="code inline">sfRootLocatorPort 3800;</span>
</p>
</li>
</ul>
<p class="WW-List 4">the registry port for the root process compound</p>
<a name="N127B2"></a><a name="Accessing+Process+Compounds+And+Attributes"></a>
<h4>Accessing Process Compounds And Attributes</h4>
<p class="Text body">Attributes may be accessed via the process compound itself. Indeed, the attributes should never be accessed by requesting the system properties - they may not have been defined through that mechanism. To access the attributes, first obtain the process compound of that process then simply lookup the attribute using the normal SmartFrog supplied methods (it is, after all, a Prim) as in:</p>
<p class="Code last line">SFProcess.getProcessCompound()<br>.sfResolve(Reference.fromString("sfRootLocatorPort"));</p>
<p class="Text body">Note that for efficiency, using the string reference parser should be limited. Overall, it is better to build and use a reference to avoid the expensive step of parsing the string as a reference. </p>
<p class="Text body">If the process compound required is on a different host, or is in a different sub-process, the mechanism is to first locate the root process compound on that host, then to find the process of that name as an attribute within the process compound. This can be done using the following invocation</p>
<p class="Code last line">SFProcess.getRootLocator().getRootProcessCompound("hostname");</p>
<p class="Text body">Or by making use of the host reference</p>
<p class="Code last line">sfResolve(Reference.fromString("HOST hostname"));</p>
<p class="Text body">Attributes may then be queried as before. Once the root process compound is obtained, sub-processes may be obtained by looking up the process name in the compound as with any other attribute.</p>
<a name="N127D1"></a><a name="Creating+And+Naming+Sub-Processes"></a>
<h4>Creating And Naming Sub-Processes</h4>
<p class="Text body">Sub-processes are created in two ways. A user may create a sub-process of an existing root process by setting the system property <span class="T3">sfProcessName</span> as follows on the command line to start the daemon:</p>
<p class="Code last line">-Dorg.smartfrog.sfcore.ProcessComopund.sfProcessName=name</p>
<p class="Text body">By doing so, the process registers with the root under the supplied name. If the root does not exist, the process will fail and terminate. Note that if the reserved name &ldquo;<span class="code inline">rootProcess</span>&rdquo; is used, a root process is created.</p>
<p class="Text body">The second mechanism is via the attribute &ldquo;<span class="code inline">sfProcessName</span>&rdquo; being given in a component to be deployed as in the following snippet</p>
<p class="Code">Foo extends Compound { </p>
<p class="Code">sfProcessName "fooProcess";</p>
<p class="Code">// ... </p>
<p class="Code last line">}</p>
<p class="Text body">On deployment, the compound <span class="code inline">Foo</span> will be deployed in a sub-process <span class="T3">fooProcess</span>, the host depending on the provision of the attribute <span class="T3">sfProcessHost</span> and local if not provided. If <span class="T3">fooProcess</span> already exists, this will be used, otherwise a new process will be created using that name.</p>
<p class="Text body">It should be noted that in automatically creating this subprocess, the command line is defined to pass on all system properties of the root, apart from the <span class="T3">org.smartfrog.sfcore.processCompound.sfProcessName</span><span class="code inline"> </span>property that set to the appropriate name for the process.</p>
<a name="N12817"></a><a name="Naming+Applications"></a>
<h4>Naming Applications</h4>
<p class="Text body">As applications are deployed into the various processes, the process compounds are involved in the creation of the first component of an application tree in that process (this may not be the root component of the application tree, just the first in that process). As it does so, the process compound will keep an attribute referencing this component, the name of the component being either obtained from the component&rsquo;s <span class="T3">sfProcessComponentName</span> attribute if it exists, or a random unique name generated on demand. </p>
<p class="Text body">This component is not a child of the process compound, though the process compound does monitor it for status using the liveness mechanism, removing it if liveness shows that the component has terminated. However, the provision of this attribute does enable a management system to locate processes (using the registry and named sub-processes) and then to find all applications that are resident completely or partially within that process. By following the hierarchy of parent/child relationships, every component across all processes of every application can be located.</p>
<p class="Text body">Using the <span class="T2">&ndash;n</span> command-line parameter of <span class="T3">SFSystem</span> command ensures that the root component of the associated configuration is given the name provided on the command line. It is exactly as though application were being given a name by using the <span class="code inline">sfProcessComponentName</span> in the application itself.</p>
<a name="N12835"></a><a name="HOST+and+PROCESS+Links"></a>
<h4>HOST and PROCESS Links</h4>
<p class="Text body">Note that the naming of components in this way also provides a convenient naming service across a SmartFrog system that could be used by components to locate each other &ndash; for example, a component may wish to log events at the logging service on a specific host. The normal way in which components locate each other is, of course, by using a link. To support the use of the naming capability, a <span class="code inline">HOST</span> link is provided which will, as it is resolved, use the root location mechanism to access remote process compounds, allowing the remainder of the link to be de-referenced in that context, to a subprocess compound or an application component. The syntax for <span class="code inline">HOST</span> references is given in section 2.2.4. </p>
<p class="Text body">Another link that may be used in a similar way is the <span class="code inline">PROCESS</span> link that refers to the process compound of process in which the component is deployed.</p>
<a name="N1284C"></a><a name="The+SmartFrog+Security+Model"></a>
<h3 class="boxed">The SmartFrog Security Model</h3>
<a name="N12851"></a><a name="Introduction-N12851"></a>
<h4>Introduction </h4>
<p class="Text body">This section describes the SmartFrog security model. Its design deliberately had a very simple usage model in mind, so it may not suit all uses. Future releases of SmartFrog will address more complex scenarios by enhancing some of the current mechanisms, so even if it does not fully meet your requirements, some experimentation may still be worthwhile. In addition, although some penetration testing has been done, security mechanisms are difficult to get right first time, so unwanted "features" may well appear.</p>
<p class="Text body">Several aspects are covered in this section. Firstly, the threats that are considered in the model are described. Secondly, the policies that must be enforced in order to protect the system from these threats are defined. Thirdly, the specific mechanisms that have been implemented, and the assumptions regarding the rest of the system are listed. Finally, a discussion about the current limitations that will motivate enhancements in future releases. </p>
<a name="N1285C"></a><a name="Threat+Model"></a>
<h4>Threat Model </h4>
<p class="Text body">SmartFrog could be an extremely powerful tool to spread viruses. The ease of deploying and managing the life cycle of a distributed application plays against you when the application deployed is malign. Therefore, it is critical that the system controls who can deploy what and where.</p>
<p class="Text body">In particular, the communication channels between SmartFrog daemons are not necessarily secure, e.g., they could be Internet connections. An attacker could modify deployment configurations sent from legitimate daemons, or just pretend that he is a valid participant and send his own. In addition, he can obtain critical configuration information, such as passwords, by snooping on the communication, that he can later use to attack the system. </p>
<p class="Text body">An important feature of SmartFrog is to dynamically load resources from web servers while deploying. These resources could be additional configuration descriptions, Java classes, scripts, executable files and so on. New exploits on web servers appear every month, and the concern is that these could be used to modify resources that SmartFrog will download later on. </p>
<p class="Text body">Making a node "SmartFrog aware" implies installing a permanent service in this node, opening up a port for incoming requests, creating a special account to run the service, and so on. This can make that platform more vulnerable if someone can compromise the service itself, e.g., by exploiting a buffer overflow. </p>
<a name="N1286D"></a><a name="Security+Policy"></a>
<h4>Security Policy </h4>
<p class="Text body">The ultimate goal is that a distributed application configured, deployed and managed by SmartFrog is not more vulnerable than the same application configured, deployed and managed manually using a local secure procedure. This means that SmartFrog is not trying to "fix" the security problems of the application itself by, e.g., constraining what the application can do. However, the application could indirectly benefit by having a more flexible mechanism to bootstrap its security, or it could even use directly SmartFrog security services. </p>
<p class="Text body">Another desired goal is not to introduce new vulnerabilities in the hosting node because SmartFrog has been activated. The problem is that the interactions of SmartFrog with the rest of the system make this goal platform dependent. Again, SmartFrog cannot "fix" problems in the underlying OS security; it is simply that SmartFrog must not make them more "visible". </p>
<p class="Text body">To help clarify the target security model in this release, the concept of a SmartFrog Trusted Community (SFTC) has been introduced. A SFTC is a set of principals, typically composed of SmartFrog daemons and administrators that fully trust each other, i.e., they will do <span class="T6">anything</span> that another valid member requests, and they do not trust anybody else. There is a single authority that defines who is initially in the community, but a current member could later on add new members based on its own criteria. A member of an SFTC should only use resources that are trusted, where trust in this context means that they were created or authorized by another member of the community, and nobody has modified them since. In some cases, we want to enforce confidentiality as well as integrity on these resources, always within the scope of an SFTC. </p>
<p class="Text body">As mentioned in the discussion on threats, SmartFrog uses web servers to dynamically load resources. Web servers are <span class="T6">not</span> part of the SFTC, although they host resources that are trusted by members of the SFTC. Mechanisms described in the next section will enforce the integrity (but currently not the confidentiality) of these resources. </p>
<p class="Text body">There is a strong requirement for knowing what is coming from inside or outside the community, but it is less valuable to know from whom within the community the original request came from. This means that accountability of individual members in the community is very limited, something not surprising when members fully delegate each other actions, and there are no members with "special" privileges. Nevertheless, SmartFrog still give different identities to each principal in an SFTC to make future enhancements easier. </p>
<p class="Text body">Special care should be taken before authorizing that a particular application might be deployed in the platform. Deployed components share the same environment and privileges of the SmartFrog infrastructure and they could take control of it. The problem is not only deploying a virus, but also deploying an application with an exploitable vulnerability, that will allow an attacker to get control of the application, then the SmartFrog local daemon, and finally all the nodes in the SFTC. In general, ensure that daemons have the minimal privileges required to carry out the tasks required by the applications.</p>
<a name="N1288C"></a><a name="Security+Mechanisms"></a>
<h4>Security Mechanisms </h4>
<p class="Text body">In this section, the security mechanisms that have been implemented for SmartFrog to support SFTCs are described. This implies knowing when a principal is a valid member of the community, ensuring that interactions over an insecure network of valid members are safe, and satisfying the integrity (and authentication) requirements of trusted resources, possibly hosted by non-members of the SFTC. In addition, other mechanisms that have not been implemented as part of SmartFrog, but are assumed to be available to make the model work, are discussed. </p>
<a name="N12894"></a><a name="Built-in+security+mechanisms"></a>
<h5>Built-in security mechanisms</h5>
<p class="Text body">SmartFrog uses PKI (Public Key Infrastructure) based on X509 certificates to provide principals of the SFTC with credentials that justify they are valid members of the community. The centralized CA (Certificate Authority) is based on openSSL and fully integrated with the rest of the release installation process (by using Ant). Keys for individual members are actually generated using Sun's <span class="code inline">keytool</span>, and Sun's implementation of a keystore (with random passwords) is used to keep node credentials safe (we assume though that the centralized CA is in a safe, isolated environment). </p>
<p class="Text body">Java 2 security mechanisms are leveraged to create a SFTC. In particular, the Java security policy is set so that, when enforced by a <span class="code inline">SecurityManager</span>, gives full privileges to classes loaded from signed jars (using a trusted key for the SFTC), and none otherwise. These mechanisms are extended to other resources apart from classes, such as configuration descriptions, so that they are only loaded if they are in a signed jar (same signing key as before). This is particularly useful when the jars are hosted by web servers that are not part of the SFTC. Jars containing classes and configurations of this release are signed as part of the installation process. Jars with your classes/configurations could be easily signed with a similar process (i.e., using Ant). </p>
<p class="Text body">RMI calls are tunnelled over SSL using the JSSE API and Sun's reference implementation. SmartFrog forces <span class="T6">mutual</span> authentication in the SSL sessions based on the 1024 bits RSA public/private keys that are discussed above. Only the SFTC CA keys are part of our trust assumptions so, by validating the other partner's X509 certificate chain, SmartFrog knows that it belongs to the community. However, the authenticated credentials of the other session peer are currently propagated to the application layer, but this will only be useful in future releases. Current SSL session settings include triple DES encryption, with HMAC SHA-1 for message authentication. In addition, a similar mechanism is used to protect access to the RMI registry. </p>
<p class="Text body">SmartFrog supports dynamic loading of stubs during RMI calls, or arbitrary resources in signed jar files using an enhanced RMI class loader. In both cases the loading sources is restricted to a configured codebase, and use the Java 2 mechanisms for signed JAR files described above. </p>
<p class="Text body">All SmartFrog core classes use the security hooks described above for loading resources and communicating with other peers. In addition, the set-up of the security mechanisms is done as early as possible in the initialization of daemons to minimize exposure. </p>
<a name="N128B4"></a><a name="Assumptions"></a>
<h5>Assumptions</h5>
<p class="Text body">The process of setting up the critical components of SmartFrog is safe. For example, the Zip file containing the release has not been tampered with or, if keys are centrally created, their confidentiality has not been compromised when they were ship to the target host. </p>
<p class="Text body">Similarly, SmartFrog critical components are protected by the underlying OS after they have been set-up. For example, everything under the directory "<span class="code inline">private/</span>" can only be read/modified by the authorized user account that is using SmartFrog (the security credentials are in that directory). Moreover, an attacker cannot modify the SF core classes, basic scripts, or the JVM itself. In general, SmartFrog is not trying to solve vulnerabilities of the platform, just hoping that things do not get worse. </p>
<p class="Text body">The current SmartFrog infrastructure is only as secure as the applications that it deploys, unless significant application customization is done (e.g., spawn processes under a different user with less privileges). </p>
<p class="Text body">The implementation of the security mechanisms in SmartFrog uses many third-party packages to quickly implement the security mechanisms. This implies that if vulnerabilities are found in one of these components, e.g., Sun's secure random number generator, this will have a devastating effect on the implementation. </p>
<a name="N128C9"></a><a name="Known+limitations+and+future+enhancements"></a>
<h5>Known limitations and future enhancements </h5>
<p class="Text body">Some of the security assumptions will be relaxed in future releases of SmartFrog. The next logical enhancement is to isolate the SmartFrog infrastructure from the applications that it deploys and manages. Since restrictions should not be placed on what SmartFrog can deploy, OS support will be required for that.</p>
<p class="Text body">Once isolation can be guaranteed, a common platform can be used to deploy applications for non-mutually trusted clients. This will require virtualizing the deployment service so that clients just can view and interact with their own applications. </p>
<p class="Text body">The next step will be deploying applications that spawn multiple domains of trust, i.e., multiple SFTC, in which a non-hierarchical trust model and more accountability is required. This federated model, together with a new revocation mechanism, will limit the exposure when the security credentials of a valid member are compromised. </p>
<p class="Text body">Finally, denial of service attacks are not prevented, and some of third party packages that are used are particularly exposed to these attacks. Re-engineering SmartFrog to be more robust against these attacks is a significant effort.</p>
<a name="N128DA"></a><a name="Properties"></a>
<h3 class="boxed">Properties</h3>
<p class="Text body">SmartFrog may have a number of properties defined that alter the behaviour of the daemon. Some of these are required to be defined on the command line (typically those that affect the way Java itself works), others may be defined in a file (often <span class="T3">default.ini</span><span class="T1">) and</span> passed to the daemon on the command line. </p>
<p class="Text body">These properties are captured in the class:</p>
<p class="Code last line">org.smartfrog.sfcore.common.SmartFrogCoreProperty</p>
<p class="Text body">Some interesting properties are:</p>
<ul>
<li>
<p class="P36">
<span class="code inline">org.smartfrog.logger.logStackTrace</span>: Optional boolean property to include stack trace with error message. Default=false.</p>
</li>
</ul>
<ul>
<li>
<p class="P37">
<span class="T11">org.smartfrog.sfcore.processcompound.</span><span class="code inline">sfRootLocatorPort</span>: SmartFrog daemon connection port. Default=3800.</p>
</li>
</ul>
<ul>
<li>
<p class="P38">
<span class="T11">org.smartfrog.sfcore.processcompound.</span><span class="code inline">sfLivenessDelay</span>: Liveness check period (in seconds). Default=15.</p>
</li>
</ul>
<ul>
<li>
<p class="P39">
<span class="T11">org.smartfrog.sfcore.processcompound.</span><span class="code inline">sfLivenessFactor</span>. Liveness check retries. Default = 5.</p>
</li>
</ul>
<ul>
<li>
<p class="P40">
<span class="T11">org.smartfrog.sfcore.processcompound.</span><span class="code inline">sfProcessAllow</span>: Allow spawning of subprocess. Default=true.</p>
</li>
</ul>
<ul>
<li>
<p class="P41">
<span class="T11">org.smartfrog.sfcore.processcompound.</span><span class="code inline">sfProcessTimeout</span>: Subprocess creation/failure timeout. Default=60. Slower machines might need longer periods to start a new subprocess.</p>
<p class="P41"></p>
</li>
</ul>
<p class="Text body">Properties that can only be defined using Java <span class="code inline">-D</span> command line:</p>
<p class="P19">
<span class="code inline">org.smartfrog.sfcore.processcompound.sfProcessName</span>: A user may create a sub-process of an existing root process by setting this system property. To start a SmartFrog daemon this property has to be set to &ldquo;<span class="code inline">rootProcess</span>&rdquo;.</p>
<p class="P42">
<span class="code inline">org.smartfrog.iniFile</span>: to load a file with properties to define JVM system properties. This file may not contain properties that affect security or code loading &ndash; it is read after these are already initialized.</p>
<p class="P19">
<span class="code inline">org.smartfrog.sfcore.processcompound.sfDefault.REGISTRATION_NAME</span>: This property is used to describe some descriptions that should be deployed in all daemons and sub-processes. Each description will be registered in the process using <span class="code inline">REGISTRATION_NAME</span> as <span class="code inline">name</span>. It is possible to have many of this properties but the <span class="code inline">REGISTRATION_NAME</span> cannot be repeated.</p>
<p class="P19">
<span class="code inline">org.smartfrog.codebase</span>: Property used to define the codebase, a list of space separated URLs of JAR files used by the daemon. </p>
<p class="P19">
<span class="code inline">org.smartfrog.sfcore.security.keyStoreName</span>: to load the private keys for the daemon.</p>
<p class="P19">
<span class="code inline">org.smartfrog.sfcore.security.propFile=</span> to load security properties.</p>
<p class="P42">
<span class="T12">org.smartfrog.sfcore.security.debug</span><span class="T13">: to enable security debug information. Default</span>=<span class="code inline">false</span>;</p>
<p class="P19">
<span class="code inline">java.security.policy</span>: Property to define Java security properties.</p>
<p class="P19">
<span class="code inline">java.security.debug</span>: Property to define debug level in Java security.</p>
<p class="P19">
<span class="code inline">java.rmi.server.logCalls</span>: Property to enable RMI logging. Default=<span class="code inline">false</span>;</p>
<p class="P43">
<span class="code inline">sun.rmi.loader.logLevel</span>: Property to define debug RMI level. Example: .<span class="code inline">VERBOSE</span> 
</p>
<p class="P19">
<span class="code inline">java.security.manager</span>: Property to define the Java security manager.</p>
</div>
<a name="N129A1"></a><a name="Part+5%3A+A+SmartFrog+Example"></a>
<h2 class="boxed">Part 5: A SmartFrog Example</h2>
<div class="section">
<a name="N129A6"></a><a name="Example"></a>
<h3 class="boxed">Example</h3>
<p class="Text body">This section creates a simple example, covering all aspects including the creation of the SmartFrog description and the necessary Java classes.</p>
<p class="Text body">The example is a variant on the normal &ldquo;hello world&rdquo; that is so favoured by books on programming. There will be two components &ndash; a printer and a message generator. The message generator will locate the printer, send a series of messages to it, and terminate. The printer, on the other hand, will wait until it is given a message, and then print it. It will terminate when told to do so.</p>
<p class="Text body">The example is supplied with the SmartFrog distribution and is in package <span class="T3">org.smartfrog.examples.helloworld</span>.</p>
<p class="Text body">For each of the two components, two aspects must be considered:</p>
<ul>
<li>
<p class="WW-List Bullet 2">How the description for the component is defined, what attributes must be provided and what the default attribute values are</p>
</li>
<li>
<p class="WW-List Bullet 2">How the implementation is to be written, what is to be done in the various lifecycle phases and what threading is required</p>
</li>
</ul>
<p class="Text body">Following the definition of the components, consideration must be given as to how they are to be combined into a single application.</p>
<a name="N129C7"></a><a name="The+Printer"></a>
<h4>The Printer </h4>
<p class="Text body">The printer is a very simple component. It offers a single method that must be accessible via RMI, namely <span class="T3">printIt</span>, which must take a string and print it on the standard output. It has no specific initialization requirements, no threading and no specific need to clean up on termination. </p>
<p class="Text body">To make it a little more interesting, the printer will prefix the output message with an identifier - either the <span class="T3">name</span> attribute if it is provided, or the name the component has in the application tree if it is not.</p>
<p class="Heading 4">The Description &ndash; file &ldquo;<span class="code inline">printer.sf</span>&rdquo;</p>
<p class="Text body">The description needs only to link the component type to the implementing class. It does not need to provide a default value for the name of the printer, since the use of no name will cause a default to the name within the component tree.</p>
<p class="Code">Printer extends Prim {</p>
<p class="Code">sfClass "org.smartfrog.examples.helloworld.PrinterImpl";</p>
<p class="Code">name ""; //name &ndash; if empty, uses sfCompleteName</p>
<p class="Code last line">}</p>
<p class="Text body">This fully describes the basic printer component. Host bindings will be done as part of the complete application description.</p>
<p class="Heading 4">The Interface &ndash; file &ldquo;<span class="code inline">Printer.java</span>&rdquo;</p>
<p class="Text body">Since the printer has an RMI accessible method, that method must be described in an interface that extends <span class="T3">Remote</span>, and the method must throw the appropriate <span class="T3">RemoteException</span>. The interface is very simple:</p>
<p class="Code">package org.smartfrog.examples.helloworld;</p>
<p class="Code">import java.rmi.*;</p>
<p class="Code"></p>
<p class="Code">public interface Printer extends Remote {</p>
<p class="Code">public void printIt(String message) throws RemoteException;</p>
<p class="Code last line">}</p>
<p class="Text body">This interface will be used by RMIC to generate the appropriate stub for the <span class="code inline">PrinterImpl</span> class enabling other components to remotely call this method.</p>
<p class="Heading 4">The Implementation &ndash; file &ldquo;<span class="code inline">PrinterImpl.java</span>&rdquo;</p>
<p class="Text body">The <span class="T3">PrinterImpl</span> class is a primitive component and so must follow the outline template provided in section . In addition, it must implement the <span class="T2">Printer</span> interface.</p>
<p class="Text body">Note that since there are no specific start or termination actions to carry out, there is no need to provide the <span class="T3">sfStart</span> or <span class="T3">sfTerminateWith</span> methods.</p>
<p class="Code">package org.smartfrog.examples.helloworld;</p>
<p class="Code">import org.smartfrog.sfcore.prim.*;</p>
<p class="Code">import java.rmi.*;</p>
<p class="Code">import org.smartfrog.sfcore.Reference.*;</p>
<p class="Code">import org.smartfrog.sfcore.prim.*;</p>
<p class="Code"></p>
<p class="Code">public class PrinterImpl extends PrimImpl implements Prim, Printer {</p>
<p class="Code"></p>
<p class="Code">/* any component specific declarations */</p>
<p class="Code"></p>
<p class="Code">// my name</p>
<p class="Code">String name = "";</p>
<p class="Code"></p>
<p class="Code">// reference to my name attribute</p>
<p class="Code">Reference nameRef = new Reference(ReferencePart.here("name"));</p>
<p class="Code"></p>
<p class="Code">// standard remotable constructor &ndash; must be provided</p>
<p class="Code">public PrinterImpl() throws RemoteException {</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">// initialization template method</p>
<p class="Code">public synchronized void sfDeploy() </p>
<p class="Code">throws RemoteException, SmartFrogException {</p>
<p class="Code">super.sfDeploy();</p>
<p class="Code">/* any component specific initialization code */</p>
<p class="Code">name = sfResolve(nameRef, "", false); </p>
<p class="Code">if (name.equals("") name = sfCompleteName().toString();</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">/* component specific methods */</p>
<p class="Code">public void printIt(String message) throws RemoteException {</p>
<p class="Code">system.out.println(name + ": " + message);</p>
<p class="Code">}</p>
<p class="Code">}</p>
<p class="Text body"></p>
<a name="N12A9B"></a><a name="The+Generator"></a>
<h4>The Generator </h4>
<p class="Text body">The generator is a slightly more complex component. In particular, it must locate the printer, and call it with a sequence set of messages. This must be done in a separate thread started during the <span class="T3">sfStart</span> lifecycle method. The thread must be terminated during the termination template method if it has not already done so.</p>
<p class="Text body">In addition to locating the printer, the component must obtain its set of messages and a frequency with which it should print these messages (defaulting to, say, one every 10 seconds).</p>
<p class="Heading 4">The Description &ndash; file &ldquo;<span class="code inline">generator.sf</span>&rdquo;</p>
<p class="Text body">The description needs to link to the component type to the implementing class and define the other attributes with their default values. The link to the printer component, which will be LAZY because the RMI reference is required, cannot be provided until the whole application is created.</p>
<p class="Code">Generator extends Prim {</p>
<p class="Code">sfClass "org.smartfrog.examples.helloworld.GeneratorImpl";</p>
<p class="Code">frequency 10; // default value set to 10 seconds</p>
<p class="Code">messasges []; // a vector of messages</p>
<p class="Code">printer; // link to the printer component</p>
<p class="Code last line">}</p>
<p class="Heading 4">The Implementation &ndash; file &ldquo;GeneratorImpl.java&rdquo;</p>
<p class="Text body">Unlike the printer, the generator has no externally accessed methods apart from those related to being a primitive component. Consequently, no additional interface needs to be defined. The generator, though, requires a thread &ndash; this may be done in many ways but extending <span class="T2">Runnable</span> and creating a thread from itself is the easiest.</p>
<p class="Code">package org.smartfrog.examples.helloworld;</p>
<p class="Code">import org.smartfrog.sfcore.Reference.*;</p>
<p class="Code">import org.smartfrog.sfcore.prim.*;</p>
<p class="Code">import java.util.*;</p>
<p class="Code">import java.rmi.*;</p>
<p class="Code"></p>
<p class="Code"></p>
<p class="Code">public class GeneratorImpl extends PrimImpl implements Prim,Runnable {</p>
<p class="Code"></p>
<p class="Code">/* any component specific declarations */</p>
<p class="Code">Reference messagesRef = new Reference(</p>
<p class="Code">ReferencePart.here("messages"));</p>
<p class="Code">Reference printerRef = new Reference(</p>
<p class="Code">ReferencePart.here("printer"));</p>
<p class="Code">Reference frequencyRef = new Reference(</p>
<p class="Code">ReferencePart.here("frequency"));</p>
<p class="Code"></p>
<p class="Code">Printer printer;</p>
<p class="Code">Vector messages;</p>
<p class="Code">int frequency;</p>
<p class="Code"></p>
<p class="Code">Thread sender;</p>
<p class="Code">boolean terminated = false; // notify the thread to terminate</p>
<p class="Code"></p>
<p class="Code">public GeneratorImpl() throws RemoteException {</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">public synchronized void sfDeploy() </p>
<p class="Code">throws RemoteException, SmartFrogException {</p>
<p class="Code">super.sfDeploy();</p>
<p class="Code"></p>
<p class="Code">printer = (Printer) sfResolve(printerRef, true);</p>
<p class="Code">messages = sfResolve(messagesRef), [], true);</p>
<p class="Code">frequency = sfResolve(frequencyRef,0,true)* 1000;</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">public synchronized void sfStart() </p>
<p class="Code">throws RemoteException, SmartFrogException {</p>
<p class="Code">super.sfStart();</p>
<p class="Code"></p>
<p class="Code">// create and start the thread</p>
<p class="Code">sender = new Thread(this);</p>
<p class="Code">sender.start();</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">public synchronized void sfTerminateWith(TerminationRecord tr) {</p>
<p class="Code">// terminate the thread nicely if needed, can wait for it to</p>
<p class="Code">// awake to actually do so</p>
<p class="Code"></p>
<p class="Code">terminated = true;</p>
<p class="Code">super.sfTerminateWith(tr);</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">public void run() {</p>
<p class="Code">// the body of the thread</p>
<p class="Code">try {</p>
<p class="Code">for (Enumeration en = messages.elements();</p>
<p class="Code">en.hasMoreElements() &amp; !terminated; ) {</p>
<p class="Code">printer.printIt(en.nextElement().toString()); </p>
<p class="Code">if (frequency &gt; 0) {</p>
<p class="Code">Thread.sleep (frequency)</p>
<p class="Code">}</p>
<p class="Code">}</p>
<p class="Code">} finally {</p>
<p class="Code">// it doesn't matter calling this many times</p>
<p class="Code">sfTerminate(TerminationRecord.normal(null));</p>
<p class="Code">}</p>
<p class="Code">}</p>
<p class="Code">}</p>
<a name="N12B92"></a><a name="Compiling+the+Components"></a>
<h4>Compiling the Components</h4>
<p class="Text body">The two classes and the interface all need to be compiled using the <span class="T3">javac</span> compiler. This has been done in the distribution and the classes are in the <span class="T3">sfExamples.jar</span> file.</p>
<p class="Text body">Further, the two classes must be prepared for RMI by creating and compiling the stubs and skeletons. This is done using the <span class="T2">rmic</span> compiler that is invoked on the class:</p>
<p class="Code">rmic org.smartfrog.examples.helloworld.PrinterImpl</p>
<p class="Code last line">rmic org.smartfrog.examples.helloworld.GeneratorImpl</p>
<p class="Text body">Both the classes must be rmic&rsquo;ed because although the generator has no interface as part of its own specialized behaviour, it does implement the <span class="T2">Prim</span> interface which may be access remotely &ndash; for example in the case of remote deployment.</p>
<p class="Text body">If either of the classes will never be remotely accessed &ndash; for example if the entire application will always be run in a single JVM &ndash; the <span class="code inline">rmic</span> steps may be skipped. In this case, the attribute <span class="T3">sfExport</span> must be set to <span class="T3">false</span><span class="T2"> </span>in the appropriate component descriptions. If this is not done, the SmartFrog system will attempt to load the stubs and skeletons for the classes and make the objects accessible remotely. </p>
<p class="Text body">Again, the stubs and skeletons have been pre-compiled and are in the jar file.</p>
<a name="N12BCB"></a><a name="The+Combined+Application"></a>
<h4>The Combined Application</h4>
<p class="Text body">Now that the various parts are defined and compiled it is possible to define a few applications, consisting of one or more generators and printers, deployed on one or more hosts, as required.</p>
<p class="Text body">Starting with the simplest, one of each on the same host:</p>
<p class="Code">#include <span class="T20">"</span>org/smartfrog/components.sf<span class="T20">"</span>
</p>
<p class="Code">#include <span class="T20">"</span>org/smartfrog/examples/helloworld/printer.sf<span class="T20">"</span>
</p>
<p class="Code">#include <span class="T20">"</span>org/smartfrog/examples/helloworld/generator.sf<span class="T20">"</span>
</p>
<p class="Code"></p>
<p class="Code">// the application must be called sfConfig</p>
<p class="Code">// a compound is a collection of components</p>
<p class="Code">sfConfig extends Compound {</p>
<p class="Code">g extends Generator {</p>
<p class="Code">messages [<span class="T20">"</span>hello<span class="T20">"</span>, <span class="T20">"</span>world<span class="T20">"</span>];</p>
<p class="Code">printer LAZY ATTRIB p; // link to the instance of the printer</p>
<p class="Code">}</p>
<p class="Code">p extends Printer {</p>
<p class="Code">name <span class="T20">"</span>myPrinter<span class="T20">"</span>;</p>
<p class="Code">}</p>
<p class="Code">}</p>
<p class="Text body">Note that the printer is given a name rather than using the name derived from the tree (which would be &ldquo;<span class="code inline">p</span>&rdquo; as the name is from, but not including, &ldquo;<span class="code inline">sfConfig</span>&rdquo;). The generator uses the default frequency of 10.</p>
<p class="Text body">The next example shows that it&rsquo;s possible to have more than one generator using the same printer:</p>
<p class="Code">#include "org/smartfrog/components.sf"</p>
<p class="Code">#include "org/smartfrog/examples/helloworld/printer.sf"</p>
<p class="Code">#include "org/smartfrog/examples/helloworld/generator.sf"</p>
<p class="Code"></p>
<p class="Code">// the application must be called sfConfig</p>
<p class="Code">// a compound is a collection of components</p>
<p class="Code">sfConfig extends Compound {</p>
<p class="Code">g1 extends Generator {</p>
<p class="Code">messages ["hello", "world"];</p>
<p class="Code">// link to the instance of the printer</p>
<p class="Code">printer LAZY ATTRIB p;</p>
<p class="Code">}</p>
<p class="Code">g2 extends Generator {</p>
<p class="Code">messages ["hello", "world", "again"];</p>
<p class="Code">frequency 5;</p>
<p class="Code">// link to the instance of the printer</p>
<p class="Code">printer LAZY ATTRIB p;</p>
<p class="Code">}</p>
<p class="Code">p extends Printer {</p>
<p class="Code">name "myPrinter";</p>
<p class="Code">}</p>
<p class="Code">}</p>
<p class="Text body">(In this case, there is a problem with termination that will be explained later.)</p>
<p class="Text body">A more complex example is one where we define a new component that consists of a printer and generator pair. This pair will print to each other, and the application consists of two of these pairs. </p>
<p class="P143">#include "org/smartfrog/components.sf"</p>
<p class="Code">#include "org/smartfrog/examples/helloworld/printer.sf"</p>
<p class="Code">#include "org/smartfrog/examples/helloworld/generator.sf"</p>
<p class="Code"></p>
<p class="Code">// a compound is a collection of components</p>
<p class="Code">Pair extends Compound {</p>
<p class="Code"></p>
<p class="Code">g extends Generator {</p>
<p class="Code">messages ["hello", "world"];</p>
<p class="Code">// link to the instance of the printer</p>
<p class="Code">printer LAZY ATTRIB p;</p>
<p class="Code">}</p>
<p class="Code">p extends Printer;</p>
<p class="Code">}</p>
<p class="Code">sfConfig extends Compound {</p>
<p class="Code">pair1 extends Pair;</p>
<p class="Code">pair2 extends Pair;</p>
<p class="Code last line">}</p>
<p class="Text body">In this case the printer component has not been given a name, so will use the one derived from the tree &ndash; <span class="T3">pair1:p</span> and <span class="T3">pair2:p</span> respectively. Each generator will find the associated printer, even though they are using the same link, because these links are resolved in different contexts.</p>
<p class="Text body">There is, however, a problem with this example and the previous one. Since the lifecycle of the whole application is connected, the first of the two generators to finish will cause the whole application to terminate even though the other may not have finished yet. This may be solved by the use of the workflow components, but this is not covered in this reference manual. </p>
<p class="Text body">Enriching the example a little further, the pair should optionally be parameterizable with the set of messages and the frequency, but without requiring the user to know the structure of the components contained within it.</p>
<p class="Code">#include "org/smartfrog/components.sf"</p>
<p class="Code">#include "org/smartfrog/examples/helloworld/printer.sf"</p>
<p class="Code">#include "org/smartfrog/examples/helloworld/generator.sf"</p>
<p class="Code"></p>
<p class="Code">Pair extends Compound { </p>
<p class="Code">// default value for param</p>
<p class="Code">messages ["this is a", "boring&rdquo;, "set of strings"];</p>
<p class="Code"></p>
<p class="Code">// ditto </p>
<p class="Code">frequency 10; </p>
<p class="Code"></p>
<p class="Code">g extends Generator {</p>
<p class="Code">// link to container&rsquo;s value</p>
<p class="Code">messages PARENT:messages;</p>
<p class="Code">// link to container&rsquo;s value</p>
<p class="Code">frequency PARENT:frequency; </p>
<p class="Code">// link to the instance of the printer</p>
<p class="Code">printer LAZY p;</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">p extends Printer;</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code"></p>
<p class="Code">sfConfig extends Compound {</p>
<p class="Code">pair1 extends Pair {</p>
<p class="Code">messages ["hello", "world&rdquo;, "again"];</p>
<p class="Code">}</p>
<p class="Code">pair2 extends Pair {</p>
<p class="Code">frequency 5;</p>
<p class="Code">}</p>
<p class="Code last line">}</p>
<p class="Text body">This example shows the use of the parameterization pattern described in section 4.</p>
<p class="Text body">The final example is one where the hosts on which various components are to be deployed may be modified. Taking the last example, we will enrich the notion of <span class="T2">pair</span> with two hosts &ndash; the printer host and the generator host, both defaulting to the local host.</p>
<p class="Text body">In the combination, we will put the printer of one pair and the generator of the other pair on one host, and the reverse on a second host.</p>
<p class="Code">#include "org/smartfrog/components.sf"</p>
<p class="Code">#include "org/smartfrog/examples/helloworld/printer.sf"</p>
<p class="Code">#include "org/smartfrog/examples/helloworld/generator.sf"</p>
<p class="Code"></p>
<p class="Code">Pair extends Compound { // a compound is a collection of components</p>
<p class="Code">printerHost "localhost";</p>
<p class="Code">generatorHost "localhost";</p>
<p class="Code"></p>
<p class="Code"></p>
<p class="Code">// default value for parameter messages</p>
<p class="Code">messages ["this is a", "boring&rdquo;, "set of strings"];</p>
<p class="Code"></p>
<p class="Code">// ditto </p>
<p class="Code">frequency 10; </p>
<p class="Code"></p>
<p class="Code">g extends Generator {</p>
<p class="Code">sfProcessHost generatorHost;</p>
<p class="Code">messages PARENT:messages; // link to container&rsquo;s value</p>
<p class="Code">frequency PARENT:frequency; // ditto</p>
<p class="Code">printer LAZY p; // link to the instance of the printer</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code">p extends Printer {</p>
<p class="Code">sfProcessHost printerHost;</p>
<p class="Code">}</p>
<p class="Code">}</p>
<p class="Code"></p>
<p class="Code"></p>
<p class="Code">sfConfig extends Compound {</p>
<p class="Code">hostA "foo.smartfrog.org";</p>
<p class="Code">hostB "bar.smartfrog.org";</p>
<p class="Code"></p>
<p class="Code">pair1 extends Pair {</p>
<p class="Code">printerHost hostA;</p>
<p class="Code">generatorHost hostB;</p>
<p class="Code">messages ["hello", "world&rdquo;, "again"];</p>
<p class="Code">}</p>
<p class="Code">pair2 extends Pair {</p>
<p class="Code">printerHost hostB;</p>
<p class="Code">generatorHost hostA;</p>
<p class="Code">frequency 5;</p>
<p class="Code">}</p>
<p class="Code last line">}</p>
<p class="Text body">By modifying the <span class="code inline">hostA</span> and <span class="code inline">hostB</span> attributes, different deployments may be obtained<span class="T20">.</span>
</p>
<p class="P25"></p>
<p class="P25"></p>
<p class="P25"></p>
<p class="P25"></p>
<p class="P25"></p>
</div>
<a name="N12DC0"></a><a name="Appendix+A."></a>
<h2 class="boxed">Appendix A.</h2>
<div class="section">
<a name="N12DC5"></a><a name="Exit+Codes+for+SmartFrog+Scripts"></a>
<h3 class="boxed">Exit Codes for SmartFrog Scripts</h3>
<p class="Code last line">0 - Success</p>
<p class="Code last line">1 - General Errors</p>
<p class="Code last line">69 - Bad Arguments input to Script</p>
<p class="Code last line">130 - Script terminated by Control-C</p>
</div>
</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2005 Hewlett Packard Company</div>
<div class="host">
<a href="http://sourceforge.net/projects/smartfrog"><img class="logoImage" alt="" src="images/sourceforge.gif"></a>
</div>
</div>
</body>
</html>
