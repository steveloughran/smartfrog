<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Shell Scripts and Process Management with SmartFrog</title>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="breadtrail">
<script src="skin/breadcrumbs.js" language="JavaScript" type="text/javascript"></script>
</div>
<div class="header">
<div class="grouplogo">
<a href="http://www.SmartFrog.org/"><img class="logoImage" alt="SmartFrog" src="images/group.png" title="SmartFrog"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.SmartFrog.org"><img class="logoImage" alt="" src="images/frog.gif"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="index.html">Home</a>
</li>
<li>
<a class="base-not-selected" href="sfcore.html">SmartFrog Core</a>
</li>
<li>
<a class="base-not-selected" href="comp.html">Components</a>
</li>
<li>
<a class="base-not-selected" href="anttasks.html">Ant Tasks</a>
</li>
<li>
<a class="base-not-selected" href="extras.html">Extras</a>
</li>
<li>
<a class="base-not-selected" href="examples.html">Examples</a>
</li>
<li>
<a class="base-not-selected" href="jdocs_index.html">Java Docs</a>
</li>
<li>
<a class="base-not-selected" href="Copyright.html">Copyright</a>
</li>
<li>
<a class="base-not-selected" href="lpgl.html">License Terms</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="content">
<h1>Shell Scripts and Process Management with SmartFrog</h1>
<div class="abstract"></div>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Introduction">Introduction</a>
</li>
<li>
<a href="#Common+Component+Aspects">Common Component Aspects</a>
</li>
<li>
<a href="#Process+management">Process management</a>
</li>
<li>
<a href="#Shells">Shells</a>
</li>
<li>
<a href="#Scripts">Scripts</a>
</li>
</ul>
</div>
<p class="P1"></p>
<p class="instruction"></p>
<p class="P3">Shell Scripts and</p>
<p class="P3">Process Management</p>
<p class="P3">with SmartFrog</p>
<p class="P4"></p>
<p class="P4"></p>
<p class="P4">version 1.0</p>
<p class="P5">16<span class="T1">th</span> May, 2005</p>
<p class="P6"></p>
<p class="P7"></p>
<p class="P8"></p>
<p class="Heading">Table Of Contents</p>
<p class="Text body"></p>
<p class="P11"></p>
<a name="N10034"></a><a name="Introduction"></a>
<h2 class="boxed">Introduction</h2>
<div class="section">
<p class="P13">SmartFrog is a framework for writing distributed configuration systems, configuring nodes or other devices as determined by a description of the desired state of the system. As such, whether the system being configured is a Windows platform, a Linux platform or some other operating environment, much of the low level tasks to be carried out will involve executing commands or running daemons of the underlying operating system to achieve the desired configuration. This report shows how the SmartFrog system can make this process easy through the use of the process management and shell scripting components provided as part of the core release.</p>
<p class="P13">Note that this document assumes a working knowledge of SmartFrog; if basic knowledge of this is required, the tutorial and reference manuals should provide the kind of information required.</p>
<p class="P13">It is always possible for a component programmer to resort to the use of the Java command execution libraries, however these are not easy to use. Better is to provide a series of components that are heavily tested and hide much of the unpleasantness of dealing with processes and shells, making for a quicker and more reliable way to handle many configuration tasks. </p>
<p class="P13">The document does not deal with how to write well-formed components that interact directly through the Java libraries to create processes or shells. This is not easy, due to the complexity of the model provided in these libraries.</p>
<p class="P13">The document is structured into three main sections: </p>
<ol>
<li>
<p class="P14">process management: how to run a process using the process management component, </p>
</li>
<li>
<p class="P14">shells: how to run a a specific shell (a special case of a process) and interact with it in a form more suited to shells,</p>
</li>
<li>
<p class="P14">scripts: how to represent interactions with a shell as a component.</p>
</li>
</ol>
<p class="P13">In each case, as appropriate, the discussion of each aspect is split into two parts: the component model and the programming model. The first, the component model, shows how to describe a component so that it may be deployed and configured as required. The second, the programming model, examines how a component can be written that interacts through interfaces exported by the components. Scripts do not export an interface, so this is not appropriate for this component.</p>
<p class="P13">Before this discussion, there is a section covering some of the general aspects of writing components and those parts that are common between these three component types.</p>
</div>
<a name="N1005B"></a><a name="Common+Component+Aspects"></a>
<h2 class="boxed">Common Component Aspects</h2>
<div class="section">
<p class="Text body">This section covers some of the general points around the description of the components and their semantics.</p>
<p class="Heading 2">Logging</p>
<p class="Text body">All the components log their activity to a log interface. They use the logging sfLog() method with the default logger. A specific named logger can be used by defining the sfLog attribute to the name of that logger.</p>
<p class="Text body">The log messages themselves contain an identifier for the component that is issuing each log message. By default this is the sfCompleteName() of the component but if a different name is required, this can be set by providing the optional &ldquo;name&rdquo; attribute.</p>
<p class="Heading 2">Commands</p>
<p class="Text body">An important concept to grasp is the uniform way in which these components represent processes to manage &ndash; this is used directly by the user when configuring the process management components, but is also used to describe the shell process (but not the commands sent to the shell) in the shell component. In the latter case, normally users will not see this as descriptions have been provided for many of the common shells &ndash; such as Bash under Linux and the Windows CMD shell under XP &ndash; which have these predefined.</p>
<p class="Text body">A command may have a number of attributes:</p>
<p class="P15">the working directory</p>
<p class="P15">a set of environmental variables</p>
<p class="P15">the command to be executed</p>
<p class="Text body">These are described according to the following schema, and basic wrapping component. These are defined in a file contained in sfServices.jar:, namely &ldquo;org/smartfrog/services/shellscript/components.sf&rdquo;</p>
<p class="sf">// schema and core component for a command</p>
<p class="sf">ExecSchema extends Schema {</p>
<p class="sf">cmd extends Vector;</p>
<p class="sf">dir extends OptionalString;</p>
<p class="sf">envProperties extends OptionalVector;</p>
<p class="sf">}</p>
<p class="sf"></p>
<p class="sf">Exec extends LAZY {</p>
<p class="sf">execSchema extends ExecSchema;</p>
<p class="sf">}</p>
<p class="sf"></p>
<p class="Text body">The working directory (dir) is a string representing the directory name, the environment is a vector of strings, each representing a variable binding (see example below) and the command is a vector of strings, each representing one token of the command-line (again see example).</p>
<p class="Text body">Given this, an example of a valid command might be:</p>
<p class="sf">// example of the use of a command</p>
<p class="sf">#include &ldquo;.../shellscript/components.sf&rdquo;</p>
<p class="sf"></p>
<p class="sf">myProcess extends Process {</p>
<p class="sf">exec extends LAZY Exec {</p>
<p class="sf">workingDirectory &ldquo;.&rdquo;;</p>
<p class="sf">envProperties [&ldquo;sfHome=/usr/sf&rdquo;, &ldquo;tempDir=/tmp&rdquo;];</p>
<p class="sf">cmd [&ldquo;sfStart&rdquo;, &ldquo;localhost&rdquo;, &ldquo;foo&rdquo;, &ldquo;foobar.sf&rdquo;];</p>
<p class="sf">}</p>
<p class="sf">}</p>
<p class="sf"></p>
<p class="Text body">Now a description of a command is always data, not a component definition, so it will always occur as an &ldquo;extends LAZY&rdquo; (or &ldquo;extends DATA&rdquo;). Furthermore, in both the process management component and the shell component, the attribute which holds the command definition is called &ldquo;exec&rdquo; as in the example above.</p>
<p class="Heading 2">Command Exists</p>
<p class="Text body">The process manager and the shell, the two components that manage processes as determined by the command descriptions, both track the status of their process. They both provide attributes as part of the component context which describe the current state:</p>
<ul>
<li>
<p class="P16">execExitCode &ndash; the exit code of the command the last time the process exited (died). </p>
</li>
<li>
<p class="P16">numberOfExecs &ndash; the number of times that the process has been started</p>
</li>
<li>
<p class="P16">execExitCodes &ndash; a vector of integers, in the 0<span class="T1">th</span> position is the number of execs, and in all others (if they exist) the exit codes of all the process exit codes in order.</p>
</li>
</ul>
<p class="Text body">In actual fact, these attributes are only useful if the description of the process management indicates that the process should be restarted (or at least not terminated) on process failure, and this never happens in the case of a shell. However, initial values of these attributes do appear it the run-time context of the shell component, hence the need to document their existence.</p>
</div>
<a name="N100E2"></a><a name="Process+management"></a>
<h2 class="boxed">Process management</h2>
<div class="section">
<p class="Text body">The process management component provides a simple management model for processes, with the ability to access the various I/O streams of the process through a local Java interface. In its most basic form, the control of the process is a simple definition of the command to execute and a set of attributes that control how the life cycle of the component mirrors (or otherwise) by the life cycle of the process it is managing.</p>
<p class="Heading 2">The component model</p>
<p class="Text body">The ProcessManager component has the following schema and basic default component.</p>
<p class="sf">// schema and wrapping component</p>
<p class="sf">ProcessSchema extends Schema {</p>
<p class="sf">detach extends OptionalBoolean;</p>
<p class="sf">restart extends OptionalBoolean;</p>
<p class="sf">terminate extends OptionalBoolean;</p>
<p class="sf">autoStart extends OptionalBoolean;</p>
<p class="sf">string extends OptionalString;</p>
<p class="sf">}</p>
<p class="sf"></p>
<p class="sf"></p>
<p class="sf">Process extends Prim {</p>
<p class="sf">execShema extends ProcessSchema;</p>
<p class="sf">sfClass "...shellscript.SFProcessExecutionImpl";</p>
<p class="sf">//retart false;</p>
<p class="sf">//terminate false;</p>
<p class="sf">//detach false;</p>
<p class="sf">//auotStart true;</p>
<p class="sf"></p>
<p class="sf">exec extends LAZY Exec;</p>
<p class="sf">sfExport false;</p>
<p class="sf">}</p>
<p class="Text body"></p>
<p class="Text body">The component starts the process by executing the command &ndash; it does this during the sfDeploy phase of the life cycle. If, at any time, the process should terminate, the following actions will be taken.</p>
<p class="Text body">if restart is true, the process will be restarted if it ever fails unexpectedly, if it is false it will be left dead until told (programmatically) to restart. (Default false.) Note that the component does not deal properly with repeat failures within a short time interval &ndash; in other words, currently the component will simply continue to try to restart the process every time a failure occurs. There is no limit which would cause an alternative action &ndash; such as component termination.</p>
<ol>
<li>
<p class="P17">If terminate is true, the component managing the process will carry out an abnormal termination if the process fails &ndash; this dominates over any restart that may be required. If it is false, it will not terminate but remain in existence, restarting the process if this is appropriate (Default: true.) </p>
</li>
<li>
<p class="P17">if detach is true, the component detaches itself from the parent before any abnormal termination. If false, any termination will propagate to the parent component if one exists. (Default false.)</p>
</li>
<li>
<p class="P17">if autoStart is set to false, the process will not start automatically at the time of deploying the component, but it will need to be started using the programmatic interface. If true, it will start automatically (Default true).</p>
</li>
</ol>
<p class="Text body">Note that unless the programmatic interface is in use, the component by default logs all the output from the process to the components standard log. This can be set as normal by using the sfLog attribute.</p>
<p class="Text body">Note that the shell component must not be exported to RMI as it has a non-remote interface that has to be accessed through linking. This means that there are some restrictions in the use of a shell. In particular, if it is to be deployed remotely, it must be wrapped in a remotable component such as a Compound. Secondly, some of the remote management components may not work correctly &ndash; typically generating a serialization exception when they try to obtain a remote reference.</p>
<p class="Heading 2">The programming model</p>
<p class="Text body">The component offers a simple interface to control the process managed by the process. This interface is defined as follows.</p>
<p class="sf">package org.smartfrog.services.shellscript;</p>
<p class="sf"></p>
<p class="sf">import java.io.InputStream;</p>
<p class="sf">import java.io.OutputStream;</p>
<p class="sf"></p>
<p class="sf">public interface SFProcessExecution extends SFExecution {</p>
<p class="sf">public InputStream getStdOutStream();</p>
<p class="sf">public InputStream getStdErrStream();</p>
<p class="sf">public OutputStream getStdInpStream();</p>
<p class="sf">public void kill();</p>
<p class="sf">public void restart();</p>
<p class="sf">public boolean isRunning();</p>
<p class="sf">}</p>
<p class="sf"></p>
<p class="Text body">This methods have the following effect on the underlying semantics of the component. Starting with the two process control methods:</p>
<ul>
<li>
<p class="P18">The process kill method terminates the process in a controlled way &ndash; this is not considered to be a failure and so the life cycle attributes are not used at this point.</p>
</li>
<li>
<p class="P18">The process restart method will kill the process is necessary, then (re)run the command as in the initial deploy. Failure of this will be treated as any other failure in the process.</p>
</li>
<li>
<p class="P18">The isRunning method returns a boolean describing whether the subprocess is running or not (terminated, failed or not started).</p>
</li>
</ul>
<p class="Text body">The get stream methods enable another component to interact with the process to signal it in some way, or to monitor its output to identify some events. Using them can be dangerous and difficult, and in particular if the stdOut and stdErr streams are accessed, the user must make sure that they are continuously emptied of data otherwise JVM lock-up can occur. If the streams are never obtained, the component creates threads that empty the streams and log the output found, once the streams have been obtained, control of them can never be regenerated.</p>
<p class="Text body">Note that the failure (or other termination) of a process will result in the streams closing and the waiting threads being notified with an InterruptedIOException. At this point if the process is restarted, either by the process manager or by another component via the restart method described above, the new streams must be obtained and handled properly as described above. The component does not create new handlers for these streams.</p>
<p class="Text body">Other data, such as the exit codes of the process if it fails, can be obtained by resolving references to the attributes execExitCode et al. As described above.</p>
</div>
<a name="N1018D"></a><a name="Shells"></a>
<h2 class="boxed">Shells</h2>
<div class="section">
<p class="Text body">A specific type of process which is particularly useful for many configuration tasks is the shell component and the related component that has been created to submit scripts to the shell.</p>
<p class="Text body">The shell component differs from a normal process component in that rather than accessing the streams directly, the script component (or any other component wishing to send scripts to the shell) use a command-based interface &ndash; submitting a set of command lines, and receiving back the associated lines of output. This is done using an asynchronous model of submitting lines to be executed and later being able to collect or wait for the results.</p>
<p class="Text body">Unlike the generic process component, the shell component fixes some of the options. For example, it always starts the shell on component deployment and it always terminates if the shell exits. The rationale for this is that a shell carries state from previous scripts &ndash; for example the definition of environmental variables. Consequently, restarting a shell can lead to errors. If restarting is required, the shell can be wrapped in a restarting work flow component. Also, the component never detaches itself on termination, but will always propagate its failure.</p>
<p class="Heading 2">The component model</p>
<p class="Text body">The shell component defines the shell command that runs the shell process it is managing. In addition, it has a small number of additional attributes, mostly to do with differences between different shells running on different platforms.</p>
<p class="Text body">The model for the component is that it can be given a number of scripts to run by either using the programmatic interface or using the Script component described below. In order to identify the boundary of the output of the various scripts, the component adds an &ldquo;echo&rdquo; command between them. The output of this echo is determined by the component and it uses this to recognize these boundaries of the shell output. In addition, in order to extract the termination code of the last command, the component needs to be given the definition of the environment variable that does so - this is used in the delimiting echo to extract this.</p>
<p class="Text body">Users need not be aware of the most common instances of these, as some predefined shell component descriptions are provided with the core definition. However, should a new shell be encountered, this may be set in the configuration description of a shell component.</p>
<p class="Text body">The schema for this divided up as follows:</p>
<ol>
<li>
<p class="P19">define the exec structure for the desired shell (examples here of Bash and the WinXP cmd shell.</p>
</li>
<li>
<p class="P19">define a shell as a prim parameterized by the appropriate exec for the shell.</p>
</li>
</ol>
<p class="sf">ShellExecSchema extends ExecSchema {</p>
<p class="sf">lineSeparator extends OptionalString;</p>
<p class="sf"></p>
<p class="sf">echoCmd extends OptionalString;</p>
<p class="sf">echoErrorCmd extends OptionalString;</p>
<p class="sf">}</p>
<p class="sf"></p>
<p class="sf">ShellExec extends Exec {</p>
<p class="sf">execShema extends ShellExecSchema;</p>
<p class="sf">echoCmd "echo";</p>
<p class="sf">}</p>
<p class="sf"></p>
<p class="sf">BashExec extends ShellExec{</p>
<p class="sf">cmd ["/etc/bash"];</p>
<p class="sf">echoErrorCmd "$?";</p>
<p class="sf">}</p>
<p class="sf"></p>
<p class="sf">WinXPExec extends ShellExec {</p>
<p class="sf">cmd ["cmd.exe"];</p>
<p class="sf">echoErrorCmd "%ERRORLEVEL%";</p>
<p class="P20">}</p>
<p class="P21"></p>
<p class="Text body">Note that a shell exec structure is extended by a number of additional attributes, in particular the concept of an line separator (by default obtained from the Java properties relating to the local platform, but it can be set explicitly), an echoCmd which defines a shell command that echoes to stdout a given string, and a echoErrorCmd string which, when echoed using the shell, returns the exit code of the last command executed.</p>
<p class="Text body">Given these, it is possible to define the second part, the specific shells.</p>
<p class="sf">ShellSchema extends Schema {</p>
<p class="sf">name extends OptionalString;</p>
<p class="sf">ID extends Long;</p>
<p class="sf">exec extends CD;</p>
<p class="sf">}</p>
<p class="sf"></p>
<p class="sf">Shell extends Prim {</p>
<p class="sf">shellSchema extends ShellSchema;</p>
<p class="sf">sfClass "...shellscript.SFScriptExecutionImpl";</p>
<p class="sf">exec extends LAZY Exec;</p>
<p class="sf">sfExport false;</p>
<p class="sf">}</p>
<p class="sf"></p>
<p class="sf">BashShell extends Shell {</p>
<p class="sf">exec extends LAZY BashExec;</p>
<p class="sf">}</p>
<p class="sf"></p>
<p class="sf">WinXPShell extends Shell {</p>
<p class="sf">exec extends LAZY WinXPExec;</p>
<p class="sf">}</p>
<p class="Text body"></p>
<p class="Text body">Note that the shell component must not be exported to RMI as it has a non-remote interface that has to be accessed through linking. This means that there are some restrictions in the use of a shell. In particular, if it is to be deployed remotely, it must be wrapped in a remotable component such as a Compound. Secondly, some of the remote management components may not work correctly &ndash; typically generating a serialization exception when they try to obtain a remote reference.</p>
<p class="Text body">This schema defines all the fields required for specialization of the component in various ways:</p>
<ul>
<li>
<p class="P22">the cmd attribute is used to define the program that will be run as part of the component (in most cases this will be a shell).</p>
</li>
<li>
<p class="P22">The dir attribute defines the working directory for the command</p>
</li>
</ul>
<ul>
<li>
<p class="P23">the envProperties defines environmental properties that should exist in the environment in which the shell should execute</p>
</li>
<li>
<p class="P23">the line separator defines the characters to be used to separate the data sent to the program through the standard input (in most cases the commands sent to the shelll). If not provided, this is obtained from the Java system property &ldquo; line.separator&ldquo; set on each platform.</p>
</li>
</ul>
<p class="Heading 2">The programming model</p>
<p class="Text body">This is the most complex part of the use of the built-in shell script support within SmartFrog. If appropriate it is in general easier to use the Script component described below, though it is not always sufficient.</p>
<p class="Text body">The shell component provides a local interface &ldquo;..shellscript.ScriptExecution&rdquo;. This interface provides a line-oriented command interface to the shell component. Many components may use the shell to interleave their commands, with a locking mechanism provided to ensure that the sets of commands that must be implemented without interleaving can be guaranteed.</p>
<p class="Text body">The model is asynchronous, in that a set of commands can be submitted to the shell, then at a later time the submitter may wait for the results or see if the results are ready .</p>
<p class="Text body">The basic interface is defined as follows:</p>
<p class="sf">public interface ScriptExecution {</p>
<p class="sf">public ScriptLock lockShell(long timeout) </p>
<p class="sf">throws SmartFrogException;</p>
<p class="sf"></p>
<p class="sf">public ScriptResults execute(List commands,</p>
<p class="sf">ScriptLock lock) </p>
<p class="sf">throws SmartFrogException;</p>
<p class="sf"></p>
<p class="sf">public ScriptResults execute(String command, </p>
<p class="sf">ScriptLock lock) </p>
<p class="sf">throws SmartFrogException;</p>
<p class="sf"></p>
<p class="sf">public void releaseShell(ScriptLock lock)</p>
<p class="sf">throws SmartFrogException;</p>
<p class="sf"></p>
<p class="sf"></p>
<p class="sf"></p>
<p class="sf">public ScriptResults execute(List commands,</p>
<p class="sf">long timeout)</p>
<p class="sf">throws SmartFrogException;</p>
<p class="sf"></p>
<p class="sf">public ScriptResults execute(String command,</p>
<p class="sf">long timeout) </p>
<p class="sf">throws SmartFrogException;</p>
<p class="sf">}</p>
<p class="Text body"></p>
<p class="Text body">The interface can be divided into two groups &ndash; the first four methods use the shell locking mechanism, whereas the last two are single atomic actions on the shell. In both cases, the interface supports either supplying a single command or a list of commands, each of which will be separated in the shell by the lineSeparator character.</p>
<p class="Text body">Note that in all cases, submitting a command (using one of the execute methods) consists of adding the command to the stdIn queue of the shell process, and that the fact that the method that submits a command returns in no way implies that the shell has started to execute the command. Indeed in general it may be queued behind a number of other commands from previous invocations of the execute methods. Furthermore, the method may block until the stream has room for the command to be added. This is not included in the timeouts associated with obtaining a lock.</p>
<p class="Text body">The model for use of the locking methods is to request a lock, submit one or more execute commands (either single or list), then release the lock. In the execute methods and the release lock method, the correct lock-object must be provided to ensure that method is being associated with the right lock operation.</p>
<p class="Text body">An example code snippet is as follows:</p>
<p class="sf">import ...shellscript.ScriptExecution;</p>
<p class="sf">import ...shellscript.ScriptResults;</p>
<p class="sf">import ...shellscript.ScriptLock;</p>
<p class="sf"></p>
<p class="sf">/* </p>
<p class="sf">* get an instance of a script component (e.g. via a LAZY</p>
<p class="sf">* link; in this example the attribute &ldquo;shell&rdquo;</p>
<p class="sf">*/</p>
<p class="sf">ScriptExecution se = </p>
<p class="sf">(ScriptExection) sfResolveHere(&ldquo;shell&rdquo;);</p>
<p class="sf"></p>
<p class="sf"></p>
<p class="sf">/*</p>
<p class="sf">* obtain the lock, run a set of commands,</p>
<p class="sf">* release the lock</p>
<p class="sf">*/</p>
<p class="sf">try {</p>
<p class="sf">ScriptLock sl = es.lockShell(-1);</p>
<p class="sf">ScriptResults res1 = se.execute(&ldquo;aVar=*.jar&rdquo;, sl);</p>
<p class="sf">ScriptResults res2 = se.execute(&ldquo;aCommand $aVar&rdquo;, sl);</p>
<p class="sf">} finally {</p>
<p class="sf">if (sl != null) se.releaseShell(sl);</p>
<p class="sf">}</p>
<p class="sf"></p>
<p class="sf">/* run a single command */</p>
<p class="sf">ScriptResults res3 = es.execute(&ldquo;someCommand&rdquo;, -1);</p>
<p class="Text body"></p>
<p class="Text body">Note that in the lockShell method and the single command execute method there is a timeout. This timeout is simply to obtain the lock (implicit in the single method execute), not to start executing the command. The values for the timeout are 0: immediate or throw an exception, -1: wait forever if necessary, anything else is waiting for a maximum of the specified number of milliseconds. The example above will wait forever for the lock to be released.</p>
<p class="Text body">As the lock is not automatically released if an exception is generated, the releaseLock should be called within a &ldquo;finally&rdquo; clause to ensure that it is released.</p>
<p class="Text body">Given that the command is submitted to the shell (though possibly queued behind others) when the execute method is complete, the next issue is how to collect the output of the commands.</p>
<p class="Text body">Internally, the shell component adds an echo command between each execute method command or list of commands. In this way it can recognize the boundary of the output data that is generated by each individual execute method call. </p>
<p class="Text body">This data is collected into two lists of strings, one string per line of output, one list for each of the two output streams. Also, the command boundary echo obtains the exit code for the last of the commands executed as part of that execute method. Both of these lists and that exit code can be obtained from the ScriptResult object.</p>
<p class="Text body">However, the object does not necessarily have the results ready immediately &ndash; they may finally be available at some point in the future after the commands reach the front of the shell's buffer and execute. Consequently, the programming model provides two methods: waiting for the results to be available, with a timeout, or inspecting whether they are ready yet.</p>
<p class="Text body">This is defined in the interface ScriptResults:</p>
<p class="sf">public interface ScriptResults {</p>
<p class="sf">public boolean resultsReady();</p>
<p class="sf"></p>
<p class="sf">public ComponentDescription waitForResults(long timeout) </p>
<p class="sf">throws SmartFrogException;</p>
<p class="sf">}</p>
<p class="Text body"></p>
<p class="Text body">As with the execute methods, the timeouts are 0: immediate return, -1: wait forever, other values in milliseconds.</p>
<p class="Text body">The component description returned contains the data from the result, in appropriately named attributes, These attributes are:</p>
<ul>
<li>
<p class="P24">code &ndash; the result code of the last line of the commands</p>
</li>
<li>
<p class="P24">stdout &ndash; the list of lines output onto stdout by this set of commands</p>
</li>
<li>
<p class="P24">stderr &ndash; the list of lines output onto stderr by this set of commands</p>
</li>
</ul>
<p class="Text body">Note that due to the way in which the output from the various commands are delinieated (using an echo), and command which results in a background task may have its output appended to the wrong ScriptResult(s).</p>
<p class="Text body">An example of a code snippet to make use of the results, following on from the previous example, is as follows:</p>
<p class="sf">// wait forever for the script to execute and complete</p>
<p class="sf">ComponentDescription res = res1.waitForResults(-1);</p>
<p class="sf"></p>
<p class="sf">if (res.sfResolve(&ldquo;code&rdquo;, 0, true) == 0) {</p>
<p class="sf"></p>
<p class="sf">// the script completed properly (code 0)</p>
<p class="sf">if (((List)res.sfResolve(&ldquo;stderr&rdquo;)).size() == 0) {</p>
<p class="sf"></p>
<p class="sf">// there was no error output</p>
<p class="sf">List stdout = (List)res.sfResolve(&ldquo;stderr&rdquo;);</p>
<p class="sf">for (Iterator lines = stdout.iterator(); ....) {</p>
<p class="sf">// print each output line</p>
<p class="sf">System.out.println(lines.next());</p>
<p class="sf">}</p>
<p class="sf"></p>
<p class="sf">} else {</p>
<p class="sf">// there was some error output</p>
<p class="sf">throw ...</p>
<p class="sf">}</p>
<p class="sf"></p>
<p class="sf">} else { </p>
<p class="sf">// the script failed</p>
<p class="sf">throw ...</p>
<p class="sf">}</p>
<p class="Text body"></p>
<p class="Text body">Clearly the result processing could be quite complex, with the likely need to pattern-match over possible error messages, non-zero codes indicating possible errors, and so on. However this complexity is purely dependent on the complexity of the application's scripts and there is little that the supporting componentry can do to ease this. It is easier, however, than hooking directly into the streams of a process or having to do the management of the process oneself.</p>
</div>
<a name="N1037F"></a><a name="Scripts"></a>
<h2 class="boxed">Scripts</h2>
<div class="section">
<p class="Text body">A script is an easy component-oriented way of using the shell component which avoids the use of the programming interface. Indeed the scripts to execute are simply strings, or lists of strings, given as attributes to the component. Furthermore, the component can be used as a traditional component with the ability to run scripts during each of its life cycle phases, or it can be used as part of a work flow &ndash; running a script and then terminating.</p>
<p class="Text body">A script component does not offer any run-time interface to other components, it is merely a component wrapper for the programming model provided by the shell to which it it linked.</p>
<p class="Heading 2">The component model</p>
<p class="Text body"></p>
<p class="Text body">In additiion to the definition of the &ldquo;scriptExectution&rdquo; attribute which is a lazy reference to the shell component, the component defines three script attributes: &ldquo;deployScript&rdquo;, &ldquo;startScript&rdquo; and &ldquo;terminateScript&rdquo;. Each of these is a vector of commands to send to the shell during the associated lifecycle phase. In addition, a boolean attribute &ldquo;autoTerminate&rdquo; can be set to true if the component should automatically self-terminate after the sfStart phase &ndash; this is useful in a workflow.</p>
<p class="Text body">The definitions in the components.sf file is as follows:</p>
<p class="sf">/** schema for the script component */</p>
<p class="sf">// first the schema for a single script entry</p>
<p class="sf">OptionalScript extends Optional {</p>
<p class="sf">class ["java.lang.String",</p>
<p class="sf">"java.util.Vector",</p>
<p class="sf">"...componentdescription.ComponentDescription"];</p>
<p class="sf">}</p>
<p class="sf"></p>
<p class="sf">// now the full schema with its set of lifecycle scripts</p>
<p class="sf">ScriptSchema extends Schema {</p>
<p class="sf">shell extends Reference;</p>
<p class="sf"></p>
<p class="sf">deployScript extends OptionalScript;</p>
<p class="sf">startScript extends OptionalScript;</p>
<p class="sf">terminateScript extends OptionalScript;</p>
<p class="sf"></p>
<p class="sf">autoTerminate extends Boolean;</p>
<p class="sf">}</p>
<p class="sf"></p>
<p class="sf">Script extends Prim {</p>
<p class="sf">schema extends ScriptSchema;</p>
<p class="sf">autoTerminate false;</p>
<p class="sf">}</p>
<p class="Text body"></p>
<p class="Text body">Given these definitions, the semantics are:</p>
<ul>
<li>
<p class="P25">During the relevant lifecycle, the commands defined (if any) in the appropriate attribute are executed by the shell to completion. </p>
</li>
<li>
<p class="P25">If, whist executing the deploy or start scripts the exit code for the last command is 0, the vector of commands is assumed to have executed correctly. If it is other than 0, a termination is triggered to indicate that an error occurred in the execution of the script.</p>
<p class="P25">This will terminate the component in the way that a lifecycle method failing would do in any other component. The resultant abnormal termination record will contain details of the script execution. The error is also logged.</p>
</li>
<li>
<p class="P25">If an error occurs during the termination script, no action is taken (apart from logging the error).</p>
</li>
<li>
<p class="P25">If the autoTerminate attribute is true, after executing the start script the component will terminate with a normal termination record.</p>
</li>
</ul>
<p class="Text body">Now the definition of a script needs some explanation. A script can come in three forms: </p>
<ol>
<li>
<p class="P26">a string, which is the command to send to the shell</p>
</li>
<li>
<p class="P26">a vector of strings, sent in one locked interaction, with each string being a single command.</p>
</li>
<li>
<p class="P26">a component description, with each attribute being a string, or a vector of strings or indeed a component description. The description is traversed top-down, depth-first. The whole is considered as a single locked </p>
</li>
</ol>
<p class="Text body">An example of the use of the Script component in use in conjunction with the required shell script component is shown below</p>
<p class="P27"></p>
<p class="P27">#include &ldquo;org/smartfrog/services/shellscript/components.sf&rdquo;;</p>
<p class="P27"></p>
<p class="P27">sfConfig extends Compound {</p>
<p class="P27">aShell extends BashShell;</p>
<p class="P27">dns extends Script {</p>
<p class="sf">shell LAZY aShell;</p>
<p class="P27">deployScript [&ldquo;/usr/bin/named ...&rdquo;];</p>
<p class="P27">terminateScript [&ldquo;killall named&rdquo;];</p>
<p class="P27">}</p>
<p class="P27">dhcp extends Script {</p>
<p class="P27">shell LAZY aShell;</p>
<p class="P27"> deployScript [&ldquo;...&rdquo;];</p>
<p class="P27">terminateScript [&ldquo;...&rdquo;];</p>
<p class="P27">}</p>
<p class="P27">}</p>
<p class="Text body"></p>
<p class="Text body">Note that the two script components assume that they are deployed after the shell component to ensure that the script is already executing by the time the scripts are run. Also, the shell and the scripts must be on the same host since the interface offered by the shell is local only.</p>
<p class="Heading 2"></p>
<p class="Text body"></p>
<p class="P13"></p>
</div>
</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2005 Hewlett Packard Company</div>
<div class="host">
<a href="http://sourceforge.net/projects/smartfrog"><img class="logoImage" alt="" src="images/sourceforge.gif"></a>
</div>
</div>
</body>
</html>
