\section{The Fundamental Flaws of JAX-RPC}
\label{objections}

\subsection{The O/X Mapping Problem}
\label{objections:o-x}

O/X mapping\footnote{Object-XML mapping} attempts to turn an XML
document into Java classes derived from the type information attached
to nodes. This is distinct from the type of mapping performed by
DOM\footnote{Document Object Model} implementations, in that the
classes are ``serialised'' from the XML tree, not merely created to
represent it (it is a semantic rather than syntactic mapping).  O/X
mapping is an essential part of JAX-RPC, allowing method calls to be
translated into SOAP requests, and responses translated back into Java
objects.

We chose the term \emph{O/X mapping problem} to emphasise the
similarities it has with the heavily studied O/R mapping
problem\footnote{ \emph{"Object-relational mapping is the Vietnam of
Computer Science"} - Ted Neward. He means that it's a problem you can
never declare victory over, merely invest more and more effort in to
get deeper into the quagmire.
%{\small \tt http://www.neward.net/ted/weblog/index.jsp?date=20041003#1096871640048}
}.  There is less experience in mapping between XML and objects, and
rather than drawing on the experiences of the many failed attempts at
O/R mapping, O/X mapping technologies appear destined to share a
similar evolution.

At first glance, O/X mapping appears simple: create a Java object
for each XML element, building a DAG\footnote{directed, acyclic graph}
when serializing to rpc/encoded SOAP or a tree with doc/lit
messages. Read or write between attributes and class fields, bind to
children and the conversion is complete. If only it were so
straightforward. Here are just some of the problems:

\todo{Is this list really exhaustive?}

\begin{itemize}

\item Mapping between Java classes and XML elements. This can be
particularly difficult with document/literal messages, where the type
is omitted.

\item Mapping from XML names to valid Java names: the set of legal
identifiers differs between Java and XML.

\end{itemize}

\subsubsection{XML Elements and Java Classes}
\label{objections:o-x:xml-classes}

The language of XML schema is much richer than the object model of
Java. In Java, inheritance can extend a type, and change some existing
semantics, but derivation by restriction is not explictly
supported. Java, in common with many object oriented programming
environments, allows derived types to expand upon the capabilities of
their parents, but not to decrease them.

In the XML schema language, it is natural to declare that a dog is a
mammal with four legs, and that a three legged dog is a restriction
where the number of legs must be three. In Java this type of
relationship cannot be explicitly modelled. \tocheck{As a more concrete
example, consider declaring that a {\tt Shape} has a {\tt getArea()}
method, and that a {\tt Point} is a {\tt Shape} without such a method}.

\todo{This section would benefit from a discussion of why the
fundamental differences in the type systems of the two representations
mean that mappings, if achieved, will always be unstable. Some of the
enumeration discussion below could migrate in here, but the
enumeration discussion doesn't perhaps go far enough.}

\subsubsection{Mapping XML QNames to Java Identifiers}
\label{objections:o-x:names}

\todo{Need to discuss the particular difficulties involved in mapping
XML QNames to Java identifiers, this will set the scene for the
following discussion of enumerations}.

One specific example that deserves special mention is how
\verb$xsd:enumeration$ declarations are mapped to Java. Prior to
Java1.5, there was no explict \verb$enum$ clause in the language, so
workarounds were developed. The JAX-RPC solution is that of a common
pattern: to declare a class with a public static instance representing
a valid enumeration value. The WSDL to Java code generates such a
class, with the name of each static class taken from the name of each
value in the enumeration.

This is a simple example of how O/X mapping should work. Except, what if the
value of the one of the enumeration types is a reserved word, such as in the
lifecycle state machine we wrote:

\begin{verbatim}
<xsd:simpleType name="lifecycleStateEnum">
  <xsd:restriction base="xsd:string"> 
    <xsd:enumeration value="initialized"/> 
    <xsd:enumeration value="running"/> 
    <xsd:enumeration value="failed"/> 
    <xsd:enumeration value="terminated"/> 
    <xsd:enumeration value="null"/> 
  </xsd:restriction>
</xsd:simpleType>
\end{verbatim}

One element in the enumeration is reserved, \verb|null|, so the
enumeration must now enumerate all states as \verb|value1|,
\verb|value2|, and so on, for the entire list. This means the
enumeration names in the Java source no longer contains any value at
all, other than the position number in the set. This is inordinately
brittle, as any change to the enumeration could reorder the values,
without the code detecting a change.

\subsection{SOAP is not RMI}
\label{objections:soap-not-rmi}

JAX-RPC suffers from a greater flaw than those classically associated
with RPC invocation: it tries to make the communications look like
Java RMI. Java RMI is a simple and effective mechanism for connecting
Java classes running on different machines. It is an IDL-free
communication mechanism, which relies on introspection to create proxy
classes and to marshall classes. It works because the systems at both
ends are Java, usually different pieces of a single larger
application.

With synchronised versions of common code, objects can be trivially
serialised and sent over a network connection. Exceptions are just
another type of object, and so too can be sent over the wire. There is
no need for an IDL, as Java interface declarations can perform much of
the same role. And as the recipient is a remote object, state is
automatic.

JAX-RPC tries to reuse many of the programming patterns of RMI. For
example, the runtime will attempt to serialize classes marked as
\verb|serializable|, ignoring those fields marked as
\verb|transient|. It will even serialize complex compound objects where
possible. The user appears to have a reference to something like an
object, though one that represents the current conversation with an
endpoint, not a direct endpoint proxy.

% When a message gets delivered to its endpoint, the normal handler for
% dispatching the message creates an instance of the relevant Java class
% and then dispatches the request to it. The message is turned into an
% invocation of an instance of a remote object, which certainly looks
% like RMI, even if the lifecycle of the class is radically different.

SOAP strove to overcome many of the failings of precursor technologies
like CORBA and DCOM. These technologies work well over local area
networks, and enable rich bidirectional communications, but are not
completely cross platform\footnote{Albeit for political rather than
technical reasons}, and ended up being used to produce distributed
object systems that were too tightly coupled. Recall that one of our
key hopes from adopting SOAP (section \ref{introduction}) was to
maintain loose coupling.

\tocheck{While Java RMI provides convenience, the preceding paragraphs
should have made clear that one thing it does not provide in any way
is loose coupling. Interacting systems typically run from the same
codebase (indeed running them from different codebases can pose
significant problems). By trying to turn SOAP into RMI, we risk losing
the very things we turned to SOAP for in the first place.}

% Tight coupling has proven to be a bad thing in a distributed
% system. If components are too tightly coupled, it implies that the
% separate components have merged to become one large system, one which
% cannot be treated except as a whole. And in a sufficiently large
% system, it is impossible to co-ordinate the whole \cite{deutsch,
% jini}. The move towards SOAP and a service oriented architecture was
% advocated as a means of dealing with loose organisational coupling, by
% forcing a loose data coupling between applications.

\subsubsection{Blocking RPC is often inappropriate}
\label{objections:soap-not-rmi:blocking}

On a fast network, RPC invocation is often a good choice as a
communication paradigm. Other models of communication are harder to
code, and the benefits are not apparent. When working over long-haul
connections, however, or with large content (eg fifteen megabyte
attachments), the limitations of RPC become clear. 

Currently, our only option is to split network communication into a
separate thread from the rest of the program. While this works, it
provides the programmer no way to give the user effective feedback or
control over the communications. There is no way to receive progress
notifications or cancel an active call, even though the underlying
transport code invariably permits such features.

\tocheck{Again, following our principle that SOAP technologies should
attempt to work to the same goals as SOAP itself, we note that SOAP
was designed to work over long haul connections (and be simple). By
making it both difficult and complicated to work over a long
connection, JAX-RPC fails to meet these criteria for a SOAP
technology.}

\subsubsection{Fault processing}
\label{objections:soap-not-rmi:faults}

JAX-RPC tries to marshall Java faults over the network, in such a way
that they can be reconstituted at the far end into the same
fault\footnote{Before we criticise faults, we must note that one of
the authors has his name in the source of the {\tt AxisFault} class,
so may not be without blame himself.}. To manage this is a somewhat
complex process, as the class name of the fault must be exchanged as
the fault code.

We believe attempting to seamlessly marshall faults is a mistaken
approach.  By propagating the still controversial ``declare all
possible faults'' rule of Java into remote interfaces, it exposes
platform implementation details. If a service could only raise a
normal {\tt SOAPFault} unless its developers explicitly declared and
implemented custom WSDL fault elements, service definition would be
platform-neutral.

%% I don't understand the relevance of this so I cut it
% As well as the marshalled faults, the specification includes one
% standard fault, {\tt SoapFaultException}.

\tocheck{Exposing implementation details in the service interface, and
particularly by providing faults which are otherwise undeclared in the
service's interface definition, makes ensuring interoperability much
more difficult. We recall that interoperability was yet another reason
for adopting SOAP initially, and that this is yet another capability
of SOAP's which JAX-RPC fails to deliver upon.}

\input{wsdl}

\subsection{Implications}
\label{objections:implications}

What are the implications of these problems?

There are only two categories of people writing web services:
\tocheck{those who know XML and want to work with it, and those who
don't but end up doing so anyway. JAX-RPC provides a sugar coated
wrapping that encourages developers who are relatively unfamiliar with
XML to bite. Yet, as anyone who has written a web service of any
complexity knows, the XML must be faced and understood eventually. In
practice, the task of creating a real web service is made more
difficult, not less, by the huge volume of code JAX-RPC introduces.}

\tocheck{JAX-RPC only superficially benefits developers who do not want to work
with XML: by hiding all the details, and giving developers a model of
remote method calls via serialized Java graphs, JAX-RPC makes it
harder to write true, interoperable SOAP services.} Not only that, but
it introduces the O/X mapping problem, while retaining an invocation
model that is inappropriate for long-distance networks and slow
communications.

\tocheck{We argue that JAX-RPC greatly complicates users' software
by introducing a complex serialisation system (which, at least in
Apache Axis, is notoriously fickle.) The generation of WSDL from Java
code, which JAX-RPC encourages, by makes it very difficult to
maintain version consistency of an interfaces, and creates significant
interoperability problems. }

\tocheck{On top of all of this, for users who do want to work with XML
(typically those whose first project did not!) JAX-RPC is
inappropriate because it hides everything.} Trying to integrate custom
XML documents with JAX-RPC serialisations is possible, but very hard
work. In Apache Axis, DOM trees get recreated when assigning or
extracting them from {\tt SoapMessageElement} implementations.

% For the developers of proprietary implementations, this is not an
% issue, and the inherent complexity of the implentation results in a
% product the vendors can charge for. It is hard to get serialization,
% interoperability, WSDL processing and introspection right, and then
% there is the performance issue. Perhaps this is why both webMethods
% GLUE and the BEA JAX-RPC implementations have a reputation for being
% faster and more reliable than the open source version.

\subsubsection{The Future}
\label{objections:implications:future}

JAX-RPC has moved to become the centerpiece of enterprise Java, in
which distributed communications based on RMI and CORBA are considered
legacy protocols. That is not by itself a bad thing, but we believe
that migration to web services should be done from a position of
understanding the XML and the message. Instead, more and more
developers will feel obliged to write Web Service accessors to their
code, and in doing so, fall into the traps that JAX-RPC creates for
them.

The forthcoming 2.0 release of the JAX-RPC specification promises to
correct some of these flaws, but does it correct enough? An alternate
O/X mapping is used: JAX-B\footnote{Java Architecture for XML
Binding}, which is independent of the SOAP Stack, but still represents
a compile-time declaration of what XML is to be expected. The 2.0
release also retains the core metaphor of service invocation as method
invocation, with the payload of most invocations being Java objects
that are somehow mapped to XML content. The automated generation of
WSDL from Java source is retained, despite this problem having been
shown to be hard.

We understand the rationale for much of this. Working with raw XML is
hard.  Writing good XML Schema documents is hard. WSDL is exceedingly
painful to work with\footnote{We'd be tempted to say it's like an
interface definition language, only more complex and
verbose!}. However, we believe that if service developers do not write
their XSD and WSDL definitions of messages, they will never have
control of the messages that get sent over the wire, and without that
control, interoperability and XML-based processing will be hard.

%Instead the developers will be left at the mercy of JAX-RPC and JAX-B.
