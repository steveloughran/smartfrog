\section{The Fundamental Flaws of JAX-RPC}
\label{objections}

\subsection{The Object/XML Impedance Mismatch}
\label{objections:o-x}

JAX-RPC attempts to turn an XML document into Java classes, using
service specific mapping information. This is distinct from the kind
of mapping performed by DOM implementations, in that the classes are
``serialised'' from the XML tree, not merely created to represent it
(it is a semantic rather than syntactic mapping). This
serialisation/deserialisation is an essential part of JAX-RPC,
allowing method calls to be translated into SOAP requests, and
responses translated back into Java objects.

We believe that the term \emph{serialisation} downplays the nature of
the problem, likening it to the more tractable problem of creating a
non-portable persistence format for a class. Instead, we prefer to use
the term \emph{O/X mapping} to emphasise the similarities it has with
the heavily studied \emph{O/R mapping problem}\footnote{
\emph{``Object-relational mapping is the Vietnam of Computer Science''}
- Ted Neward, 2004.
%{\small \tt http://www.neward.net/ted/weblog/index.jsp?date=20041003#1096871640048}
}. 
Over a decade has been spent trying to map between records in relational
databases and language-level objects, and there is still no sign of an ideal
solution. There is significantly less experience in mapping between XML and
objects, and rather than drawing on the experiences of the many failed attempts
at O/R mapping, O/X mapping technologies appear destined to share a similar
evolution.

At first glance, O/X mapping appears simple: create a Java object for
each XML element, building a DAG\footnote{directed, acyclic graph}
when serialising to RPC/encoded SOAP or a tree with document/literal
messages. Read or write between attributes and class fields, bind to
children and the conversion is complete. If only it were so
straightforward. There is a fundamental difference between the type
systems of XML (especially that of XML Schema) and that of Java, which
makes any mapping both complex and brittle.

\subsubsection{Binding XML Elements to Java Classes}
\label{objections:o-x:xml-classes}

The language of XML Schema is much richer than the object model of
Java. In Java, inheritance can extend a type, and change some existing
semantics, but derivation by restriction is not explicitly
supported. Java, in common with many object oriented programming
environments, allows derived types to expand upon the capabilities of
their parents. XML schema allows one to extend a type by restricting
it, constraining attribute and element values. Java has no intrinsic
model for this type of constraint.

This is a fundamental difference which means that one cannot
accurately model an XSD type hierarchy in a Java class hierarchy. All
one can do is inaccurately model it.Here, for example, a postcode is
modelled by restricting a string:

%\todo{more entertaining example. something like `us-beer' is a 
%restriction of type `beer' where alcohol is a removed attribute}

\begin{verbatim}
<simpleType name="UKPostcode">
  <restriction base="xsd:string">
    <pattern value="[A-Z]{2}\d \d[A-Z]{2}"/>
  </restriction>
</simpleType>
\end{verbatim}

The actual result is going to be a simple class of type {\tt String}:
all restriction information will be lost in the transformation from
XML Schema to Java. This is a fundamental difference, and one which
would appear to remain intractable except in special cases.

Note that XML Schema offers other type extension mechanisms, such as
substitution and derivation. These mechanism have similar issues with mapping
to the inheritance and type model of Java. 

\subsubsection{Mapping XML Names to Java Identifiers}
\label{objections:o-x:names}

Not all XML names can be turned into Java identifiers.  XML names may
begin with a letter in one of many Unicode languages, an ideograph or
an underscore (``\_'') . They can be followed by any of the same
characters, and also a hyphen ``-'' or a full stop ``.''. Some
examples are: {\tt schr\"odinger}, {\tt \_unknown.type-set}, and {\tt
String}.

Java identifiers almost comprise a proper subset of XML
names\footnote{XML names beginning in ``xml'' (any case) are reserved.}.
Because of the much greater range of allowable XML identifiers, the
system will often need to perform a non-trivial mapping from the XML
names to valid class and package names. Package names are typically
derived from namespace URLs if not overridden, as discussed in section
\ref{objections:o-x:namespaces}.

The translation is inordinately brittle: whenever a new
version of Java is released, the logic must be updated to avoid new
reserved words (like {\tt assert} and {\tt enum}), or the generated
code will no longer compile in the enhanced language. Needless to say,
such an upgrade will break any existing code that linked to old
classes which made use of these names.

\subsubsection{Enumerations}
\label{objections:o-x:enum}

One specific example that deserves special mention is how {\tt
xsd:enumeration} declarations are mapped to Java. Before Java 1.5,
there was no explicit {\tt enum} clause in the language, and the
JAX-RPC approach to SOAP enumerations is based on a
workaround. However, the problem of mapping enumerations from XML to
Java is unchanged, regardless of the language version used: generate a
set of identifiers, one for each value in the enumeration.

This appears a straightforward example of how O/X mapping should
work. But what if the value of the one of the enumeration types is a
reserved word?  Our API (from section \ref{intro:experience} contains
a lifecycle state machine like this:

\begin{verbatim}
<xsd:simpleType name="lifecycleStateEnum">
  <xsd:restriction base="xsd:string"> 
    <xsd:enumeration value="initialized"/> 
    <xsd:enumeration value="running"/> 
    <xsd:enumeration value="failed"/> 
    <xsd:enumeration value="terminated"/> 
    <xsd:enumeration value="null"/> 
  </xsd:restriction>
</xsd:simpleType>
\end{verbatim}

One element in this enumeration is reserved: {\tt null}. However, the
JAX-RPC specification states that an implementation must now enumerate
all states as {\tt value1}, {\tt value2}, and so on, for the entire
list.  The enumeration names in the Java source no longer contain any
informative value at all, other than a position number in the
set. Any change to the enumeration
could reorder the values, without this change being detected by code
that used the enumeration. The defect would only show up in interoperability
testing. 

\subsubsection{Unportable types}
\label{objections:o-x:types}

Some Java types are by nature explicitly unportable. One would not
expect to be able to have a SOAP runtime serialise a database
connection instance and have it reconstituted in working order at the
far end. One might hope that a {\tt java.util.Hashtable} could be
translated into some structure that could be turned into a
platform-specific equivalent at the far end. But surely a {\tt
java.util.Calendar} object could be sent over the wire, as it
apparently maps so well to the {\tt xsd:dateTime} type in XML Schema?

We can certainly send such times. They are readable on the wire, and
are mapped into whatever a remote endpoint uses to represent
time. Unfortunately, due to differences in expectations between Java
and .NET date/time classes, we cannot guarantee that the same time
will be received at the far end. If both client and server are in the
UTC time zone all works well, but if either of them are in a different
location, hours appear to get added or removed. Clearly a different
expectation regarding time processing is taking place.

This is an insidious defect as it is not apparent on any
testing which takes place in the same time zone, or between Java
implementations. It is only apparent when remote callers, using
different platforms, attempt to use the service.


\subsubsection{Serialising a Graph of Objects}
\label{objections:o-x:graphs}

XML is a hierarchical data structure, and can only describe trees or
lists or lists of data. Java classes almost invariably refer to other
objects, often creating cyclic graphs of objects. If such a cyclic
graph is to be mapped into XML, the mapping infrastructure must
recognise the cycle, otherwise the it would enter a non-terminating
loop. Once the cycle is recognised, it must be addressed. The options
appear to be:
\begin{enumerate}
\item Signal an error.
\item Insert cross references into the XML message, for processing by
the mapper at the destination. 
\item Break the graph by duplicating content in the XML.
%% This doesnt differ from 2 in any obvious way?
%\item Insert explicit relationship information into the message.
\end{enumerate}

The only one of these solutions which seamlessly marshals cyclic
graphs of objects is the second: inserting cross references into the
XML. The SOAP solution for this is SOAP Section 5 encoding, as
documented in \cite{spec:SOAP1.1}. This linking mechanism is only
supported in RPC/encoded messages; the document/literal message format
does not allow it.

JAX-RPC was originally based on RPC/encoded messages, but the
alternate representation, document/literal, is now broadly agreed to
be more flexible and generally superior. There is no way to marshal a
cyclic graph into a document/literal message without custom
code\footnote{This problem is covered in detail in ``Effective
Enterprise Java'' \cite{neward:EEJ}, where it is termed
\emph{the object-hierarchical impedance mismatch}.}. Any technology
that attempts to map XML to a cyclic object graph will suffer from the
same problem.

\subsubsection{XML Metadata and Namespaces}
\label{objections:o-x:namespaces}

As discussed in the previous sections, XML Schema provides a type
system that is much richer than that of Java. One aspect not mentioned
so far is the relationship between XML metadata, notably namespaces,
and Java classes.

The problem is essentially as follows: each node in an XML message can
have attached to it a namespace. There is no related construct in Java
which can model this accurately. The choice that is normally made is
to model it inaccurately by package names (mapping namespaces to Java
packages provides many of the problems discussed in section
\ref{objections:o-x:names}, since these are more examples of identifiers). 

The problems that typically arise are of two kinds:
\begin{enumerate}
\item Mapping an incoming message to a web service object requires
guessing the namespace of either the operation itself or its
parameters. This guessing can be wildly inaccurate when the web
service's Java interface was generated from WSDL using package
renaming.
\item When dynamic invocation is desired (service invocation without
the use of pre-built stub classes) it can be very difficult to
determine the correct namespaces for service invocations (the WSDL
typically leaves this unspecified, meaning that for JAX-RPC services
the WSDL is not a complete description of the service interface).
\end{enumerate}

If more metadata were recorded with generated types, this problem would not
arise. We therefore expect that future versions of JAX-RPC will address this 
problem by way of the code annotation facility recently added to the Java
language. 

\subsubsection{Message validation}
\label{objections:o-x:validation}

When a message is received, the serialised form is generated and
passed to the handlers for processing. No validation of the incoming
XML against the message schema is performed, and in particular any
restrictions on the number of times an item is required are not
checked. This forces the implementation code to follow one of two
paths:
\begin{enumerate}

\item It could ignore the problem. If the client code and functional
tests do not generate invalid messages (as is likely if they are also
all written in JAX-RPC) then the problem will not be noticed, only
only surfacing when a third party attempts to use the service.

\item The developers could write procedural logic to verify that
the Java classes representing a deserialised message have a
structure that matches their expectation based on the schema. This
requires an understanding of the schema, knowledge of the
serialisation mapping and potential trouble spots, the willingness to
write the tests to validate this extra logic, and most of all, time.

\end{enumerate}

We suspect that most services err on the side of ignorance, and do not
validate their incoming messages adequately. This brings into question
their interoperability.

\subsubsection{Inadequate Mixing of XML and Serialised Data}
\label{objections:o-x:mixing}

JAX-RPC and JAXM are two different views of the world. What does JAX-RPC
do when it encounters a piece of random XML in a message? It creates a
SAAJ {\tt Node} to describe that part of the tree.

From that point on, the tree below the node is permanently isolated
from the JAX-RPC model: the developer has sailed off the edge of the
JAX-RPC world, and fallen into the universe of XML. Any O/X mappings
which may exist for data within this piece of the message are now
inaccessible, all that is left is the low-level JAXM API. 

This behaviour makes it appear that incorporating arbitrary XML within
a SOAP message is not an approved action, yet the ability to easily
incorporate such XML is a key aspect of SOAP's flexibility and a key
to its being more extensible and less brittle than its predecessors.

\subsubsection{Fault processing}
\label{objections:soap-not-rmi:faults}

JAX-RPC tries to marshal Java faults over the network in such a way
that they can be reconstituted at the far end into the same fault.
This is a somewhat complex process to manage, as the class name of the
fault must be exchanged as the fault code. Since faults are often
immutable, the standard serialisation mechanism of named getter and
setter methods must be replaced by a more exotic one: getter methods
are used to extract the contents of a fault, a fault which must offer
a constructor that takes every attribute in a parameter of the same
name\footnote{This implicitly requires code to be built with debugging
information, so that the bytecode can be analysed to determine
parameter names.}.

We believe that attempting to seamlessly marshal faults is a mistaken
approach.  By propagating the still controversial ``declare all
possible faults'' rule of Java into remote interfaces, it exposes
platform implementation details. If a service could only raise a
normal {\tt SOAPFault} unless its developers explicitly declared and
implemented custom WSDL fault elements, service definition would be
platform-neutral.


Exposing implementation details in the service interface makes ensuring
interoperability much more difficult. We recall that interoperability
was a major reason for adopting SOAP initially, and that this is yet
another capability of SOAP's which JAX-RPC fails to deliver upon.

\subsection{SOAP is not just RPC}
\label{objections:soap-not-just-rmi}

SOAP's parentage includes XML-RPC \cite{winer:xmlrpc} and (indirectly)
COM/DCOM \cite{dbox:SoapHistory,dbox:com}and CORBA \cite{vinoski:CORBA}. It was clearly
designed at its outset to be a form of remote procedure call in XML,
over HTTP. Over time, the world-view that lead to that choice has
changed. Though it is often presented as a form of RPC, it is coming
to be seen that it is more powerful when viewed as a system where
arbitrary XML documents are exchanged between parties, potentially
asynchronously, and potentially via intermediaries.

In this world, the programming paradigms that seemed appropriate for
an RPC infrastructure look out of place. On a fast network, RPC
invocation is often a good choice, as other models of communication
are harder to code, and their benefits are not readily apparent. A complex
communication can be modelled in a few lines of code, rather than a state
machine, and the synchronous nature of the communication makes it easier to
to build a model of the state of the remote system.  

When we begin to work over long-haul connections, however, or with
large content (e.g.\ fifteen megabyte attachments), the limitations of
RPC become clear. The greatest of these is that RPC is
synchronous. Although asynchronous behaviours can, with some
difficulty, be introduced, this is not the natural way for RPC to
behave. As content becomes larger and the network latency increases,
the problems posed by synchronous calls become much more acute.

Currently, our only option is to split network communication into a
separate thread from the rest of the program. While this works, it
provides the programmer no way to give the user effective feedback or
control over the communications. There is no way to receive progress
notifications or cancel an active call, even though the underlying
transport code invariably permits such features. This has caused
problems when one of the authors wrote a GUI front end to a service
that could accept 15-30MB CAD files: while multithreading could keep
the UI responsive, there was no way to present an upload progress
indicator or offer a cancel button. These are both features one
expects in a web browser.

Again, following our principle that SOAP technologies should uphold
the same desiderata as SOAP itself, we note that one reason SOAP was
adopted was to make working over long haul connections simpler. By
making it both difficult and complicated to work over a long
connection, JAX-RPC fails to meet these criteria for a SOAP
technology.

\subsection{SOAP is not RMI}
\label{objections:soap-not-rmi}

JAX-RPC suffers from a greater flaw than those classically associated
with RPC invocation: it tries to make the communications look like
Java RMI. Java's RMI system is a simple and effective mechanism for
connecting Java classes running on different machines. It is an
IDL-free communication mechanism, which relies on introspection to
create proxy classes and to marshal classes. It works because the
systems at both ends are Java, usually different pieces of a single
larger application. Even then, it works best if both ends are running
the same version of all classes.

With synchronised versions of common code, objects can be trivially
serialised and sent over a network connection. Exceptions are just
another type of object, and so too can be sent over the wire. There is
no need for an IDL, as Java interface declarations can perform much of
the same role. And as the recipient is a remote object, state is
automatic.  One can even keep code synchronised by using a special
class loader, one that fetches code from jointly-accessible URLs.

JAX-RPC tries to reuse many of the programming patterns of RMI. For
example, the runtime will attempt to serialise classes marked as
{\tt Serializable}, ignoring those fields marked as
{\tt transient}. It will even serialise complex compound objects where
possible. The user appears to have a reference to something like an
object, though one that represents the current conversation with an
endpoint, not a direct endpoint proxy.

SOAP strove to overcome many of the failings of precursor technologies
like CORBA and DCOM. These technologies work well over local area
networks, and enable rich bidirectional communications, but are not
completely cross platform\footnote{Arguably for political rather than
technical reasons}, and ended up being used to produce distributed
object systems that were too tightly coupled. Recall that one of our
key hopes from adopting SOAP (section \ref{introduction}) was to
enable loose coupling between components of a distributed system.

While Java RMI provides convenience, the one thing it does not provide in any way
is loose coupling. Interacting systems typically run from the same
codebase, and each element of the distributed system usually contains many 
implicit assumptions about the rest of the system. By trying to turn SOAP into RMI,
we imitate this architecture, and risk losing
the very things we turned to SOAP for in the first place.

% Tight coupling has proven to be a bad thing in a distributed
% system. If components are too tightly coupled, it implies that the
% separate components have merged to become one large system, one which
% cannot be treated except as a whole. And in a sufficiently large
% system, it is impossible to co-ordinate the whole \cite{deutsch,
% JINI}. The move towards SOAP and a service oriented architecture was
% advocated as a means of dealing with loose organisational coupling, by
% forcing a loose data coupling between applications.

\input{wsdl}


