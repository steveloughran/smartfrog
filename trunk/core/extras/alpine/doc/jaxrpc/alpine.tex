\section{Alpine: a proposed alternative}
\label{alpine}

We are in the preliminary stages of designing an alternative SOAP
stack for Java, by the name of \emph{Alpine}.

\subsection{Manifesto}
\label{alpine:manifesto}

Our goal is to create a SOAP stack that is easy to use, robust, and
maintainable. In order to do this, we are adopting an XML centric
approach. Alpine will make no attempt to map between XML and custom
Java classes, instead providing access to the SOAP messages using
modern XML support libraries, which make it easy to navigate an XML
document. By avoiding O/X mapping we greatly decrease the volume and
complexity of our code. Some may argue this will make Alpine more
difficult to use, but experience shows us that simpler systems are
typically more straightforward to work with, as they react in more
predictable ways.

If a WSDL description of an Alpine-hosted service is required, the
user will be required to write it: as we concluded in section
\ref{objections:wsdl-gen} generating WSDL from Java introduces
unwanted implementation dependencies and hampers interoperability.

What will Alpine consist of then? With so much stripped out, a SOAP
stack gets reduced to its essentials: a system for managing the flow
of messages through a set of handlers, and libraries to handle
transport across supported the protocols. Core compliance with the
SOAP protocol will be provided, namely envelope validation and
\verb|mustUnderstand| processing of headers. Developers will be
expected to use XPath specifications to work with contents of the
message; we will depend upon XOM for our XML binding
\cite{harold:xom}.

By removing extraneous yet useful features, we introduce dependencies
on many other components to work correctly. Yet we also reduce
development and support effort. This is not going to be a SOAP stack
for use by anyone who wants to make SOAP look like RMI, nor for anyone
who wants to ignore the format of the messages sent or over the wire.
Instead, Alpine will provide the basic housekeeping and handler
chain management to make life simpler for web service developers.

\subsection{Design Goals}
\label{alpine:design}

The full design goals are as follows:

\begin{enumerate}

\item Stay in the XML Space as much as possible
\item Take advantage of as much leading edge infrastructure as we can
\item Adopt the the handler chain pattern of Axis/JAX-RPC
\item Target SOAP1.2 (POST) only, WS-I 1.1
\item Document/literal only, not RPC/encoded
\item Run server-side, client-side, and as an intermediary. 
\item No support for JAX-RPC or JAX-M/SAAJ APIs.
\item Configurable only procedurally or through JMX.
\item Permit dynamic handler chain configuration during message processing.
\item One supported parser %: Xerces
\item Java 1.5 or later 

\item No provision of side features such as a built in HTTP server, or
a declarative configuration mechanism. These are delegated to other products.
\end{enumerate}

We believe the core of this design is likely to resemble JAX-M/SAAJ in
in terms of classes, integrated with a handler chain based on the
JAX-RPC/Axis model.

\subsection{XSD validation}
\label{alpine:validation}
An XML schema document, as used to describe a document/literal
payload, can contain many declarations about what constitutes a valid
XML document. \emph{Restrictions} can restrict the type of a value,
such as the range of an integer from zero to ten. The \verb|minOccurs|
and \verb|maxOccurs| declarations are used to declare what allowed
number of occurrences of an element are. None of these values are
used. Restricted integer types are just mapped to normal integers,
while element occurrence declarations are ignored.

This means that the set of XML documents which an endpoint can receive
is significantly larger than the set of XML documents which its XML
schema considers valid. With no built-in validation, developers must
either write both validation logic and corresponding tests themselves,
or ignore the problem. Given that there is no warning that the problem
occurs, we suspect that ignorance is the common process. 

Not writing the logic to recognise and reject illegal documents is
unlikely to show up in development, especially if a test-centric
process is not followed, but is inevitable once a service goes live,
and callers using other languages invoke the service. Such insidious
defects, defects that only show up in production, are never welcome.

We note that there is a trivial solution to this problem, one that is
common to other XML stacks. It is: validate incoming messages against
the XML schema of the service. This is not done for performance, yet
the effect is to hide defects.

Our intent is that Alpine will validate documents against their schema,
through a handler that can be added to the chain. It will be able to 
validate outbound messages as well as incoming ones, which should be useful
during development. 


\subsection{A Community SOAP Stack}
\label{alpine:community}
From the perspective of an open source project, JAX-RPC creates many
problems as it isolates all the XML in the implementation. This
creates a huge gulf between the exceedingly complex implementation
code (low level SAX and DOM processing, code generation from WSDL
metadata, WSDL generation from introspection, fault processing) and
the end user code.  This makes it hard for end users to become
developers, something that open source platforms depend on.  

An open source project succeeds from the contributions of its users,
and so depend upon users who are able and willing to understand the
implementation. JAX-RPC, by its very nature, places too firm a divide
between end users and developers.

We can see the consequences of this on the user mailing list for
Apache Axis. All too often, someone is confused by the errors that
occur when they try to do something that they expect to work like
Java RMI, such as sending low-level classes like a \verb|java.io.File|
instance, or a \verb|javax.swing.JPanel|. The latter is serialisable
in RMI, yet clearly does not make sense for an interoperable web
service.

While it would be easy to laugh at their na\"{i}ve and unrealistic
expectations, we have to recognise that these users have been led to
such expectations through a combination of marketing ("Web Services!
They're easy!") and the fact that JAX-RPC creates the illusion of
being just like RMI. It is often easy to write code that looks like a
SOAP service, only to try and deploy it and find at runtime that the
introspection system rejects Java classes as unacceptable, or that the
serialisation logic raises deserialisation exceptions when inbound
messages are processed. A quick perusal of the Apache Axis user list
\footnote{{\small \tt http://mail-archives.apache.org/eyebrowse/SummarizeList?listId=209}}
will demonstrate that these are amongst the most common problems.

With Alpine, we hope to avoid reaching a similar situation, where a
small core of developers maintain a codebase for a much larger user
base, for whom the operation of the stack is essentially ``black
magic''.

\subsection{The implications of Alpine}

If Alpine succeeds, it will be a SOAP stack that requires advanced
knowledge of XML before it can be used. This might appear to be a
barrier to the widespread adoption of the tool, and perhaps it will
prove so. Unlike commercial SOAP vendors, we have no fiscal benefit in
making our product broadly usable. We will, however, have a SOAP
implementation that all users should be able to understand and
maintain.  Furthermore, we believe that a good understanding of XML is
needed for any robust web service, and by forcing developers to
acquire that skill early on, we avoid them having to learn it just
before their shipping deadlines are missed.

This may seem somewhat ruthless: to deny the right to write web
services to developers who are and wish to remain ignorant of XML.
However, we have to ask: \emph{if they do not want to know XML, why are
they writing Web Services?}. If the developers want to use a less portable,
more brittle, remote method invocation system, they would be better off
using a stable technology such as Java RMI or CORBA.
